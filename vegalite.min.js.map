{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vegalite.js","src/Encoding.js","src/axis.js","src/compile.js","src/consts.js","src/data.js","src/globals.js","src/legends.js","src/marks.js","src/scale.js","src/schema.js","src/schemautil.js","src/time.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","merge","schema","Encoding","axis","compile","data","legends","marks","scale","./Encoding","./axis","./compile","./consts","./data","./globals","./legends","./marks","./scale","./schema","./util",2,"marktype","enc","config","encDefaults","instantiate","properties","cfgDefaults","cfg","k","DEFAULTS","this","_marktype","_enc","_cfg","proto","prototype","is","m","has","x","undefined","field","nodata","nofn","aggr","bin","name","fn","fieldName","fieldTitle","legend","any","all","keys","reduce","init","forEach","type","isType","xt","toSpec","excludeConfig","spec","duplicate","dataTypeNames","toShorthand","map","v","join","parseShorthand","shorthand","split","shift","enctype","dataTypes","indexOf","substr","timefns","fromSpec","extraCfg",3,"axis_title","encoding","title","Y","titleOffset","names","props","X","defs","opt","push","def","isCol","COL","isRow","ROW","Q","ticks","grid","layer","opacity","value","majorTicks","offset","xAxisMargin","orient","O","T","labels","angle","align","baseline","text",4,"getCardinality","encType","stats","bins","getbins","stop","start","step","cardinality","setSize","hasRow","hasCol","hasX","hasY","colCardinality","rowCardinality","cellWidth","cellHeight","cellPadding","bandPadding","width","height","xCardinality","yCardinality","facet","group","mdef","stack","enter","facetKeys","cellAxes","fill","from","transform","error","y","unshift","axesGrp","groupdef","axes","apply","scales","concat","update","trans","subfacet","details","g","COLOR","by","binning","vv","d","preaggregatedData","output","maxbins","MAX_BINS","aggregates","dims","meas","detail","facets","op","vals","groupby","fields","TEXT","expr","aggregated","stacking","dim","val","idx","stacked","STACKED","source","TABLE","point","y1","y0","markdef","mark","p","prop","_name","template","size","format","dataUrl","getUrl","url","parse","padding","time","hasAgg","hasAggregate","lineType","line","aggResult","hasDetails","./time",5,"encodingTypes","SIZE","SHAPE","ALPHA","cellBackgroundColor","yAxisMargin","textCellWidth","bandSize","pointSize","pointShape","strokeWidth","color","textColor","textAlign","textBaseline","textMargin","font","fontSize","fontWeight","fontStyle","_thickOpacity","_thinOpacity","_xZero","_xReverse","_yZero","_yReverse","timeScaleNice","timeScaleLabelLength",6,"obj","binSize","query","table","JSON","stringify","getSchema","datum","isNaN","Date","getStats","stat","minmax","uniq","count",7,"INDEX",8,"_legends","console","shape","_legend",9,"bar_props","x2","xc","y2","yc","point_props","stroke","line_props","area_props","filled_point_props","text_props","dx","bar","requiredEncoding","supportedEncoding","row","col","alpha","area","circle","square",10,"scale_domain","range","domain","reverse","scale_range","bandWidth","zero","round","nice","outerPadding","points","sort",11,"enum","supportedEnums","supportedTypes","scale_type","default","required","clone","typicalField","description","onlyOrdinalField","axisMixin","legendMixin","textMixin","weight","minimum","viewport","items","_minWidth","_minHeight","dataFormatType","useVegaServer","vegaServerTable","vegaServerUrl","$schema","./schemautil",12,"isEmpty","Object","requried","instance","child","difference","defaults","changes","c","hasOwnProperty","constructor","Array",13,"timeFields","timeFn","tf","formula","date","labelLength",14,"arguments","Infinity","j","find","list","pattern","filter","min","max","arr","dest","src","vg","msg"],"mappings":"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","file":"vegalite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var globals = require(\"./globals\"),\n    util = require(\"./util\"),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.schema = require('./schema');\nvl.Encoding = require('./Encoding');\nvl.axis = require('./axis');\nvl.compile = require('./compile');\nvl.data = require('./data');\nvl.legends = require('./legends');\nvl.marks = require('./marks')\nvl.scale = require('./scale');\n\nmodule.exports = vl;\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar globals = require(\"./globals\"),\n    util = require(\"./util\"),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.schema = require('./schema');\nvl.Encoding = require('./Encoding');\nvl.axis = require('./axis');\nvl.compile = require('./compile');\nvl.data = require('./data');\nvl.legends = require('./legends');\nvl.marks = require('./marks')\nvl.scale = require('./scale');\n\nmodule.exports = vl;\n\n},{\"./Encoding\":2,\"./axis\":3,\"./compile\":4,\"./consts\":5,\"./data\":6,\"./globals\":7,\"./legends\":8,\"./marks\":9,\"./scale\":10,\"./schema\":11,\"./util\":14}],2:[function(require,module,exports){\n\"use strict\";\n\nvar global = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  schema = require('./schema');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config) {\n    // TODO: caching\n    var encDefaults = schema.util.instantiate(schema.schema.properties.enc);\n    var cfgDefaults = schema.util.instantiate(schema.schema.properties.cfg);\n\n    // Hack\n    for (var k in consts.DEFAULTS) {\n      cfgDefaults[k] = consts.DEFAULTS[k];\n    }\n\n    // remove field defs that we don't use in encoding\n    for (var k in encDefaults) {\n      if (!enc[k]) {\n        delete encDefaults[k];\n      }\n    }\n\n    this._marktype = marktype;\n    this._enc = schema.util.merge(encDefaults, enc);\n    this._cfg = schema.util.merge(cfgDefaults, config);\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(x) {\n    return this._enc[x] !== undefined;\n  };\n\n  proto.enc = function(x){\n    return this._enc[x];\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(x, nodata, nofn) {\n    if (!this.has(x)) return null;\n\n    var f = (nodata ? \"\" : \"data.\");\n\n    if (this._enc[x].aggr === \"count\") {\n      return f + \"count\";\n    } else if (!nofn && this._enc[x].bin) {\n      return f + \"bin_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].aggr) {\n      return f + this._enc[x].aggr + \"_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].fn){\n      return f + this._enc[x].fn + \"_\" + this._enc[x].name;\n    } else {\n      return f + this._enc[x].name;\n    }\n  };\n\n  proto.fieldName = function(x){\n    return this._enc[x].name;\n  }\n\n  proto.fieldTitle = function(x){\n    if (this._enc[x].aggr) {\n      return this._enc[x].aggr + \"(\" + this._enc[x].name + \")\";\n    } else {\n      return this._enc[x].name;\n    }\n  }\n\n  proto.scale = function(x){\n    return this._enc[x].scale || {};\n  }\n\n  proto.axis = function(x){\n    return this._enc[x].axis || {};\n  }\n\n  proto.aggr = function(x){\n    return this._enc[x].aggr;\n  }\n\n  proto.bin = function(x){\n    return this._enc[x].bin;\n  }\n\n  proto.legend = function(x){\n    return this._enc[x].legend;\n  }\n\n  proto.fn = function(x){\n    return this._enc[x].fn;\n  }\n\n  proto.any = function(f){\n    return util.any(this._enc, f);\n  }\n\n  proto.all = function(f){\n    return util.all(this._enc, f);\n  }\n\n  proto.length = function(){\n    return util.keys(this._enc).length;\n  }\n\n  proto.reduce = function(f, init){\n    var r = init, i=0;\n    for (k in this._enc){\n      r = f(r, this._enc[k], k, this._enc);\n    }\n    return r;\n  }\n\n  proto.forEach = function(f) {\n    var i=0, k;\n    for (k in this._enc) {\n      f(k, this._enc[k], i++);\n    }\n  };\n\n  proto.type = function(x) {\n    return this.has(x) ? this._enc[x].type : null;\n  };\n\n  proto.isType = function(x, t) {\n    var xt = this.type(x);\n    if (xt == null) return false;\n    return (xt & t) > 0;\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig){\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for(var e in enc){\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc\n    }\n\n    if(!excludeConfig){\n      spec.cfg = util.duplicate(this._cfg)\n    }\n\n    return spec;\n  };\n\n  proto.toShorthand = function(){\n    var enc = this._enc;\n    return this._marktype + \".\" + util.keys(enc).map(function(e){\n      var v = enc[e];\n        return e + \"-\" +\n          (v.aggr ? v.aggr+\"_\" : \"\") +\n          (v.fn ? v.fn+\"_\" : \"\") +\n          (v.bin ? \"bin_\" : \"\") +\n          (v.name || \"\") + \"-\" +\n          consts.dataTypeNames[v.type];\n      }\n    ).join(\".\");\n  }\n\n  Encoding.parseShorthand = function(shorthand, cfg){\n    var enc = shorthand.split(\".\"),\n      marktype = enc.shift();\n\n    enc = enc.reduce(function(m, e){\n      var split = e.split(\"-\"),\n        enctype = split[0],\n        o = {name: split[1], type: consts.dataTypes[split[2]]};\n\n      // check aggregate type\n      for(var i in schema.aggr.enum){\n        var a = schema.aggr.enum[i];\n        if(o.name.indexOf(a+\"_\") == 0){\n          o.name = o.name.substr(a.length+1);\n          if (a==\"count\" && o.name.length === 0) o.name = \"*\";\n          o.aggr = a;\n          break;\n        }\n      }\n      // check time fn\n      for(var i in schema.timefns){\n        var f = schema.timefns[i];\n        if(o.name && o.name.indexOf(f+\"_\") == 0){\n          o.name = o.name.substr(o.length+1);\n          o.fn = f;\n          break;\n        }\n      }\n\n      // check bin\n      if(o.name && o.name.indexOf(\"bin_\") == 0){\n        o.name = o.name.substr(4);\n        o.bin = true;\n      }\n\n      m[enctype] = o;\n      return m;\n    }, {});\n\n    return new Encoding(marktype, enc, cfg);\n  }\n\n  Encoding.fromSpec = function(spec, extraCfg) {\n    var enc = util.duplicate(spec.enc);\n\n    //convert type from string to bitcode (e.g, O=1)\n    for(var e in enc){\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, util.merge(spec.cfg, extraCfg || {}));\n  }\n\n  return Encoding;\n\n})();\n\n},{\"./consts\":5,\"./globals\":7,\"./schema\":11,\"./util\":14}],3:[function(require,module,exports){\nvar globals = require('./globals'),\n  util = require('./util');\n\nvar axis = module.exports = {};\n\naxis.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s===X || s===Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function (name, encoding, opt){\n  var type = name;\n  var isCol = name==COL, isRow = name==ROW;\n  if(isCol) type = \"x\";\n  if(isRow) type = \"y\";\n\n  var axis = {\n    type: type,\n    scale: name,\n  };\n\n  if (encoding.isType(name, Q)) {\n    //TODO(kanitw): better determine # of ticks\n    axis.ticks = 3;\n  }\n\n  if (encoding.axis(name).grid) {\n    axis.grid = true;\n    axis.layer = \"back\";\n  }\n\n  if (encoding.axis(name).title) {\n    //show title by default\n\n    axis = axis_title(axis, name, encoding, opt);\n  }\n\n  if(isRow || isCol){\n    axis.properties = {\n      ticks: { opacity: {value: 0} },\n      majorTicks: { opacity: {value: 0} },\n      axis: { opacity: {value: 0} }\n    };\n  }\n  if(isCol){\n    axis.offset = [opt.xAxisMargin || 0, encoding.config(\"yAxisMargin\")];\n    axis.orient = \"top\";\n  }\n\n  if (name==\"x\" && (encoding.isType(name, O|T) || encoding.bin(name))) {\n    axis.properties = {\n      labels: {\n        angle: {value: 270},\n        align: {value: \"right\"},\n        baseline: {value: \"middle\"}\n      }\n    };\n  }\n\n  // add custom label for time type\n  if (encoding.isType(name, T)) {\n    var fn = encoding.fn(name),\n      properties = axis.properties = axis.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    switch (fn) {\n      case \"day\":\n      case \"month\":\n        text.scale = \"time-\"+fn;\n        break;\n    }\n  }\n\n  return axis;\n};\n\nfunction axis_title(axis, name, encoding, opt){\n  axis.title = encoding.fieldTitle(name);\n  if(name==Y){\n    axis.titleOffset = 60;\n    // TODO: set appropriate titleOffset\n    // maybe based on some string length from stats\n  }\n  return axis;\n}\n\n},{\"./globals\":7,\"./util\":14}],4:[function(require,module,exports){\nvar globals = require('./globals'),\n  util = require('./util'),\n  axis = require('./axis'),\n  legends = require('./legends'),\n  marks = require('./marks'),\n  scale = require('./scale'),\n  time = require('./time');\n\nvar compile = module.exports = function(encoding, stats) {\n  var size = setSize(encoding, stats),\n    cellWidth = size.cellWidth,\n    cellHeight = size.cellHeight;\n\n  var hasAgg = encoding.any(function(v, k){\n    return v.aggr !== undefined;\n  });\n\n  var spec = template(encoding, size, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdef = markdef(mark, encoding, {\n      hasAggregate: hasAgg\n    });\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  group.marks.push(mdef);\n  // TODO: return value not used\n  binning(spec.data[0], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if(!preaggregatedData){\n    spec = time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec.data[0], encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isType(X, Q | T) && encoding.isType(Y, O)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    mdef.from.transform = [{type: \"sort\", by: encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding);\n    group.legends = legends.defs(encoding);\n  }\n  return spec;\n};\n\nfunction getCardinality(encoding, encType, stats){\n  var field = encoding.fieldName(encType);\n  if (encoding.bin(encType)) {\n    var bins = util.getbins(stats[field]);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  return stats[field].cardinality;\n}\n\nfunction setSize(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y);\n\n  // HACK to set chart size\n  // NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  // One solution is to update Vega to support auto-sizing\n  // In the meantime, auto-padding (mostly) does the trick\n  //\n  var colCardinality = hasCol ? getCardinality(encoding, COL, stats) : 1,\n    rowCardinality = hasRow ? getCardinality(encoding, ROW, stats) : 1;\n\n  var cellWidth = hasX ?\n      +encoding.config(\"cellWidth\") || encoding.config(\"width\") * 1.0 / colCardinality :\n      encoding.marktype() === \"text\" ?\n        +encoding.config(\"textCellWidth\") :\n        +encoding.config(\"bandSize\"),\n    cellHeight = hasY ?\n      +encoding.config(\"cellHeight\") || encoding.config(\"height\") * 1.0 / rowCardinality :\n      +encoding.config(\"bandSize\"),\n    cellPadding = encoding.config(\"cellPadding\"),\n    bandPadding = encoding.config(\"bandPadding\"),\n    width = encoding.config(\"_minWidth\"),\n    height = encoding.config(\"_minHeight\");\n\n  if (hasX && (encoding.isType(X, O) || encoding.bin(X))) { //ordinal field will override parent\n    // bands within cell use rangePoints()\n    var xCardinality = getCardinality(encoding, X, stats);\n    cellWidth = (xCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  width = cellWidth * ((1 + cellPadding) * (colCardinality-1) + 1);\n\n  if (hasY && (encoding.isType(Y, O) || encoding.bin(Y))) {\n    // bands within cell use rangePoint()\n    var yCardinality = getCardinality(encoding, Y, stats);\n    cellHeight = (yCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  height = cellHeight * ((1 + cellPadding) * (rowCardinality-1) + 1);\n\n  return {\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    width: width,\n    height:height\n  };\n}\n\nfunction facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats) {\n    var enter = group.properties.enter;\n    var facetKeys = [], cellAxes = [];\n\n    var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n    var xAxisMargin = encoding.has(Y) ? encoding.config(\"xAxisMargin\") : undefined;\n\n    enter.fill = {value: encoding.config(\"cellBackgroundColor\")};\n\n    //move \"from\" to cell level and add facet transform\n    group.from = {data: group.marks[0].from.data};\n\n    if (group.marks[0].from.transform) {\n      delete group.marks[0].from.data; //need to keep transform for subfacetting case\n    } else {\n      delete group.marks[0].from;\n    }\n    if (hasRow) {\n      if (!encoding.isType(ROW, O)) {\n        util.error(\"Row encoding should be ordinal.\");\n      }\n      enter.y = {scale: ROW, field: \"keys.\" + facetKeys.length};\n      enter.height = {\"value\": cellHeight}; // HACK\n\n      facetKeys.push(encoding.field(ROW));\n\n      var from;\n      if (hasCol) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(COL)]});\n      }\n\n      var axesGrp = groupdef(\"x-axes\", {\n          axes: encoding.has(X) ?  axis.defs([\"x\"], encoding) : undefined,\n          x: hasCol ? {scale: COL, field: \"keys.0\", offset: xAxisMargin} : {value: xAxisMargin},\n          width: hasCol && {\"value\": cellWidth}, //HACK?\n          from: from\n        });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || []);\n      spec.axes.push.apply(spec.axes, axis.defs([\"row\"], encoding));\n    } else { // doesn't have row\n      if(encoding.has(X)){\n        //keep x axis in the cell\n        cellAxes.push.apply(cellAxes, axis.defs([\"x\"], encoding));\n      }\n    }\n\n    if (hasCol) {\n      if (!encoding.isType(COL, O)) {\n        util.error(\"Col encoding should be ordinal.\");\n      }\n      enter.x = {scale: COL, field: \"keys.\" + facetKeys.length};\n      enter.width = {\"value\": cellWidth}; // HACK\n\n      facetKeys.push(encoding.field(COL));\n\n      var from;\n      if (hasRow) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(ROW)]});\n      }\n\n      var axesGrp = groupdef(\"y-axes\", {\n        axes: encoding.has(Y) ? axis.defs([\"y\"], encoding) : undefined,\n        y: hasRow && {scale: ROW, field: \"keys.0\"},\n        x: hasRow && {value: xAxisMargin},\n        height: hasRow && {\"value\": cellHeight}, //HACK?\n        from: from\n      });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || [])\n      spec.axes.push.apply(spec.axes, axis.defs([\"col\"], encoding, {\n        xAxisMargin: xAxisMargin\n      }));\n    } else { // doesn't have col\n      if(encoding.has(Y)){\n        cellAxes.push.apply(cellAxes, axis.defs([\"y\"], encoding));\n      }\n    }\n\n    if(hasRow){\n      if(enter.x) enter.x.offset= xAxisMargin;\n      else enter.x = {value: xAxisMargin};\n    }\n    if(hasCol){\n      //TODO fill here..\n    }\n\n    // assuming equal cellWidth here\n    // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n    spec.scales = (spec.scales ||[]).concat(scale.defs(\n      scale.names(enter).concat(scale.names(mdef.properties.update)),\n      encoding,\n      {cellWidth: cellWidth, cellHeight: cellHeight, stack: stack, facet:true, stats: stats}\n    )); // row/col scales + cell scales\n\n    if (cellAxes.length > 0) {\n      group.axes = cellAxes;\n    }\n\n    // add facet transform\n    var trans = (group.from.transform || (group.from.transform = []));\n    trans.unshift({type: \"facet\", keys: facetKeys});\n\n  return spec;\n  }\n\nfunction subfacet(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef(\"subfacet\", {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: \"facet\", keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: \"sort\", by: encoding.field(COLOR)});\n  }\n}\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n  encoding.forEach(function(vv, d) {\n    if (d.bin) bins[d.name] = d.name;\n  });\n  bins = util.keys(bins);\n\n  if (bins.length === 0 || opt.preaggregatedData) return false;\n\n  if (!spec.transform) spec.transform = [];\n  bins.forEach(function(d) {\n    spec.transform.push({\n      type: \"bin\",\n      field: \"data.\" + d,\n      output: \"data.bin_\" + d,\n      maxbins: MAX_BINS\n    });\n  });\n  return bins;\n}\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n  var dims = {}, meas = {}, detail = {}, facets={};\n  encoding.forEach(function(encType, field) {\n    if (field.aggr) {\n      if(field.aggr===\"count\"){\n        meas[\"count\"] = {op:\"count\", field:\"*\"};\n      }else{\n        meas[field.aggr+\"|\"+field.name] = {\n          op:field.aggr,\n          field:\"data.\"+field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType==ROW || encType == COL){\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!spec.transform) spec.transform = [];\n    spec.transform.push({\n      type: \"aggregate\",\n      groupby: dims,\n      fields: meas\n    });\n\n    if (encoding.marktype() === TEXT) {\n      meas.forEach( function (m) {\n        var fieldName = m.field.substr(5), //remove \"data.\"\n          field = \"data.\" + (m.op ? m.op + \"_\" : \"\") + fieldName;\n        spec.transform.push({\n          type: \"formula\",\n          field: field,\n          expr: \"d3.format('.2f')(d.\"+field+\")\"\n        });\n      });\n    }\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  }\n}\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n  if (!encoding.has(COLOR)) return false;\n\n  var dim = X, val = Y, idx = 1;\n  if (encoding.isType(X,Q|T) && !encoding.isType(Y,Q|T) && encoding.has(Y)) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: \"aggregate\",\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: \"sum\", field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if(facets && facets.length > 0){\n    stacked.transform.push({ //calculate max for each facet\n      type: \"aggregate\",\n      groupby: facets,\n      fields: [{op: \"max\", field: \"data.sum_\" + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: \"stack\",\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val+\"2\"}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val+\"2\"] = mdef.properties.enter[val+\"2\"] = {scale: val, field: val+\"2\"};\n\n  return val; //return stack encoding\n}\n\n\nfunction markdef(mark, encoding, opt) {\n  var p = mark.prop(encoding, opt)\n  return {\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  };\n}\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: \"group\",\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: \"width\"},\n        height: opt.height || {group: \"height\"}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction template(encoding, size, stats) { //hack use stats\n\n  var data = {name:TABLE, format: {type: encoding.config(\"dataFormatType\")}},\n    dataUrl = vl.data.getUrl(encoding, stats);\n  if(dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  encoding.forEach(function(encType, field){\n    if(field.type == T){\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = \"date\";\n    }else if(field.type == Q){\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === \"count\") {\n        var name = \"count\";\n      } else if(preaggregatedData && field.bin){\n        var name = \"bin_\" + field.name;\n      } else if(preaggregatedData && field.aggr){\n        var name = field.aggr + \"_\" + field.name;\n      } else{\n        var name = field.name;\n      }\n      data.format.parse[name] = \"number\";\n    }\n  });\n\n  return {\n    width: size.width,\n    height: size.height,\n    padding: \"auto\",\n    data: [data],\n    marks: [groupdef(\"cell\", {\n      width: size.cellWidth ? {value: size.cellWidth}: undefined,\n      height: size.cellHeight ? {value: size.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"./axis\":3,\"./globals\":7,\"./legends\":8,\"./marks\":9,\"./scale\":10,\"./time\":13,\"./util\":14}],5:[function(require,module,exports){\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT];\n\nconsts.dataTypes = {\"O\": O, \"Q\": Q, \"T\": T};\n\nconsts.dataTypeNames = [\"O\",\"Q\",\"T\"].reduce(function(r,x) {\n  r[consts.dataTypes[x]] = x; return r;\n},{});\n\nconsts.DEFAULTS = {\n  //small multiples\n  cellHeight: 200, // will be overwritten by bandWidth\n  cellWidth: 200, // will be overwritten by bandWidth\n  cellPadding: 0.1,\n  cellBackgroundColor: \"#fdfdfd\",\n  xAxisMargin: 80,\n  yAxisMargin: 0,\n  textCellWidth: 90,\n\n  // marks\n  bandSize: 21,\n  bandPadding: 1,\n  pointSize: 50,\n  pointShape: \"circle\",\n  strokeWidth: 2,\n  color: \"steelblue\",\n  textColor: \"black\",\n  textAlign: \"left\",\n  textBaseline: \"middle\",\n  textMargin: 4,\n  font: \"Helvetica Neue\",\n  fontSize: \"12\",\n  fontWeight: \"normal\",\n  fontStyle: \"normal\",\n  opacity: 1,\n  _thickOpacity: 0.5,\n  _thinOpacity: 0.2,\n\n  // scales\n  // TODO remove _xZero, ...\n  _xZero: true,\n  _xReverse: false,\n  _yZero: true,\n  _yReverse: false,\n  timeScaleNice: \"day\",\n  timeScaleLabelLength: 3\n};\n},{\"./globals\":7}],6:[function(require,module,exports){\n// TODO rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar data = module.exports = {};\n\ndata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config(\"useVegaServer\")) {\n    // don't use vega server\n    return encoding.config(\"dataUrl\");\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = []\n  encoding.forEach(function(encType, field){\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    }\n    if (field.aggr) {\n      obj.aggr = field.aggr\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name]).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config(\"vegaServerTable\"),\n    fields: fields\n  }\n\n  return encoding.config(\"vegaServerUrl\") + \"/query/?q=\" + JSON.stringify(query)\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\ndata.getSchema = function(data){\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k){\n    // find non-null data\n    var i=0, datum = data[i][k];\n    while(datum === \"\" || datum === null || datum === undefined){\n      datum = data[++i][k];\n    }\n\n    //TODO(kanitw): better type inference here\n    var type = (typeof datum === \"number\") ? \"Q\":\n      isNaN(Date.parse(datum)) ? \"O\" : \"T\";\n\n    schema.push({name: k, type: type});\n  });\n\n  return schema;\n};\n\ndata.getStats = function(data){ // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = util.minmax(data, k);\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n    stats[k] = stat;\n  });\n  return stats;\n};\n\n},{\"./util\":14}],7:[function(require,module,exports){\n(function (global){\n// declare global constant\nvar g = global || window;\n\ng.TABLE = \"table\";\ng.STACKED = \"stacked\";\ng.INDEX = \"index\";\n\ng.X = \"x\";\ng.Y = \"y\";\ng.ROW = \"row\";\ng.COL = \"col\";\ng.SIZE = \"size\";\ng.SHAPE = \"shape\";\ng.COLOR = \"color\";\ng.ALPHA = \"alpha\";\ng.TEXT = \"text\";\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n//TODO refactor this to be config?\ng.MAX_BINS = 20;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],8:[function(require,module,exports){\nvar global = require('./globals');\n\nvar legends = module.exports = {};\n\nlegends.defs = function(encoding) {\n  var _legends = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    _legends.push(legends.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: \"right\"\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    _legends.push(legends.def(SIZE, encoding, {\n      size: SIZE,\n      orient: _legends.length === 1 ? \"left\" : \"right\"\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (_legends.length === 2) {\n      // TODO: fix this\n      console.error(\"Vegalite currently only supports two _legends\");\n      return _legends;\n    }\n    _legends.push(legends.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: _legends.length === 1 ? \"left\" : \"right\"\n    }));\n  }\n\n  return _legends;\n};\n\nlegends.def = function(name, encoding, props){\n  var _legend = props;\n\n  _legend.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T)) {\n    var fn = encoding.fn(name),\n      properties = _legend.properties = _legend.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    switch (fn) {\n      case \"day\":\n      case \"month\":\n        text.scale = \"time-\"+fn;\n        break;\n    }\n  }\n\n  return _legend;\n};\n},{\"./globals\":7}],9:[function(require,module,exports){\nvar globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar marks = module.exports = {};\n\nmarks.bar = {\n  type: \"rect\",\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.line = {\n  type: \"line\",\n  line: true,\n  prop: line_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, color:1, alpha:1}\n};\n\nmarks.area = {\n  type: \"area\",\n  stack: true,\n  line: true,\n  requiredEncoding: [\"x\", \"y\"],\n  prop: area_props,\n  supportedEncoding: marks.line.supportedEncoding\n};\n\nmarks.circle = {\n  type: \"symbol\",\n  prop: filled_point_props(\"circle\"),\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.square = {\n  type: \"symbol\",\n  prop: filled_point_props(\"square\"),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: \"symbol\",\n  prop: point_props,\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1, shape:1}\n};\n\nmarks.text = {\n  type: \"text\",\n  prop: text_props,\n  requiredEncoding: [\"text\"],\n  supportedEncoding: {row:1, col:1, size:1, color:1, alpha:1, text:1}\n};\n\nfunction bar_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T) && !e.bin(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.has(Y) && (!e.isType(Y,Q|T) || e.bin(Y))) {\n      p.x2 = {scale: X, value: 0};\n    }\n  } else if (e.has(X)) {\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T) && !e.bin(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    p.yc = {group: \"height\"};\n  }\n\n  // width\n  if (!e.isType(X,Q|T)) {\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.width = {scale: X, band: true, offset: -1};\n      p.width = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(Y,O) && !e.bin(Y)) {\n    p.width = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // height\n  if (!e.isType(Y,Q|T)) {\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.height = {scale: Y, band: true, offset: -1};\n      p.height = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(X,O) && !e.bin(X)) {\n    p.height = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, opt) {\n  var p = {};\n  opt = opt || {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.config(\"pointSize\")};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.config(\"pointShape\")};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }else{\n    p.opacity = {\n      value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n    };\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction line_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction area_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.isType(Y,Q|T) && e.has(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: \"horizontal\"};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, opt) {\n    var p = {};\n    opt = opt || {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.config(\"bandSize\")/2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.config(\"bandSize\")/2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.config(\"pointSize\")};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.config(\"color\")};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    }else {\n      p.opacity = {\n        value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n      };\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(X)) {\n    p.fontSize = {value: e.config(\"fontSize\")};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"textColor\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    p.text = {field: e.field(TEXT)};\n  } else {\n    p.text = {value: \"Abc\"};\n  }\n\n  p.font = {value: e.config(\"font\")};\n  p.fontWeight = {value: e.config(\"fontWeight\")};\n  p.fontStyle = {value: e.config(\"fontStyle\")};\n  p.baseline = {value: e.config(\"textBaseline\")};\n\n  // align\n  if (e.has(X)) {\n    if (e.isType(X,O)) {\n      p.align = {value: \"left\"};\n      p.dx = {value: e.config(\"textMargin\")};\n    } else {\n      p.align = {value: \"center\"}\n    }\n  } else if (e.has(Y)) {\n    p.align = {value: \"left\"};\n    p.dx = {value: e.config(\"textMargin\")};\n  } else {\n    p.align = {value: e.config(\"textAlign\")};\n  }\n\n  return p;\n}\n},{\"./globals\":7,\"./util\":14}],10:[function(require,module,exports){\nvar globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar scale = module.exports = {};\n\nscale.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function (names, encoding, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, opt)\n    };\n    if (s.type === \"ordinal\" && !encoding.bin(name)) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function (name, encoding) {\n  var fn;\n  switch (encoding.type(name)) {\n    case O: return \"ordinal\";\n    case T:\n      switch(encoding.fn(name)){\n        case \"second\":\n        case \"minute\":\n        case \"hour\":\n        case \"day\":\n        case \"date\":\n        case \"month\":\n          return \"ordinal\";\n        case \"year\":\n          return \"linear\";\n      }\n      return \"time\";\n    case Q:\n      if (encoding.bin(name)) {\n        return \"ordinal\";\n      }\n      return encoding.scale(name).type || \"linear\";\n  }\n};\n\nfunction scale_domain(name, encoding, opt) {\n  if (encoding.type(name) === T){\n    switch(encoding.fn(name)){\n      case \"second\":\n      case \"minute\":  return util.range(0, 60);\n      case \"hour\":    return util.range(0, 24);\n      case \"day\":     return util.range(0, 7);\n      case \"date\":    return util.range(0, 32);\n      case \"month\":   return util.range(0, 12);\n    }\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)]);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name===Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: \"data.\" + (opt.facet ? \"max_\" :\"\") + \"sum_\" + encoding.field(name, true)\n    }:\n    {data: TABLE, field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type===\"ordinal\") {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellWidth ? [0, opt.cellWidth] : \"width\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_xZero\");\n        s.reverse = spec.reverse || encoding.config(\"_xReverse\");\n      }\n      s.round = true;\n      if (s.type===\"time\"){\n        s.nice = encoding.fn(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type===\"ordinal\") {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellHeight ? [opt.cellHeight, 0] : \"height\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_yZero\");\n        s.reverse = spec.reverse || encoding.config(\"_yReverse\");\n      }\n\n      s.round = true;\n\n      if (s.type===\"time\"){\n        s.nice = encoding.fn(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = opt.cellHeight || encoding.config(\"cellHeight\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = opt.cellWidth || encoding.config(\"cellWidth\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is(\"bar\")) {\n        s.range = [3, +encoding.config(\"bandSize\")];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else {\n        s.range = [10, 1000];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = \"shapes\";\n      break;\n    case COLOR:\n      if (s.type === \"ordinal\") {\n        s.range = \"category10\";\n      } else {\n        s.range = [\"#ddf\", \"steelblue\"];\n        s.zero = false;\n      }\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error(\"Unknown encoding name: \"+s.name);\n  }\n\n  switch(s.name){\n    case ROW:\n    case COL:\n      s.padding = encoding.config(\"cellPadding\");\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === \"ordinal\") { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.config(\"bandPadding\");\n      }\n  }\n}\n},{\"./globals\":7,\"./util\":14}],11:[function(require,module,exports){\n// Package of defining Vegalite Specification's json schema\n//\nvar schema = module.exports = {},\n  util = require('./util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: \"string\",\n  enum: [\"point\", \"bar\", \"line\", \"area\", \"circle\", \"square\", \"text\"]\n};\n\nschema.aggr = {\n  type: \"string\",\n  enum: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n  supportedEnums: {\n    Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n    O: [\"count\"],\n    T: [\"avg\", \"min\", \"max\", \"count\"],\n    \"\": [\"count\"],\n  },\n  supportedTypes: {\"Q\": true, \"O\": true, \"T\": true, \"\": true}\n};\n\nschema.timefns = [\"month\", \"year\", \"day\", \"date\", \"hour\", \"minute\", \"second\"];\n\nschema.fn = {\n  type: \"string\",\n  enum: schema.timefns,\n  supportedTypes: {\"T\": true}\n}\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: \"string\",\n  enum: [\"linear\", \"log\",\"pow\", \"sqrt\", \"quantile\"],\n  default: \"linear\",\n  supportedTypes: {\"Q\": true}\n};\n\nschema.field = {\n  type: \"object\",\n  required: [\"name\", \"type\"],\n  properties: {\n    name: {\n      type: \"string\"\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nvar typicalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\", \"Q\", \"T\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"Q\": true, \"O\": true}\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    scale: {\n      type: \"object\",\n      properties: {\n        type: schema.scale_type,\n        reverse: { type: \"boolean\", default: false },\n        zero: {\n          type: \"boolean\",\n          description: \"Include zero\",\n          default: false,\n          supportedTypes: {\"Q\": true}\n        },\n        nice: {\n          type: \"string\",\n          enum: [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"year\"],\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"O\": true}\n    },\n    aggr: {\n      type: \"string\",\n      enum: [\"count\"],\n      supportedTypes: {\"O\": true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: \"object\",\n  properties: {\n    axis: {\n      type: \"object\",\n      properties: {\n        grid: { type: \"boolean\", default: false },\n        title: { type: \"boolean\", default: true }\n      }\n    }\n  }\n}\n\nvar legendMixin = {\n  type: \"object\",\n  properties: {\n    legend: { type: \"boolean\", default: true }\n  }\n}\n\nvar textMixin = {\n  type: \"object\",\n  properties: {\n    text: {\n      type: \"object\",\n      properties: {\n        weight: {\n          type: \"string\",\n          enum: [\"normal\", \"bold\"],\n          default: \"normal\",\n          supportedTypes: {\"T\": true}\n        },\n        size: {\n          type: \"integer\",\n          default: 10,\n          minimum: 0,\n          supportedTypes: {\"T\": true}\n        },\n        font: {\n          type: \"string\",\n          default: \"Halvetica Neue\",\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n}\n\nvar x = merge(clone(typicalField), axisMixin);\nvar y = clone(x);\n\nvar row = clone(onlyOrdinalField);\nvar col = clone(row);\n\nvar size = merge(clone(typicalField), legendMixin);\nvar color = merge(clone(typicalField), legendMixin);\nvar alpha = clone(typicalField);\nvar shape = merge(clone(onlyOrdinalField), legendMixin);\n\nvar text = merge(clone(typicalField), textMixin);\n\nvar cfg = {\n  type: \"object\",\n  properties: {\n    // template\n    width: {\n      type: \"integer\",\n      default: undefined\n    },\n    height: {\n      type: \"integer\",\n      default: undefined\n    },\n    viewport: {\n      type: \"array\",\n      items: {\n        type: [\"integer\"]\n      },\n      default: undefined\n    },\n    _minWidth: {\n      type: \"integer\",\n      default: 20\n    },\n    _minHeight: {\n      type: \"integer\",\n      default: 20\n    },\n\n    // data source\n    dataFormatType: {\n      type: \"string\",\n      enum: [\"json\", \"csv\"],\n      default: \"json\"\n    },\n    useVegaServer: {\n      type: \"boolean\",\n      default: false\n    },\n    dataUrl: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerTable: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerUrl: {\n      type: \"string\",\n      default: \"http://localhost:3001\"\n    }\n  }\n}\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: \"http://json-schema.org/draft-04/schema#\",\n  type: \"object\",\n  required: [\"marktype\", \"enc\", \"cfg\"],\n  properties: {\n    marktype: schema.marktype,\n    enc: {\n      type: \"object\",\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text\n      }\n    },\n    cfg: cfg\n  }\n};\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function(){\n  return schema.util.instantiate(schema.schema);\n}\n\n},{\"./schemautil\":12,\"./util\":14}],12:[function(require,module,exports){\nvar util = module.exports = {};\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0\n}\n\n// instantiate a schema\nutil.instantiate = function(schema, required) {\n  if (schema.type === 'object') {\n    var requried = schema.required ? schema.required : [];\n    var instance = {};\n    for (var name in schema.properties) {\n      var child = schema.properties[name];\n      instance[name] = util.instantiate(child, requried.indexOf(name) != -1);\n    };\n    return instance;\n  } else if ('default' in schema) {\n    return schema.default;\n  } else if (schema.enum && required) {\n    return schema.enum[0];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nutil.difference = function(defaults, instance) {\n  var changes = {};\n  for (var prop in instance) {\n    if (!defaults || defaults[prop] !== instance[prop]) {\n      if (typeof instance[prop] == \"object\") {\n        var c = util.difference(defaults[prop], instance[prop]);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else {\n        changes[prop] = instance[prop];\n      }\n    }\n  }\n  return changes;\n};\n\n// recursively merges instance into defaults\nutil.merge = function (defaults, instance) {\n  if (typeof instance!=='object' || instance===null) {\n    return defaults;\n  }\n\n  for (var p in instance) {\n    if (!instance.hasOwnProperty(p))\n      continue;\n    if (instance[p]===undefined )\n      continue;\n    if (typeof instance[p] !== 'object' || instance[p] === null) {\n      defaults[p] = instance[p];\n    } else if (typeof defaults[p] !== 'object' || defaults[p] === null) {\n      defaults[p] = util.merge(instance[p].constructor === Array ? [] : {}, instance[p]);\n    } else {\n      util.merge(defaults[p], instance[p]);\n    }\n  }\n  return defaults;\n}\n\n},{}],13:[function(require,module,exports){\nvar globals = require('./globals'),\n  util = require('./util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt){\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(encType, field){\n    if(field.type === T && field.fn){\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[0],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function (field) {\n  var date = \"new Date(d.data.\"+field.name+\")\";\n  switch(field.fn){\n    case \"second\":  return date + \".getUTCSeconds()\";\n    case \"minute\":  return date + \".getUTCMinutes()\";\n    case \"hour\":    return date + \".getUTCHours()\";\n    case \"day\":     return date + \".getUTCDay()\";\n    case \"date\":    return date + \".getUTCDate()\";\n    case \"month\":   return date + \".getUTCMonth()\";\n    case \"year\":    return date + \".getUTCFullYear()\";\n  }\n  // TODO add continuous binning\n  console.error(\"no function specified for date\");\n};\n\n/** add formula transforms to data */\ntime.transform = function (transform, encoding, encType, field) {\n  transform.push({\n    type: \"formula\",\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\ntime.scale = function (scales, fn, encoding) {\n  var labelLength = encoding.config(\"timeScaleLabelLength\");\n  // TODO add option for shorter scale / custom range\n  switch(fn){\n    case \"day\":\n      scales.push({\n        name: \"time-day\",\n        type: \"ordinal\",\n        domain: util.range(0,7),\n        range: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"].map(\n          function(s){ return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case \"month\":\n      scales.push({\n        name: \"time-month\",\n        type: \"ordinal\",\n        domain: util.range(0,12),\n        range: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"].map(\n            function(s){ return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\n},{\"./globals\":7,\"./util\":14}],14:[function(require,module,exports){\nvar util = module.exports = {};\n\nutil.keys = function (obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n}\n\nutil.vals = function (obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n}\n\nutil.range = function (start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n}\n\nutil.find = function (list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n}\n\nutil.uniq = function (data, field) {\n  var map = {}, count = 0, i, k;\n  for (i=0; i<data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n}\n\nutil.minmax = function (data, field) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (i=0; i<data.length; ++i) {\n    var v = data[i][field];\n    if (v > stats.max) stats.max = v;\n    if (v < stats.min) stats.min = v;\n  }\n  return stats;\n}\n\nutil.duplicate = function (obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.any = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(f(arr[k], k, i++)) return true;\n  }\n  return false;\n}\n\nutil.all = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(!f(arr[k], k, i++)) return false;\n  }\n  return true;\n}\n\nutil.merge = function(dest, src){\n  return util.keys(src).reduce(function(c, k){\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.getbins = function (stats) {\n  return vg.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: MAX_BINS\n  });\n}\n\n\nutil.error = function(msg){\n  console.error(\"[VL Error]\", msg);\n}\n\n\n},{}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJzcmMvRW5jb2RpbmcuanMiLCJzcmMvYXhpcy5qcyIsInNyYy9jb21waWxlLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9kYXRhLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvbGVnZW5kcy5qcyIsInNyYy9tYXJrcy5qcyIsInNyYy9zY2FsZS5qcyIsInNyYy9zY2hlbWEuanMiLCJzcmMvc2NoZW1hdXRpbC5qcyIsInNyYy90aW1lLmpzIiwic3JjL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcblxudmFyIHZsID0gdXRpbC5tZXJnZShjb25zdHMsIHV0aWwpO1xuXG52bC5zY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xudmwuRW5jb2RpbmcgPSByZXF1aXJlKCcuL0VuY29kaW5nJyk7XG52bC5heGlzID0gcmVxdWlyZSgnLi9heGlzJyk7XG52bC5jb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG52bC5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG52bC5sZWdlbmRzID0gcmVxdWlyZSgnLi9sZWdlbmRzJyk7XG52bC5tYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKVxudmwuc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdmw7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vZ2xvYmFscycpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5cbnZhciBFbmNvZGluZyA9IG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIEVuY29kaW5nKG1hcmt0eXBlLCBlbmMsIGNvbmZpZykge1xuICAgIC8vIFRPRE86IGNhY2hpbmdcbiAgICB2YXIgZW5jRGVmYXVsdHMgPSBzY2hlbWEudXRpbC5pbnN0YW50aWF0ZShzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jKTtcbiAgICB2YXIgY2ZnRGVmYXVsdHMgPSBzY2hlbWEudXRpbC5pbnN0YW50aWF0ZShzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuY2ZnKTtcblxuICAgIC8vIEhhY2tcbiAgICBmb3IgKHZhciBrIGluIGNvbnN0cy5ERUZBVUxUUykge1xuICAgICAgY2ZnRGVmYXVsdHNba10gPSBjb25zdHMuREVGQVVMVFNba107XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZpZWxkIGRlZnMgdGhhdCB3ZSBkb24ndCB1c2UgaW4gZW5jb2RpbmdcbiAgICBmb3IgKHZhciBrIGluIGVuY0RlZmF1bHRzKSB7XG4gICAgICBpZiAoIWVuY1trXSkge1xuICAgICAgICBkZWxldGUgZW5jRGVmYXVsdHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFya3R5cGUgPSBtYXJrdHlwZTtcbiAgICB0aGlzLl9lbmMgPSBzY2hlbWEudXRpbC5tZXJnZShlbmNEZWZhdWx0cywgZW5jKTtcbiAgICB0aGlzLl9jZmcgPSBzY2hlbWEudXRpbC5tZXJnZShjZmdEZWZhdWx0cywgY29uZmlnKTtcbiAgfVxuXG4gIHZhciBwcm90byA9IEVuY29kaW5nLnByb3RvdHlwZTtcblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbeF0gIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICBwcm90by5lbmMgPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdO1xuICB9O1xuXG4gIC8vIGdldCBcImZpZWxkXCIgcHJvcGVydHkgZm9yIHZlZ2FcbiAgcHJvdG8uZmllbGQgPSBmdW5jdGlvbih4LCBub2RhdGEsIG5vZm4pIHtcbiAgICBpZiAoIXRoaXMuaGFzKHgpKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBmID0gKG5vZGF0YSA/IFwiXCIgOiBcImRhdGEuXCIpO1xuXG4gICAgaWYgKHRoaXMuX2VuY1t4XS5hZ2dyID09PSBcImNvdW50XCIpIHtcbiAgICAgIHJldHVybiBmICsgXCJjb3VudFwiO1xuICAgIH0gZWxzZSBpZiAoIW5vZm4gJiYgdGhpcy5fZW5jW3hdLmJpbikge1xuICAgICAgcmV0dXJuIGYgKyBcImJpbl9cIiArIHRoaXMuX2VuY1t4XS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoIW5vZm4gJiYgdGhpcy5fZW5jW3hdLmFnZ3IpIHtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW3hdLmFnZ3IgKyBcIl9cIiArIHRoaXMuX2VuY1t4XS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoIW5vZm4gJiYgdGhpcy5fZW5jW3hdLmZuKXtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW3hdLmZuICsgXCJfXCIgKyB0aGlzLl9lbmNbeF0ubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGYgKyB0aGlzLl9lbmNbeF0ubmFtZTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oeCl7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5uYW1lO1xuICB9XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKHgpe1xuICAgIGlmICh0aGlzLl9lbmNbeF0uYWdncikge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5hZ2dyICsgXCIoXCIgKyB0aGlzLl9lbmNbeF0ubmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW3hdLm5hbWU7XG4gICAgfVxuICB9XG5cbiAgcHJvdG8uc2NhbGUgPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdLnNjYWxlIHx8IHt9O1xuICB9XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKHgpe1xuICAgIHJldHVybiB0aGlzLl9lbmNbeF0uYXhpcyB8fCB7fTtcbiAgfVxuXG4gIHByb3RvLmFnZ3IgPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdLmFnZ3I7XG4gIH1cblxuICBwcm90by5iaW4gPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdLmJpbjtcbiAgfVxuXG4gIHByb3RvLmxlZ2VuZCA9IGZ1bmN0aW9uKHgpe1xuICAgIHJldHVybiB0aGlzLl9lbmNbeF0ubGVnZW5kO1xuICB9XG5cbiAgcHJvdG8uZm4gPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdLmZuO1xuICB9XG5cbiAgcHJvdG8uYW55ID0gZnVuY3Rpb24oZil7XG4gICAgcmV0dXJuIHV0aWwuYW55KHRoaXMuX2VuYywgZik7XG4gIH1cblxuICBwcm90by5hbGwgPSBmdW5jdGlvbihmKXtcbiAgICByZXR1cm4gdXRpbC5hbGwodGhpcy5fZW5jLCBmKTtcbiAgfVxuXG4gIHByb3RvLmxlbmd0aCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHV0aWwua2V5cyh0aGlzLl9lbmMpLmxlbmd0aDtcbiAgfVxuXG4gIHByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uKGYsIGluaXQpe1xuICAgIHZhciByID0gaW5pdCwgaT0wO1xuICAgIGZvciAoayBpbiB0aGlzLl9lbmMpe1xuICAgICAgciA9IGYociwgdGhpcy5fZW5jW2tdLCBrLCB0aGlzLl9lbmMpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIHByb3RvLmZvckVhY2ggPSBmdW5jdGlvbihmKSB7XG4gICAgdmFyIGk9MCwgaztcbiAgICBmb3IgKGsgaW4gdGhpcy5fZW5jKSB7XG4gICAgICBmKGssIHRoaXMuX2VuY1trXSwgaSsrKTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8udHlwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoeCkgPyB0aGlzLl9lbmNbeF0udHlwZSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8uaXNUeXBlID0gZnVuY3Rpb24oeCwgdCkge1xuICAgIHZhciB4dCA9IHRoaXMudHlwZSh4KTtcbiAgICBpZiAoeHQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoeHQgJiB0KSA+IDA7XG4gIH07XG5cbiAgcHJvdG8uY29uZmlnID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9jZmdbbmFtZV07XG4gIH07XG5cbiAgcHJvdG8udG9TcGVjID0gZnVuY3Rpb24oZXhjbHVkZUNvbmZpZyl7XG4gICAgdmFyIGVuYyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2VuYyksXG4gICAgICBzcGVjO1xuXG4gICAgLy8gY29udmVydCB0eXBlJ3MgYml0Y29kZSB0byB0eXBlIG5hbWVcbiAgICBmb3IodmFyIGUgaW4gZW5jKXtcbiAgICAgIGVuY1tlXS50eXBlID0gY29uc3RzLmRhdGFUeXBlTmFtZXNbZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHNwZWMgPSB7XG4gICAgICBtYXJrdHlwZTogdGhpcy5fbWFya3R5cGUsXG4gICAgICBlbmM6IGVuY1xuICAgIH1cblxuICAgIGlmKCFleGNsdWRlQ29uZmlnKXtcbiAgICAgIHNwZWMuY2ZnID0gdXRpbC5kdXBsaWNhdGUodGhpcy5fY2ZnKVxuICAgIH1cblxuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG4gIHByb3RvLnRvU2hvcnRoYW5kID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZW5jID0gdGhpcy5fZW5jO1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZSArIFwiLlwiICsgdXRpbC5rZXlzKGVuYykubWFwKGZ1bmN0aW9uKGUpe1xuICAgICAgdmFyIHYgPSBlbmNbZV07XG4gICAgICAgIHJldHVybiBlICsgXCItXCIgK1xuICAgICAgICAgICh2LmFnZ3IgPyB2LmFnZ3IrXCJfXCIgOiBcIlwiKSArXG4gICAgICAgICAgKHYuZm4gPyB2LmZuK1wiX1wiIDogXCJcIikgK1xuICAgICAgICAgICh2LmJpbiA/IFwiYmluX1wiIDogXCJcIikgK1xuICAgICAgICAgICh2Lm5hbWUgfHwgXCJcIikgKyBcIi1cIiArXG4gICAgICAgICAgY29uc3RzLmRhdGFUeXBlTmFtZXNbdi50eXBlXTtcbiAgICAgIH1cbiAgICApLmpvaW4oXCIuXCIpO1xuICB9XG5cbiAgRW5jb2RpbmcucGFyc2VTaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGNmZyl7XG4gICAgdmFyIGVuYyA9IHNob3J0aGFuZC5zcGxpdChcIi5cIiksXG4gICAgICBtYXJrdHlwZSA9IGVuYy5zaGlmdCgpO1xuXG4gICAgZW5jID0gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKXtcbiAgICAgIHZhciBzcGxpdCA9IGUuc3BsaXQoXCItXCIpLFxuICAgICAgICBlbmN0eXBlID0gc3BsaXRbMF0sXG4gICAgICAgIG8gPSB7bmFtZTogc3BsaXRbMV0sIHR5cGU6IGNvbnN0cy5kYXRhVHlwZXNbc3BsaXRbMl1dfTtcblxuICAgICAgLy8gY2hlY2sgYWdncmVnYXRlIHR5cGVcbiAgICAgIGZvcih2YXIgaSBpbiBzY2hlbWEuYWdnci5lbnVtKXtcbiAgICAgICAgdmFyIGEgPSBzY2hlbWEuYWdnci5lbnVtW2ldO1xuICAgICAgICBpZihvLm5hbWUuaW5kZXhPZihhK1wiX1wiKSA9PSAwKXtcbiAgICAgICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKGEubGVuZ3RoKzEpO1xuICAgICAgICAgIGlmIChhPT1cImNvdW50XCIgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gXCIqXCI7XG4gICAgICAgICAgby5hZ2dyID0gYTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY2hlY2sgdGltZSBmblxuICAgICAgZm9yKHZhciBpIGluIHNjaGVtYS50aW1lZm5zKXtcbiAgICAgICAgdmFyIGYgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICAgICAgaWYoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKGYrXCJfXCIpID09IDApe1xuICAgICAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoby5sZW5ndGgrMSk7XG4gICAgICAgICAgby5mbiA9IGY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgYmluXG4gICAgICBpZihvLm5hbWUgJiYgby5uYW1lLmluZGV4T2YoXCJiaW5fXCIpID09IDApe1xuICAgICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgICAgICBvLmJpbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIG1bZW5jdHlwZV0gPSBvO1xuICAgICAgcmV0dXJuIG07XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIG5ldyBFbmNvZGluZyhtYXJrdHlwZSwgZW5jLCBjZmcpO1xuICB9XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCBleHRyYUNmZykge1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuYyk7XG5cbiAgICAvL2NvbnZlcnQgdHlwZSBmcm9tIHN0cmluZyB0byBiaXRjb2RlIChlLmcsIE89MSlcbiAgICBmb3IodmFyIGUgaW4gZW5jKXtcbiAgICAgIGVuY1tlXS50eXBlID0gY29uc3RzLmRhdGFUeXBlc1tlbmNbZV0udHlwZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBFbmNvZGluZyhzcGVjLm1hcmt0eXBlLCBlbmMsIHV0aWwubWVyZ2Uoc3BlYy5jZmcsIGV4dHJhQ2ZnIHx8IHt9KSk7XG4gIH1cblxuICByZXR1cm4gRW5jb2Rpbmc7XG5cbn0pKCk7XG4iLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBheGlzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuYXhpcy5uYW1lcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICB2YXIgcyA9IHByb3BzW3hdLnNjYWxlO1xuICAgIGlmIChzPT09WCB8fCBzPT09WSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuYXhpcy5kZWZzID0gZnVuY3Rpb24obmFtZXMsIGVuY29kaW5nLCBvcHQpIHtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihhLCBuYW1lKSB7XG4gICAgYS5wdXNoKGF4aXMuZGVmKG5hbWUsIGVuY29kaW5nLCBvcHQpKTtcbiAgICByZXR1cm4gYTtcbiAgfSwgW10pO1xufTtcblxuYXhpcy5kZWYgPSBmdW5jdGlvbiAobmFtZSwgZW5jb2RpbmcsIG9wdCl7XG4gIHZhciB0eXBlID0gbmFtZTtcbiAgdmFyIGlzQ29sID0gbmFtZT09Q09MLCBpc1JvdyA9IG5hbWU9PVJPVztcbiAgaWYoaXNDb2wpIHR5cGUgPSBcInhcIjtcbiAgaWYoaXNSb3cpIHR5cGUgPSBcInlcIjtcblxuICB2YXIgYXhpcyA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNjYWxlOiBuYW1lLFxuICB9O1xuXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkpIHtcbiAgICAvL1RPRE8oa2FuaXR3KTogYmV0dGVyIGRldGVybWluZSAjIG9mIHRpY2tzXG4gICAgYXhpcy50aWNrcyA9IDM7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5ncmlkKSB7XG4gICAgYXhpcy5ncmlkID0gdHJ1ZTtcbiAgICBheGlzLmxheWVyID0gXCJiYWNrXCI7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS50aXRsZSkge1xuICAgIC8vc2hvdyB0aXRsZSBieSBkZWZhdWx0XG5cbiAgICBheGlzID0gYXhpc190aXRsZShheGlzLCBuYW1lLCBlbmNvZGluZywgb3B0KTtcbiAgfVxuXG4gIGlmKGlzUm93IHx8IGlzQ29sKXtcbiAgICBheGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICB0aWNrczogeyBvcGFjaXR5OiB7dmFsdWU6IDB9IH0sXG4gICAgICBtYWpvclRpY2tzOiB7IG9wYWNpdHk6IHt2YWx1ZTogMH0gfSxcbiAgICAgIGF4aXM6IHsgb3BhY2l0eToge3ZhbHVlOiAwfSB9XG4gICAgfTtcbiAgfVxuICBpZihpc0NvbCl7XG4gICAgYXhpcy5vZmZzZXQgPSBbb3B0LnhBeGlzTWFyZ2luIHx8IDAsIGVuY29kaW5nLmNvbmZpZyhcInlBeGlzTWFyZ2luXCIpXTtcbiAgICBheGlzLm9yaWVudCA9IFwidG9wXCI7XG4gIH1cblxuICBpZiAobmFtZT09XCJ4XCIgJiYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBPfFQpIHx8IGVuY29kaW5nLmJpbihuYW1lKSkpIHtcbiAgICBheGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgYW5nbGU6IHt2YWx1ZTogMjcwfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogXCJyaWdodFwifSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gYWRkIGN1c3RvbSBsYWJlbCBmb3IgdGltZSB0eXBlXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkpIHtcbiAgICB2YXIgZm4gPSBlbmNvZGluZy5mbihuYW1lKSxcbiAgICAgIHByb3BlcnRpZXMgPSBheGlzLnByb3BlcnRpZXMgPSBheGlzLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBsYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyA9IHByb3BlcnRpZXMubGFiZWxzIHx8IHt9LFxuICAgICAgdGV4dCA9IGxhYmVscy50ZXh0ID0gbGFiZWxzLnRleHQgfHwge307XG5cbiAgICBzd2l0Y2ggKGZuKSB7XG4gICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgdGV4dC5zY2FsZSA9IFwidGltZS1cIitmbjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF4aXM7XG59O1xuXG5mdW5jdGlvbiBheGlzX3RpdGxlKGF4aXMsIG5hbWUsIGVuY29kaW5nLCBvcHQpe1xuICBheGlzLnRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcbiAgaWYobmFtZT09WSl7XG4gICAgYXhpcy50aXRsZU9mZnNldCA9IDYwO1xuICAgIC8vIFRPRE86IHNldCBhcHByb3ByaWF0ZSB0aXRsZU9mZnNldFxuICAgIC8vIG1heWJlIGJhc2VkIG9uIHNvbWUgc3RyaW5nIGxlbmd0aCBmcm9tIHN0YXRzXG4gIH1cbiAgcmV0dXJuIGF4aXM7XG59XG4iLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIGF4aXMgPSByZXF1aXJlKCcuL2F4aXMnKSxcbiAgbGVnZW5kcyA9IHJlcXVpcmUoJy4vbGVnZW5kcycpLFxuICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKSxcbiAgc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGNvbXBpbGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgc2l6ZSA9IHNldFNpemUoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBjZWxsV2lkdGggPSBzaXplLmNlbGxXaWR0aCxcbiAgICBjZWxsSGVpZ2h0ID0gc2l6ZS5jZWxsSGVpZ2h0O1xuXG4gIHZhciBoYXNBZ2cgPSBlbmNvZGluZy5hbnkoZnVuY3Rpb24odiwgayl7XG4gICAgcmV0dXJuIHYuYWdnciAhPT0gdW5kZWZpbmVkO1xuICB9KTtcblxuICB2YXIgc3BlYyA9IHRlbXBsYXRlKGVuY29kaW5nLCBzaXplLCBzdGF0cyksXG4gICAgZ3JvdXAgPSBzcGVjLm1hcmtzWzBdLFxuICAgIG1hcmsgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXSxcbiAgICBtZGVmID0gbWFya2RlZihtYXJrLCBlbmNvZGluZywge1xuICAgICAgaGFzQWdncmVnYXRlOiBoYXNBZ2dcbiAgICB9KTtcblxuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gIHZhciBwcmVhZ2dyZWdhdGVkRGF0YSA9IGVuY29kaW5nLmNvbmZpZyhcInVzZVZlZ2FTZXJ2ZXJcIik7XG5cbiAgZ3JvdXAubWFya3MucHVzaChtZGVmKTtcbiAgLy8gVE9ETzogcmV0dXJuIHZhbHVlIG5vdCB1c2VkXG4gIGJpbm5pbmcoc3BlYy5kYXRhWzBdLCBlbmNvZGluZywge3ByZWFnZ3JlZ2F0ZWREYXRhOiBwcmVhZ2dyZWdhdGVkRGF0YX0pO1xuXG4gIHZhciBsaW5lVHlwZSA9IG1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLmxpbmU7XG5cbiAgaWYoIXByZWFnZ3JlZ2F0ZWREYXRhKXtcbiAgICBzcGVjID0gdGltZShzcGVjLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBoYW5kbGUgc3ViZmFjZXRzXG4gIHZhciBhZ2dSZXN1bHQgPSBhZ2dyZWdhdGVzKHNwZWMuZGF0YVswXSwgZW5jb2RpbmcsIHtwcmVhZ2dyZWdhdGVkRGF0YTogcHJlYWdncmVnYXRlZERhdGF9KSxcbiAgICBkZXRhaWxzID0gYWdnUmVzdWx0LmRldGFpbHMsXG4gICAgaGFzRGV0YWlscyA9IGRldGFpbHMgJiYgZGV0YWlscy5sZW5ndGggPiAwLFxuICAgIHN0YWNrID0gaGFzRGV0YWlscyAmJiBzdGFja2luZyhzcGVjLCBlbmNvZGluZywgbWRlZiwgYWdnUmVzdWx0LmZhY2V0cyk7XG5cbiAgaWYgKGhhc0RldGFpbHMgJiYgKHN0YWNrIHx8IGxpbmVUeXBlKSkge1xuICAgIC8vc3ViZmFjZXQgdG8gZ3JvdXAgc3RhY2sgLyBsaW5lIHRvZ2V0aGVyIGluIG9uZSBncm91cFxuICAgIHN1YmZhY2V0KGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gYXV0by1zb3J0IGxpbmUvYXJlYSB2YWx1ZXNcbiAgLy9UT0RPKGthbml0dyk6IGhhdmUgc29tZSBjb25maWcgdG8gdHVybiBvZmYgYXV0by1zb3J0IGZvciBsaW5lIChmb3IgbGluZSBjaGFydCB0aGF0IGVuY29kZXMgdGVtcG9yYWwgaW5mb3JtYXRpb24pXG4gIGlmIChsaW5lVHlwZSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzVHlwZShYLCBRIHwgVCkgJiYgZW5jb2RpbmcuaXNUeXBlKFksIE8pKSA/IFkgOiBYO1xuICAgIGlmICghbWRlZi5mcm9tKSBtZGVmLmZyb20gPSB7fTtcbiAgICBtZGVmLmZyb20udHJhbnNmb3JtID0gW3t0eXBlOiBcInNvcnRcIiwgYnk6IGVuY29kaW5nLmZpZWxkKGYpfV07XG4gIH1cblxuICAvLyBTbWFsbCBNdWx0aXBsZXNcbiAgaWYgKGhhc1JvdyB8fCBoYXNDb2wpIHtcbiAgICBzcGVjID0gZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHNwZWMsIG1kZWYsIHN0YWNrLCBzdGF0cyk7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAuc2NhbGVzID0gc2NhbGUuZGVmcyhzY2FsZS5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSwgZW5jb2RpbmcsXG4gICAgICB7c3RhY2s6IHN0YWNrLCBzdGF0czogc3RhdHN9KTtcbiAgICBncm91cC5heGVzID0gYXhpcy5kZWZzKGF4aXMubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSksIGVuY29kaW5nKTtcbiAgICBncm91cC5sZWdlbmRzID0gbGVnZW5kcy5kZWZzKGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn07XG5cbmZ1bmN0aW9uIGdldENhcmRpbmFsaXR5KGVuY29kaW5nLCBlbmNUeXBlLCBzdGF0cyl7XG4gIHZhciBmaWVsZCA9IGVuY29kaW5nLmZpZWxkTmFtZShlbmNUeXBlKTtcbiAgaWYgKGVuY29kaW5nLmJpbihlbmNUeXBlKSkge1xuICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKHN0YXRzW2ZpZWxkXSk7XG4gICAgcmV0dXJuIChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgfVxuICByZXR1cm4gc3RhdHNbZmllbGRdLmNhcmRpbmFsaXR5O1xufVxuXG5mdW5jdGlvbiBzZXRTaXplKGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksXG4gICAgICBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKSxcbiAgICAgIGhhc1ggPSBlbmNvZGluZy5oYXMoWCksXG4gICAgICBoYXNZID0gZW5jb2RpbmcuaGFzKFkpO1xuXG4gIC8vIEhBQ0sgdG8gc2V0IGNoYXJ0IHNpemVcbiAgLy8gTk9URTogdGhpcyBmYWlscyBmb3IgcGxvdHMgZHJpdmVuIGJ5IGRlcml2ZWQgdmFsdWVzIChlLmcuLCBhZ2dyZWdhdGVzKVxuICAvLyBPbmUgc29sdXRpb24gaXMgdG8gdXBkYXRlIFZlZ2EgdG8gc3VwcG9ydCBhdXRvLXNpemluZ1xuICAvLyBJbiB0aGUgbWVhbnRpbWUsIGF1dG8tcGFkZGluZyAobW9zdGx5KSBkb2VzIHRoZSB0cmlja1xuICAvL1xuICB2YXIgY29sQ2FyZGluYWxpdHkgPSBoYXNDb2wgPyBnZXRDYXJkaW5hbGl0eShlbmNvZGluZywgQ09MLCBzdGF0cykgOiAxLFxuICAgIHJvd0NhcmRpbmFsaXR5ID0gaGFzUm93ID8gZ2V0Q2FyZGluYWxpdHkoZW5jb2RpbmcsIFJPVywgc3RhdHMpIDogMTtcblxuICB2YXIgY2VsbFdpZHRoID0gaGFzWCA/XG4gICAgICArZW5jb2RpbmcuY29uZmlnKFwiY2VsbFdpZHRoXCIpIHx8IGVuY29kaW5nLmNvbmZpZyhcIndpZHRoXCIpICogMS4wIC8gY29sQ2FyZGluYWxpdHkgOlxuICAgICAgZW5jb2RpbmcubWFya3R5cGUoKSA9PT0gXCJ0ZXh0XCIgP1xuICAgICAgICArZW5jb2RpbmcuY29uZmlnKFwidGV4dENlbGxXaWR0aFwiKSA6XG4gICAgICAgICtlbmNvZGluZy5jb25maWcoXCJiYW5kU2l6ZVwiKSxcbiAgICBjZWxsSGVpZ2h0ID0gaGFzWSA/XG4gICAgICArZW5jb2RpbmcuY29uZmlnKFwiY2VsbEhlaWdodFwiKSB8fCBlbmNvZGluZy5jb25maWcoXCJoZWlnaHRcIikgKiAxLjAgLyByb3dDYXJkaW5hbGl0eSA6XG4gICAgICArZW5jb2RpbmcuY29uZmlnKFwiYmFuZFNpemVcIiksXG4gICAgY2VsbFBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoXCJjZWxsUGFkZGluZ1wiKSxcbiAgICBiYW5kUGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZyhcImJhbmRQYWRkaW5nXCIpLFxuICAgIHdpZHRoID0gZW5jb2RpbmcuY29uZmlnKFwiX21pbldpZHRoXCIpLFxuICAgIGhlaWdodCA9IGVuY29kaW5nLmNvbmZpZyhcIl9taW5IZWlnaHRcIik7XG5cbiAgaWYgKGhhc1ggJiYgKGVuY29kaW5nLmlzVHlwZShYLCBPKSB8fCBlbmNvZGluZy5iaW4oWCkpKSB7IC8vb3JkaW5hbCBmaWVsZCB3aWxsIG92ZXJyaWRlIHBhcmVudFxuICAgIC8vIGJhbmRzIHdpdGhpbiBjZWxsIHVzZSByYW5nZVBvaW50cygpXG4gICAgdmFyIHhDYXJkaW5hbGl0eSA9IGdldENhcmRpbmFsaXR5KGVuY29kaW5nLCBYLCBzdGF0cyk7XG4gICAgY2VsbFdpZHRoID0gKHhDYXJkaW5hbGl0eSArIGJhbmRQYWRkaW5nKSAqICtlbmNvZGluZy5jb25maWcoXCJiYW5kU2l6ZVwiKTtcbiAgfVxuICAvLyBDZWxsIGJhbmRzIHVzZSByYW5nZUJhbmRzKCkuIFRoZXJlIGFyZSBuLTEgcGFkZGluZy4gIE91dGVycGFkZGluZyA9IDAgZm9yIGNlbGxzXG4gIHdpZHRoID0gY2VsbFdpZHRoICogKCgxICsgY2VsbFBhZGRpbmcpICogKGNvbENhcmRpbmFsaXR5LTEpICsgMSk7XG5cbiAgaWYgKGhhc1kgJiYgKGVuY29kaW5nLmlzVHlwZShZLCBPKSB8fCBlbmNvZGluZy5iaW4oWSkpKSB7XG4gICAgLy8gYmFuZHMgd2l0aGluIGNlbGwgdXNlIHJhbmdlUG9pbnQoKVxuICAgIHZhciB5Q2FyZGluYWxpdHkgPSBnZXRDYXJkaW5hbGl0eShlbmNvZGluZywgWSwgc3RhdHMpO1xuICAgIGNlbGxIZWlnaHQgPSAoeUNhcmRpbmFsaXR5ICsgYmFuZFBhZGRpbmcpICogK2VuY29kaW5nLmNvbmZpZyhcImJhbmRTaXplXCIpO1xuICB9XG4gIC8vIENlbGwgYmFuZHMgdXNlIHJhbmdlQmFuZHMoKS4gVGhlcmUgYXJlIG4tMSBwYWRkaW5nLiAgT3V0ZXJwYWRkaW5nID0gMCBmb3IgY2VsbHNcbiAgaGVpZ2h0ID0gY2VsbEhlaWdodCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChyb3dDYXJkaW5hbGl0eS0xKSArIDEpO1xuXG4gIHJldHVybiB7XG4gICAgY2VsbFdpZHRoOiBjZWxsV2lkdGgsXG4gICAgY2VsbEhlaWdodDogY2VsbEhlaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBmYWNldChncm91cCwgZW5jb2RpbmcsIGNlbGxIZWlnaHQsIGNlbGxXaWR0aCwgc3BlYywgbWRlZiwgc3RhY2ssIHN0YXRzKSB7XG4gICAgdmFyIGVudGVyID0gZ3JvdXAucHJvcGVydGllcy5lbnRlcjtcbiAgICB2YXIgZmFjZXRLZXlzID0gW10sIGNlbGxBeGVzID0gW107XG5cbiAgICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gICAgdmFyIHhBeGlzTWFyZ2luID0gZW5jb2RpbmcuaGFzKFkpID8gZW5jb2RpbmcuY29uZmlnKFwieEF4aXNNYXJnaW5cIikgOiB1bmRlZmluZWQ7XG5cbiAgICBlbnRlci5maWxsID0ge3ZhbHVlOiBlbmNvZGluZy5jb25maWcoXCJjZWxsQmFja2dyb3VuZENvbG9yXCIpfTtcblxuICAgIC8vbW92ZSBcImZyb21cIiB0byBjZWxsIGxldmVsIGFuZCBhZGQgZmFjZXQgdHJhbnNmb3JtXG4gICAgZ3JvdXAuZnJvbSA9IHtkYXRhOiBncm91cC5tYXJrc1swXS5mcm9tLmRhdGF9O1xuXG4gICAgaWYgKGdyb3VwLm1hcmtzWzBdLmZyb20udHJhbnNmb3JtKSB7XG4gICAgICBkZWxldGUgZ3JvdXAubWFya3NbMF0uZnJvbS5kYXRhOyAvL25lZWQgdG8ga2VlcCB0cmFuc2Zvcm0gZm9yIHN1YmZhY2V0dGluZyBjYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBncm91cC5tYXJrc1swXS5mcm9tO1xuICAgIH1cbiAgICBpZiAoaGFzUm93KSB7XG4gICAgICBpZiAoIWVuY29kaW5nLmlzVHlwZShST1csIE8pKSB7XG4gICAgICAgIHV0aWwuZXJyb3IoXCJSb3cgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuXCIpO1xuICAgICAgfVxuICAgICAgZW50ZXIueSA9IHtzY2FsZTogUk9XLCBmaWVsZDogXCJrZXlzLlwiICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgICBlbnRlci5oZWlnaHQgPSB7XCJ2YWx1ZVwiOiBjZWxsSGVpZ2h0fTsgLy8gSEFDS1xuXG4gICAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZChST1cpKTtcblxuICAgICAgdmFyIGZyb207XG4gICAgICBpZiAoaGFzQ29sKSB7XG4gICAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogXCJmYWNldFwiLCBrZXlzOiBbZW5jb2RpbmcuZmllbGQoQ09MKV19KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4ZXNHcnAgPSBncm91cGRlZihcIngtYXhlc1wiLCB7XG4gICAgICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFgpID8gIGF4aXMuZGVmcyhbXCJ4XCJdLCBlbmNvZGluZykgOiB1bmRlZmluZWQsXG4gICAgICAgICAgeDogaGFzQ29sID8ge3NjYWxlOiBDT0wsIGZpZWxkOiBcImtleXMuMFwiLCBvZmZzZXQ6IHhBeGlzTWFyZ2lufSA6IHt2YWx1ZTogeEF4aXNNYXJnaW59LFxuICAgICAgICAgIHdpZHRoOiBoYXNDb2wgJiYge1widmFsdWVcIjogY2VsbFdpZHRofSwgLy9IQUNLP1xuICAgICAgICAgIGZyb206IGZyb21cbiAgICAgICAgfSk7XG5cbiAgICAgIHNwZWMubWFya3MucHVzaChheGVzR3JwKTtcbiAgICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoW1wicm93XCJdLCBlbmNvZGluZykpO1xuICAgIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSByb3dcbiAgICAgIGlmKGVuY29kaW5nLmhhcyhYKSl7XG4gICAgICAgIC8va2VlcCB4IGF4aXMgaW4gdGhlIGNlbGxcbiAgICAgICAgY2VsbEF4ZXMucHVzaC5hcHBseShjZWxsQXhlcywgYXhpcy5kZWZzKFtcInhcIl0sIGVuY29kaW5nKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc0NvbCkge1xuICAgICAgaWYgKCFlbmNvZGluZy5pc1R5cGUoQ09MLCBPKSkge1xuICAgICAgICB1dGlsLmVycm9yKFwiQ29sIGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLlwiKTtcbiAgICAgIH1cbiAgICAgIGVudGVyLnggPSB7c2NhbGU6IENPTCwgZmllbGQ6IFwia2V5cy5cIiArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgICAgZW50ZXIud2lkdGggPSB7XCJ2YWx1ZVwiOiBjZWxsV2lkdGh9OyAvLyBIQUNLXG5cbiAgICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkKENPTCkpO1xuXG4gICAgICB2YXIgZnJvbTtcbiAgICAgIGlmIChoYXNSb3cpIHtcbiAgICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgICBmcm9tLnRyYW5zZm9ybS51bnNoaWZ0KHt0eXBlOiBcImZhY2V0XCIsIGtleXM6IFtlbmNvZGluZy5maWVsZChST1cpXX0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXhlc0dycCA9IGdyb3VwZGVmKFwieS1heGVzXCIsIHtcbiAgICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFkpID8gYXhpcy5kZWZzKFtcInlcIl0sIGVuY29kaW5nKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgeTogaGFzUm93ICYmIHtzY2FsZTogUk9XLCBmaWVsZDogXCJrZXlzLjBcIn0sXG4gICAgICAgIHg6IGhhc1JvdyAmJiB7dmFsdWU6IHhBeGlzTWFyZ2lufSxcbiAgICAgICAgaGVpZ2h0OiBoYXNSb3cgJiYge1widmFsdWVcIjogY2VsbEhlaWdodH0sIC8vSEFDSz9cbiAgICAgICAgZnJvbTogZnJvbVxuICAgICAgfSk7XG5cbiAgICAgIHNwZWMubWFya3MucHVzaChheGVzR3JwKTtcbiAgICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pXG4gICAgICBzcGVjLmF4ZXMucHVzaC5hcHBseShzcGVjLmF4ZXMsIGF4aXMuZGVmcyhbXCJjb2xcIl0sIGVuY29kaW5nLCB7XG4gICAgICAgIHhBeGlzTWFyZ2luOiB4QXhpc01hcmdpblxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSBjb2xcbiAgICAgIGlmKGVuY29kaW5nLmhhcyhZKSl7XG4gICAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbXCJ5XCJdLCBlbmNvZGluZykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGhhc1Jvdyl7XG4gICAgICBpZihlbnRlci54KSBlbnRlci54Lm9mZnNldD0geEF4aXNNYXJnaW47XG4gICAgICBlbHNlIGVudGVyLnggPSB7dmFsdWU6IHhBeGlzTWFyZ2lufTtcbiAgICB9XG4gICAgaWYoaGFzQ29sKXtcbiAgICAgIC8vVE9ETyBmaWxsIGhlcmUuLlxuICAgIH1cblxuICAgIC8vIGFzc3VtaW5nIGVxdWFsIGNlbGxXaWR0aCBoZXJlXG4gICAgLy8gVE9ETzogc3VwcG9ydCBoZXRlcm9nZW5vdXMgY2VsbFdpZHRoIChtYXliZSBieSB1c2luZyBtdWx0aXBsZSBzY2FsZXM/KVxuICAgIHNwZWMuc2NhbGVzID0gKHNwZWMuc2NhbGVzIHx8W10pLmNvbmNhdChzY2FsZS5kZWZzKFxuICAgICAgc2NhbGUubmFtZXMoZW50ZXIpLmNvbmNhdChzY2FsZS5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSksXG4gICAgICBlbmNvZGluZyxcbiAgICAgIHtjZWxsV2lkdGg6IGNlbGxXaWR0aCwgY2VsbEhlaWdodDogY2VsbEhlaWdodCwgc3RhY2s6IHN0YWNrLCBmYWNldDp0cnVlLCBzdGF0czogc3RhdHN9XG4gICAgKSk7IC8vIHJvdy9jb2wgc2NhbGVzICsgY2VsbCBzY2FsZXNcblxuICAgIGlmIChjZWxsQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICBncm91cC5heGVzID0gY2VsbEF4ZXM7XG4gICAgfVxuXG4gICAgLy8gYWRkIGZhY2V0IHRyYW5zZm9ybVxuICAgIHZhciB0cmFucyA9IChncm91cC5mcm9tLnRyYW5zZm9ybSB8fCAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gPSBbXSkpO1xuICAgIHRyYW5zLnVuc2hpZnQoe3R5cGU6IFwiZmFjZXRcIiwga2V5czogZmFjZXRLZXlzfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG4gIH1cblxuZnVuY3Rpb24gc3ViZmFjZXQoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZykge1xuICB2YXIgbSA9IGdyb3VwLm1hcmtzLFxuICAgIGcgPSBncm91cGRlZihcInN1YmZhY2V0XCIsIHttYXJrczogbX0pO1xuXG4gIGdyb3VwLm1hcmtzID0gW2ddO1xuICBnLmZyb20gPSBtZGVmLmZyb207XG4gIGRlbGV0ZSBtZGVmLmZyb207XG5cbiAgLy9UT0RPIHRlc3QgTE9EIC0tIHdlIHNob3VsZCBzdXBwb3J0IHN0YWNrIC8gbGluZSB3aXRob3V0IGNvbG9yIChMT0QpIGZpZWxkXG4gIHZhciB0cmFucyA9IChnLmZyb20udHJhbnNmb3JtIHx8IChnLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogXCJmYWNldFwiLCBrZXlzOiBkZXRhaWxzfSk7XG5cbiAgaWYgKHN0YWNrICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB0cmFucy51bnNoaWZ0KHt0eXBlOiBcInNvcnRcIiwgYnk6IGVuY29kaW5nLmZpZWxkKENPTE9SKX0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbm5pbmcoc3BlYywgZW5jb2RpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBiaW5zID0ge307XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24odnYsIGQpIHtcbiAgICBpZiAoZC5iaW4pIGJpbnNbZC5uYW1lXSA9IGQubmFtZTtcbiAgfSk7XG4gIGJpbnMgPSB1dGlsLmtleXMoYmlucyk7XG5cbiAgaWYgKGJpbnMubGVuZ3RoID09PSAwIHx8IG9wdC5wcmVhZ2dyZWdhdGVkRGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICghc3BlYy50cmFuc2Zvcm0pIHNwZWMudHJhbnNmb3JtID0gW107XG4gIGJpbnMuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgc3BlYy50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICB0eXBlOiBcImJpblwiLFxuICAgICAgZmllbGQ6IFwiZGF0YS5cIiArIGQsXG4gICAgICBvdXRwdXQ6IFwiZGF0YS5iaW5fXCIgKyBkLFxuICAgICAgbWF4YmluczogTUFYX0JJTlNcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBiaW5zO1xufVxuXG5mdW5jdGlvbiBhZ2dyZWdhdGVzKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgZGltcyA9IHt9LCBtZWFzID0ge30sIGRldGFpbCA9IHt9LCBmYWNldHM9e307XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSwgZmllbGQpIHtcbiAgICBpZiAoZmllbGQuYWdncikge1xuICAgICAgaWYoZmllbGQuYWdncj09PVwiY291bnRcIil7XG4gICAgICAgIG1lYXNbXCJjb3VudFwiXSA9IHtvcDpcImNvdW50XCIsIGZpZWxkOlwiKlwifTtcbiAgICAgIH1lbHNle1xuICAgICAgICBtZWFzW2ZpZWxkLmFnZ3IrXCJ8XCIrZmllbGQubmFtZV0gPSB7XG4gICAgICAgICAgb3A6ZmllbGQuYWdncixcbiAgICAgICAgICBmaWVsZDpcImRhdGEuXCIrZmllbGQubmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zW2ZpZWxkLm5hbWVdID0gZW5jb2RpbmcuZmllbGQoZW5jVHlwZSk7XG4gICAgICBpZiAoZW5jVHlwZT09Uk9XIHx8IGVuY1R5cGUgPT0gQ09MKXtcbiAgICAgICAgZmFjZXRzW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1lbHNlIGlmIChlbmNUeXBlICE9PSBYICYmIGVuY1R5cGUgIT09IFkpIHtcbiAgICAgICAgZGV0YWlsW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkaW1zID0gdXRpbC52YWxzKGRpbXMpO1xuICBtZWFzID0gdXRpbC52YWxzKG1lYXMpO1xuXG4gIGlmIChtZWFzLmxlbmd0aCA+IDAgJiYgIW9wdC5wcmVhZ2dyZWdhdGVkRGF0YSkge1xuICAgIGlmICghc3BlYy50cmFuc2Zvcm0pIHNwZWMudHJhbnNmb3JtID0gW107XG4gICAgc3BlYy50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgICAgZ3JvdXBieTogZGltcyxcbiAgICAgIGZpZWxkczogbWVhc1xuICAgIH0pO1xuXG4gICAgaWYgKGVuY29kaW5nLm1hcmt0eXBlKCkgPT09IFRFWFQpIHtcbiAgICAgIG1lYXMuZm9yRWFjaCggZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IG0uZmllbGQuc3Vic3RyKDUpLCAvL3JlbW92ZSBcImRhdGEuXCJcbiAgICAgICAgICBmaWVsZCA9IFwiZGF0YS5cIiArIChtLm9wID8gbS5vcCArIFwiX1wiIDogXCJcIikgKyBmaWVsZE5hbWU7XG4gICAgICAgIHNwZWMudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiZm9ybXVsYVwiLFxuICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICBleHByOiBcImQzLmZvcm1hdCgnLjJmJykoZC5cIitmaWVsZCtcIilcIlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGRldGFpbHM6IHV0aWwudmFscyhkZXRhaWwpLFxuICAgIGRpbXM6IGRpbXMsXG4gICAgZmFjZXRzOiB1dGlsLnZhbHMoZmFjZXRzKSxcbiAgICBhZ2dyZWdhdGVkOiBtZWFzLmxlbmd0aCA+IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFja2luZyhzcGVjLCBlbmNvZGluZywgbWRlZiwgZmFjZXRzKSB7XG4gIGlmICghbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0uc3RhY2spIHJldHVybiBmYWxzZTtcbiAgaWYgKCFlbmNvZGluZy5oYXMoQ09MT1IpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRpbSA9IFgsIHZhbCA9IFksIGlkeCA9IDE7XG4gIGlmIChlbmNvZGluZy5pc1R5cGUoWCxRfFQpICYmICFlbmNvZGluZy5pc1R5cGUoWSxRfFQpICYmIGVuY29kaW5nLmhhcyhZKSkge1xuICAgIGRpbSA9IFk7XG4gICAgdmFsID0gWDtcbiAgICBpZHggPSAwO1xuICB9XG5cbiAgLy8gYWRkIHRyYW5zZm9ybSB0byBjb21wdXRlIHN1bXMgZm9yIHNjYWxlXG4gIHZhciBzdGFja2VkID0ge1xuICAgIG5hbWU6IFNUQUNLRUQsXG4gICAgc291cmNlOiBUQUJMRSxcbiAgICB0cmFuc2Zvcm06IFt7XG4gICAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkKGRpbSldLmNvbmNhdChmYWNldHMpLCAvLyBkaW0gYW5kIG90aGVyIGZhY2V0c1xuICAgICAgZmllbGRzOiBbe29wOiBcInN1bVwiLCBmaWVsZDogZW5jb2RpbmcuZmllbGQodmFsKX1dIC8vIFRPRE8gY2hlY2sgaWYgZmllbGQgd2l0aCBhZ2dyIGlzIGNvcnJlY3Q/XG4gICAgfV1cbiAgfTtcblxuICBpZihmYWNldHMgJiYgZmFjZXRzLmxlbmd0aCA+IDApe1xuICAgIHN0YWNrZWQudHJhbnNmb3JtLnB1c2goeyAvL2NhbGN1bGF0ZSBtYXggZm9yIGVhY2ggZmFjZXRcbiAgICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgICBncm91cGJ5OiBmYWNldHMsXG4gICAgICBmaWVsZHM6IFt7b3A6IFwibWF4XCIsIGZpZWxkOiBcImRhdGEuc3VtX1wiICsgZW5jb2RpbmcuZmllbGQodmFsLCB0cnVlKX1dXG4gICAgfSk7XG4gIH1cblxuICBzcGVjLmRhdGEucHVzaChzdGFja2VkKTtcblxuICAvLyBhZGQgc3RhY2sgdHJhbnNmb3JtIHRvIG1hcmtcbiAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7XG4gICAgdHlwZTogXCJzdGFja1wiLFxuICAgIHBvaW50OiBlbmNvZGluZy5maWVsZChkaW0pLFxuICAgIGhlaWdodDogZW5jb2RpbmcuZmllbGQodmFsKSxcbiAgICBvdXRwdXQ6IHt5MTogdmFsLCB5MDogdmFsK1wiMlwifVxuICB9XTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIHN1cGVyIGhhY2staXNoIC0tIGNvbnNvbGlkYXRlIGludG8gbW9kdWxhciBtYXJrIHByb3BlcnRpZXM/XG4gIG1kZWYucHJvcGVydGllcy51cGRhdGVbdmFsXSA9IG1kZWYucHJvcGVydGllcy5lbnRlclt2YWxdID0ge3NjYWxlOiB2YWwsIGZpZWxkOiB2YWx9O1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbCtcIjJcIl0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsK1wiMlwiXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsK1wiMlwifTtcblxuICByZXR1cm4gdmFsOyAvL3JldHVybiBzdGFjayBlbmNvZGluZ1xufVxuXG5cbmZ1bmN0aW9uIG1hcmtkZWYobWFyaywgZW5jb2RpbmcsIG9wdCkge1xuICB2YXIgcCA9IG1hcmsucHJvcChlbmNvZGluZywgb3B0KVxuICByZXR1cm4ge1xuICAgIHR5cGU6IG1hcmsudHlwZSxcbiAgICBmcm9tOiB7ZGF0YTogVEFCTEV9LFxuICAgIHByb3BlcnRpZXM6IHtlbnRlcjogcCwgdXBkYXRlOiBwfVxuICB9O1xufVxuXG5mdW5jdGlvbiBncm91cGRlZihuYW1lLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICByZXR1cm4ge1xuICAgIF9uYW1lOiBuYW1lIHx8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgZnJvbTogb3B0LmZyb20sXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDogb3B0LnggfHwgdW5kZWZpbmVkLFxuICAgICAgICB5OiBvcHQueSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHdpZHRoOiBvcHQud2lkdGggfHwge2dyb3VwOiBcIndpZHRoXCJ9LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2dyb3VwOiBcImhlaWdodFwifVxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGVzOiBvcHQuc2NhbGVzIHx8IHVuZGVmaW5lZCxcbiAgICBheGVzOiBvcHQuYXhlcyB8fCB1bmRlZmluZWQsXG4gICAgbWFya3M6IG9wdC5tYXJrcyB8fCBbXVxuICB9O1xufVxuXG5mdW5jdGlvbiB0ZW1wbGF0ZShlbmNvZGluZywgc2l6ZSwgc3RhdHMpIHsgLy9oYWNrIHVzZSBzdGF0c1xuXG4gIHZhciBkYXRhID0ge25hbWU6VEFCTEUsIGZvcm1hdDoge3R5cGU6IGVuY29kaW5nLmNvbmZpZyhcImRhdGFGb3JtYXRUeXBlXCIpfX0sXG4gICAgZGF0YVVybCA9IHZsLmRhdGEuZ2V0VXJsKGVuY29kaW5nLCBzdGF0cyk7XG4gIGlmKGRhdGFVcmwpIGRhdGEudXJsID0gZGF0YVVybDtcblxuICB2YXIgcHJlYWdncmVnYXRlZERhdGEgPSBlbmNvZGluZy5jb25maWcoXCJ1c2VWZWdhU2VydmVyXCIpO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSwgZmllbGQpe1xuICAgIGlmKGZpZWxkLnR5cGUgPT0gVCl7XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZSA9IGRhdGEuZm9ybWF0LnBhcnNlIHx8IHt9O1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2VbZmllbGQubmFtZV0gPSBcImRhdGVcIjtcbiAgICB9ZWxzZSBpZihmaWVsZC50eXBlID09IFEpe1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGlmIChmaWVsZC5hZ2dyID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBcImNvdW50XCI7XG4gICAgICB9IGVsc2UgaWYocHJlYWdncmVnYXRlZERhdGEgJiYgZmllbGQuYmluKXtcbiAgICAgICAgdmFyIG5hbWUgPSBcImJpbl9cIiArIGZpZWxkLm5hbWU7XG4gICAgICB9IGVsc2UgaWYocHJlYWdncmVnYXRlZERhdGEgJiYgZmllbGQuYWdncil7XG4gICAgICAgIHZhciBuYW1lID0gZmllbGQuYWdnciArIFwiX1wiICsgZmllbGQubmFtZTtcbiAgICAgIH0gZWxzZXtcbiAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgfVxuICAgICAgZGF0YS5mb3JtYXQucGFyc2VbbmFtZV0gPSBcIm51bWJlclwiO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgIHBhZGRpbmc6IFwiYXV0b1wiLFxuICAgIGRhdGE6IFtkYXRhXSxcbiAgICBtYXJrczogW2dyb3VwZGVmKFwiY2VsbFwiLCB7XG4gICAgICB3aWR0aDogc2l6ZS5jZWxsV2lkdGggPyB7dmFsdWU6IHNpemUuY2VsbFdpZHRofTogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiBzaXplLmNlbGxIZWlnaHQgPyB7dmFsdWU6IHNpemUuY2VsbEhlaWdodH0gOiB1bmRlZmluZWRcbiAgICB9KV1cbiAgfTtcbn1cbiIsInZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5cbnZhciBjb25zdHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5jb25zdHMuZW5jb2RpbmdUeXBlcyA9IFtYLCBZLCBST1csIENPTCwgU0laRSwgU0hBUEUsIENPTE9SLCBBTFBIQSwgVEVYVF07XG5cbmNvbnN0cy5kYXRhVHlwZXMgPSB7XCJPXCI6IE8sIFwiUVwiOiBRLCBcIlRcIjogVH07XG5cbmNvbnN0cy5kYXRhVHlwZU5hbWVzID0gW1wiT1wiLFwiUVwiLFwiVFwiXS5yZWR1Y2UoZnVuY3Rpb24ocix4KSB7XG4gIHJbY29uc3RzLmRhdGFUeXBlc1t4XV0gPSB4OyByZXR1cm4gcjtcbn0se30pO1xuXG5jb25zdHMuREVGQVVMVFMgPSB7XG4gIC8vc21hbGwgbXVsdGlwbGVzXG4gIGNlbGxIZWlnaHQ6IDIwMCwgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGhcbiAgY2VsbFdpZHRoOiAyMDAsIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoXG4gIGNlbGxQYWRkaW5nOiAwLjEsXG4gIGNlbGxCYWNrZ3JvdW5kQ29sb3I6IFwiI2ZkZmRmZFwiLFxuICB4QXhpc01hcmdpbjogODAsXG4gIHlBeGlzTWFyZ2luOiAwLFxuICB0ZXh0Q2VsbFdpZHRoOiA5MCxcblxuICAvLyBtYXJrc1xuICBiYW5kU2l6ZTogMjEsXG4gIGJhbmRQYWRkaW5nOiAxLFxuICBwb2ludFNpemU6IDUwLFxuICBwb2ludFNoYXBlOiBcImNpcmNsZVwiLFxuICBzdHJva2VXaWR0aDogMixcbiAgY29sb3I6IFwic3RlZWxibHVlXCIsXG4gIHRleHRDb2xvcjogXCJibGFja1wiLFxuICB0ZXh0QWxpZ246IFwibGVmdFwiLFxuICB0ZXh0QmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gIHRleHRNYXJnaW46IDQsXG4gIGZvbnQ6IFwiSGVsdmV0aWNhIE5ldWVcIixcbiAgZm9udFNpemU6IFwiMTJcIixcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIixcbiAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICBvcGFjaXR5OiAxLFxuICBfdGhpY2tPcGFjaXR5OiAwLjUsXG4gIF90aGluT3BhY2l0eTogMC4yLFxuXG4gIC8vIHNjYWxlc1xuICAvLyBUT0RPIHJlbW92ZSBfeFplcm8sIC4uLlxuICBfeFplcm86IHRydWUsXG4gIF94UmV2ZXJzZTogZmFsc2UsXG4gIF95WmVybzogdHJ1ZSxcbiAgX3lSZXZlcnNlOiBmYWxzZSxcbiAgdGltZVNjYWxlTmljZTogXCJkYXlcIixcbiAgdGltZVNjYWxlTGFiZWxMZW5ndGg6IDNcbn07IiwiLy8gVE9ETyByZW5hbWUgZ2V0RGF0YVVybCB0byB2bC5kYXRhLmdldFVybCgpID9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIGRhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5kYXRhLmdldFVybCA9IGZ1bmN0aW9uIGdldERhdGFVcmwoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIGlmICghZW5jb2RpbmcuY29uZmlnKFwidXNlVmVnYVNlcnZlclwiKSkge1xuICAgIC8vIGRvbid0IHVzZSB2ZWdhIHNlcnZlclxuICAgIHJldHVybiBlbmNvZGluZy5jb25maWcoXCJkYXRhVXJsXCIpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmxlbmd0aCgpID09PSAwKSB7XG4gICAgLy8gbm8gZmllbGRzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpZWxkcyA9IFtdXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSwgZmllbGQpe1xuICAgIHZhciBvYmogPSB7XG4gICAgICBuYW1lOiBlbmNvZGluZy5maWVsZChlbmNUeXBlLCB0cnVlKSxcbiAgICAgIGZpZWxkOiBmaWVsZC5uYW1lXG4gICAgfVxuICAgIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgICBvYmouYWdnciA9IGZpZWxkLmFnZ3JcbiAgICB9XG4gICAgaWYgKGZpZWxkLmJpbikge1xuICAgICAgb2JqLmJpblNpemUgPSB1dGlsLmdldGJpbnMoc3RhdHNbZmllbGQubmFtZV0pLnN0ZXA7XG4gICAgfVxuICAgIGZpZWxkcy5wdXNoKG9iaik7XG4gIH0pO1xuXG4gIHZhciBxdWVyeSA9IHtcbiAgICB0YWJsZTogZW5jb2RpbmcuY29uZmlnKFwidmVnYVNlcnZlclRhYmxlXCIpLFxuICAgIGZpZWxkczogZmllbGRzXG4gIH1cblxuICByZXR1cm4gZW5jb2RpbmcuY29uZmlnKFwidmVnYVNlcnZlclVybFwiKSArIFwiL3F1ZXJ5Lz9xPVwiICsgSlNPTi5zdHJpbmdpZnkocXVlcnkpXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBkYXRhIGluIEpTT04vamF2YXNjcmlwdCBvYmplY3QgZm9ybWF0XG4gKiBAcmV0dXJuIEFycmF5IG9mIHtuYW1lOiBfX25hbWVfXywgdHlwZTogXCJudW1iZXJ8dGV4dHx0aW1lfGxvY2F0aW9uXCJ9XG4gKi9cbmRhdGEuZ2V0U2NoZW1hID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBzY2hlbWEgPSBbXSxcbiAgICBmaWVsZHMgPSB1dGlsLmtleXMoZGF0YVswXSk7XG5cbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oayl7XG4gICAgLy8gZmluZCBub24tbnVsbCBkYXRhXG4gICAgdmFyIGk9MCwgZGF0dW0gPSBkYXRhW2ldW2tdO1xuICAgIHdoaWxlKGRhdHVtID09PSBcIlwiIHx8IGRhdHVtID09PSBudWxsIHx8IGRhdHVtID09PSB1bmRlZmluZWQpe1xuICAgICAgZGF0dW0gPSBkYXRhWysraV1ba107XG4gICAgfVxuXG4gICAgLy9UT0RPKGthbml0dyk6IGJldHRlciB0eXBlIGluZmVyZW5jZSBoZXJlXG4gICAgdmFyIHR5cGUgPSAodHlwZW9mIGRhdHVtID09PSBcIm51bWJlclwiKSA/IFwiUVwiOlxuICAgICAgaXNOYU4oRGF0ZS5wYXJzZShkYXR1bSkpID8gXCJPXCIgOiBcIlRcIjtcblxuICAgIHNjaGVtYS5wdXNoKHtuYW1lOiBrLCB0eXBlOiB0eXBlfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG5kYXRhLmdldFN0YXRzID0gZnVuY3Rpb24oZGF0YSl7IC8vIGhhY2tcbiAgdmFyIHN0YXRzID0ge30sXG4gICAgZmllbGRzID0gdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgc3RhdCA9IHV0aWwubWlubWF4KGRhdGEsIGspO1xuICAgIHN0YXQuY2FyZGluYWxpdHkgPSB1dGlsLnVuaXEoZGF0YSwgayk7XG4gICAgc3RhdC5jb3VudCA9IGRhdGEubGVuZ3RoO1xuICAgIHN0YXRzW2tdID0gc3RhdDtcbiAgfSk7XG4gIHJldHVybiBzdGF0cztcbn07XG4iLCIvLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLlRBQkxFID0gXCJ0YWJsZVwiO1xuZy5TVEFDS0VEID0gXCJzdGFja2VkXCI7XG5nLklOREVYID0gXCJpbmRleFwiO1xuXG5nLlggPSBcInhcIjtcbmcuWSA9IFwieVwiO1xuZy5ST1cgPSBcInJvd1wiO1xuZy5DT0wgPSBcImNvbFwiO1xuZy5TSVpFID0gXCJzaXplXCI7XG5nLlNIQVBFID0gXCJzaGFwZVwiO1xuZy5DT0xPUiA9IFwiY29sb3JcIjtcbmcuQUxQSEEgPSBcImFscGhhXCI7XG5nLlRFWFQgPSBcInRleHRcIjtcblxuZy5PID0gMTtcbmcuUSA9IDI7XG5nLlQgPSA0O1xuXG4vL1RPRE8gcmVmYWN0b3IgdGhpcyB0byBiZSBjb25maWc/XG5nLk1BWF9CSU5TID0gMjA7IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgbGVnZW5kcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmxlZ2VuZHMuZGVmcyA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBfbGVnZW5kcyA9IFtdO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgYWxwaGFcblxuICBpZiAoZW5jb2RpbmcuaGFzKENPTE9SKSAmJiBlbmNvZGluZy5sZWdlbmQoQ09MT1IpKSB7XG4gICAgX2xlZ2VuZHMucHVzaChsZWdlbmRzLmRlZihDT0xPUiwgZW5jb2RpbmcsIHtcbiAgICAgIGZpbGw6IENPTE9SLFxuICAgICAgb3JpZW50OiBcInJpZ2h0XCJcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNJWkUpICYmIGVuY29kaW5nLmxlZ2VuZChTSVpFKSkge1xuICAgIF9sZWdlbmRzLnB1c2gobGVnZW5kcy5kZWYoU0laRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNpemU6IFNJWkUsXG4gICAgICBvcmllbnQ6IF9sZWdlbmRzLmxlbmd0aCA9PT0gMSA/IFwibGVmdFwiIDogXCJyaWdodFwiXG4gICAgfSkpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSEFQRSkgJiYgZW5jb2RpbmcubGVnZW5kKFNIQVBFKSkge1xuICAgIGlmIChfbGVnZW5kcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFRPRE86IGZpeCB0aGlzXG4gICAgICBjb25zb2xlLmVycm9yKFwiVmVnYWxpdGUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdHdvIF9sZWdlbmRzXCIpO1xuICAgICAgcmV0dXJuIF9sZWdlbmRzO1xuICAgIH1cbiAgICBfbGVnZW5kcy5wdXNoKGxlZ2VuZHMuZGVmKFNIQVBFLCBlbmNvZGluZywge1xuICAgICAgc2hhcGU6IFNIQVBFLFxuICAgICAgb3JpZW50OiBfbGVnZW5kcy5sZW5ndGggPT09IDEgPyBcImxlZnRcIiA6IFwicmlnaHRcIlxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBfbGVnZW5kcztcbn07XG5cbmxlZ2VuZHMuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHByb3BzKXtcbiAgdmFyIF9sZWdlbmQgPSBwcm9wcztcblxuICBfbGVnZW5kLnRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIGZuID0gZW5jb2RpbmcuZm4obmFtZSksXG4gICAgICBwcm9wZXJ0aWVzID0gX2xlZ2VuZC5wcm9wZXJ0aWVzID0gX2xlZ2VuZC5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgbGFiZWxzID0gcHJvcGVydGllcy5sYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyB8fCB7fSxcbiAgICAgIHRleHQgPSBsYWJlbHMudGV4dCA9IGxhYmVscy50ZXh0IHx8IHt9O1xuXG4gICAgc3dpdGNoIChmbikge1xuICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICAgIHRleHQuc2NhbGUgPSBcInRpbWUtXCIrZm47XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfbGVnZW5kO1xufTsiLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIiksXG4gIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXJrcy5iYXIgPSB7XG4gIHR5cGU6IFwicmVjdFwiLFxuICBzdGFjazogdHJ1ZSxcbiAgcHJvcDogYmFyX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbXCJ4XCIsIFwieVwiXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6MSwgY29sOjEsIHg6MSwgeToxLCBzaXplOjEsIGNvbG9yOjEsIGFscGhhOjF9XG59O1xuXG5tYXJrcy5saW5lID0ge1xuICB0eXBlOiBcImxpbmVcIixcbiAgbGluZTogdHJ1ZSxcbiAgcHJvcDogbGluZV9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogW1wieFwiLCBcInlcIl0sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OjEsIGNvbDoxLCB4OjEsIHk6MSwgY29sb3I6MSwgYWxwaGE6MX1cbn07XG5cbm1hcmtzLmFyZWEgPSB7XG4gIHR5cGU6IFwiYXJlYVwiLFxuICBzdGFjazogdHJ1ZSxcbiAgbGluZTogdHJ1ZSxcbiAgcmVxdWlyZWRFbmNvZGluZzogW1wieFwiLCBcInlcIl0sXG4gIHByb3A6IGFyZWFfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiBtYXJrcy5saW5lLnN1cHBvcnRlZEVuY29kaW5nXG59O1xuXG5tYXJrcy5jaXJjbGUgPSB7XG4gIHR5cGU6IFwic3ltYm9sXCIsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcyhcImNpcmNsZVwiKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6MSwgY29sOjEsIHg6MSwgeToxLCBzaXplOjEsIGNvbG9yOjEsIGFscGhhOjF9XG59O1xuXG5tYXJrcy5zcXVhcmUgPSB7XG4gIHR5cGU6IFwic3ltYm9sXCIsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcyhcInNxdWFyZVwiKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IG1hcmtzLmNpcmNsZS5zdXBwb3J0ZWRFbmNvZGluZ1xufTtcblxubWFya3MucG9pbnQgPSB7XG4gIHR5cGU6IFwic3ltYm9sXCIsXG4gIHByb3A6IHBvaW50X3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzoxLCBjb2w6MSwgeDoxLCB5OjEsIHNpemU6MSwgY29sb3I6MSwgYWxwaGE6MSwgc2hhcGU6MX1cbn07XG5cbm1hcmtzLnRleHQgPSB7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBwcm9wOiB0ZXh0X3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbXCJ0ZXh0XCJdLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzoxLCBjb2w6MSwgc2l6ZToxLCBjb2xvcjoxLCBhbHBoYToxLCB0ZXh0OjF9XG59O1xuXG5mdW5jdGlvbiBiYXJfcHJvcHMoZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaXNUeXBlKFgsUXxUKSAmJiAhZS5iaW4oWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICBpZiAoZS5oYXMoWSkgJiYgKCFlLmlzVHlwZShZLFF8VCkgfHwgZS5iaW4oWSkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54YyA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2Uge1xuICAgIHAueGMgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc1R5cGUoWSxRfFQpICYmICFlLmJpbihZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIHAueTIgPSB7c2NhbGU6IFksIHZhbHVlOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkge1xuICAgIHAueWMgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnljID0ge2dyb3VwOiBcImhlaWdodFwifTtcbiAgfVxuXG4gIC8vIHdpZHRoXG4gIGlmICghZS5pc1R5cGUoWCxRfFQpKSB7XG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHAud2lkdGggPSB7c2NhbGU6IFgsIGJhbmQ6IHRydWUsIG9mZnNldDogLTF9O1xuICAgICAgcC53aWR0aCA9IHt2YWx1ZTogK2UuY29uZmlnKFwiYmFuZFNpemVcIiksIG9mZnNldDogLTF9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5pc1R5cGUoWSxPKSAmJiAhZS5iaW4oWSkpIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiArZS5jb25maWcoXCJiYW5kU2l6ZVwiKSwgb2Zmc2V0OiAtMX07XG4gIH1cblxuICAvLyBoZWlnaHRcbiAgaWYgKCFlLmlzVHlwZShZLFF8VCkpIHtcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHAuaGVpZ2h0ID0ge3NjYWxlOiBZLCBiYW5kOiB0cnVlLCBvZmZzZXQ6IC0xfTtcbiAgICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiArZS5jb25maWcoXCJiYW5kU2l6ZVwiKSwgb2Zmc2V0OiAtMX07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmlzVHlwZShYLE8pICYmICFlLmJpbihYKSkge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiArZS5jb25maWcoXCJiYW5kU2l6ZVwiKSwgb2Zmc2V0OiAtMX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUuY29uZmlnKFwiY29sb3JcIil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gcG9pbnRfcHJvcHMoZSwgb3B0KSB7XG4gIHZhciBwID0ge307XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5jb25maWcoXCJiYW5kU2l6ZVwiKS8yfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiBlLmNvbmZpZyhcImJhbmRTaXplXCIpLzJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7dmFsdWU6IGUuY29uZmlnKFwicG9pbnRTaXplXCIpfTtcbiAgfVxuXG4gIC8vIHNoYXBlXG4gIGlmIChlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3NjYWxlOiBTSEFQRSwgZmllbGQ6IGUuZmllbGQoU0hBUEUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHt2YWx1ZTogZS5jb25maWcoXCJwb2ludFNoYXBlXCIpfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS5jb25maWcoXCJjb2xvclwiKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfWVsc2V7XG4gICAgcC5vcGFjaXR5ID0ge1xuICAgICAgdmFsdWU6IGUuY29uZmlnKFwib3BhY2l0eVwiKSB8fCBlLmNvbmZpZyhvcHQuaGFzQWdncmVnYXRlID8gXCJfdGhpY2tPcGFjaXR5XCIgOiBcIl90aGluT3BhY2l0eVwiKVxuICAgIH07XG4gIH1cblxuICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZyhcInN0cm9rZVdpZHRoXCIpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gbGluZV9wcm9wcyhlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7Z3JvdXA6IFwiaGVpZ2h0XCJ9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLmNvbmZpZyhcImNvbG9yXCIpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9XG5cbiAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoXCJzdHJva2VXaWR0aFwiKX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGFyZWFfcHJvcHMoZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaXNUeXBlKFgsUXxUKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmICghZS5pc1R5cGUoWSxRfFQpICYmIGUuaGFzKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgICBwLm9yaWVudCA9IHt2YWx1ZTogXCJob3Jpem9udGFsXCJ9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2Uge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmlzVHlwZShZLFF8VCkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogMH07XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnkgPSB7Z3JvdXA6IFwiaGVpZ2h0XCJ9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUuY29uZmlnKFwiY29sb3JcIil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZmlsbGVkX3BvaW50X3Byb3BzKHNoYXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihlLCBvcHQpIHtcbiAgICB2YXIgcCA9IHt9O1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8vIHhcbiAgICBpZiAoZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuY29uZmlnKFwiYmFuZFNpemVcIikvMn07XG4gICAgfVxuXG4gICAgLy8geVxuICAgIGlmIChlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHt2YWx1ZTogZS5jb25maWcoXCJiYW5kU2l6ZVwiKS8yfTtcbiAgICB9XG5cbiAgICAvLyBzaXplXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC5zaXplID0ge3ZhbHVlOiBlLmNvbmZpZyhcInBvaW50U2l6ZVwiKX07XG4gICAgfVxuXG4gICAgLy8gc2hhcGVcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBzaGFwZX07XG5cbiAgICAvLyBmaWxsXG4gICAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHt2YWx1ZTogZS5jb25maWcoXCJjb2xvclwiKX07XG4gICAgfVxuXG4gICAgLy8gYWxwaGFcbiAgICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICAgIH1lbHNlIHtcbiAgICAgIHAub3BhY2l0eSA9IHtcbiAgICAgICAgdmFsdWU6IGUuY29uZmlnKFwib3BhY2l0eVwiKSB8fCBlLmNvbmZpZyhvcHQuaGFzQWdncmVnYXRlID8gXCJfdGhpY2tPcGFjaXR5XCIgOiBcIl90aGluT3BhY2l0eVwiKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dF9wcm9wcyhlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IGUuY29uZmlnKFwiYmFuZFNpemVcIikvMn07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5jb25maWcoXCJiYW5kU2l6ZVwiKS8yfTtcbiAgfVxuXG4gIC8vIHNpemVcbiAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAuZm9udFNpemUgPSB7dmFsdWU6IGUuY29uZmlnKFwiZm9udFNpemVcIil9O1xuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLmNvbmZpZyhcInRleHRDb2xvclwiKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfVxuXG4gIC8vIHRleHRcbiAgaWYgKGUuaGFzKFRFWFQpKSB7XG4gICAgcC50ZXh0ID0ge2ZpZWxkOiBlLmZpZWxkKFRFWFQpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnRleHQgPSB7dmFsdWU6IFwiQWJjXCJ9O1xuICB9XG5cbiAgcC5mb250ID0ge3ZhbHVlOiBlLmNvbmZpZyhcImZvbnRcIil9O1xuICBwLmZvbnRXZWlnaHQgPSB7dmFsdWU6IGUuY29uZmlnKFwiZm9udFdlaWdodFwiKX07XG4gIHAuZm9udFN0eWxlID0ge3ZhbHVlOiBlLmNvbmZpZyhcImZvbnRTdHlsZVwiKX07XG4gIHAuYmFzZWxpbmUgPSB7dmFsdWU6IGUuY29uZmlnKFwidGV4dEJhc2VsaW5lXCIpfTtcblxuICAvLyBhbGlnblxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBpZiAoZS5pc1R5cGUoWCxPKSkge1xuICAgICAgcC5hbGlnbiA9IHt2YWx1ZTogXCJsZWZ0XCJ9O1xuICAgICAgcC5keCA9IHt2YWx1ZTogZS5jb25maWcoXCJ0ZXh0TWFyZ2luXCIpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5hbGlnbiA9IHt2YWx1ZTogXCJjZW50ZXJcIn1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLmFsaWduID0ge3ZhbHVlOiBcImxlZnRcIn07XG4gICAgcC5keCA9IHt2YWx1ZTogZS5jb25maWcoXCJ0ZXh0TWFyZ2luXCIpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmFsaWduID0ge3ZhbHVlOiBlLmNvbmZpZyhcInRleHRBbGlnblwiKX07XG4gIH1cblxuICByZXR1cm4gcDtcbn0iLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIiksXG4gIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgc2NhbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5zY2FsZS5uYW1lcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICBpZiAocHJvcHNbeF0gJiYgcHJvcHNbeF0uc2NhbGUpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbnNjYWxlLmRlZnMgPSBmdW5jdGlvbiAobmFtZXMsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIHZhciBzID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHNjYWxlLnR5cGUobmFtZSwgZW5jb2RpbmcpLFxuICAgICAgZG9tYWluOiBzY2FsZV9kb21haW4obmFtZSwgZW5jb2RpbmcsIG9wdClcbiAgICB9O1xuICAgIGlmIChzLnR5cGUgPT09IFwib3JkaW5hbFwiICYmICFlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAgIHMuc29ydCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2NhbGVfcmFuZ2UocywgZW5jb2RpbmcsIG9wdCk7XG5cbiAgICByZXR1cm4gKGEucHVzaChzKSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbnNjYWxlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZW5jb2RpbmcpIHtcbiAgdmFyIGZuO1xuICBzd2l0Y2ggKGVuY29kaW5nLnR5cGUobmFtZSkpIHtcbiAgICBjYXNlIE86IHJldHVybiBcIm9yZGluYWxcIjtcbiAgICBjYXNlIFQ6XG4gICAgICBzd2l0Y2goZW5jb2RpbmcuZm4obmFtZSkpe1xuICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgIGNhc2UgXCJtaW51dGVcIjpcbiAgICAgICAgY2FzZSBcImhvdXJcIjpcbiAgICAgICAgY2FzZSBcImRheVwiOlxuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgICAgIGNhc2UgXCJ5ZWFyXCI6XG4gICAgICAgICAgcmV0dXJuIFwibGluZWFyXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJ0aW1lXCI7XG4gICAgY2FzZSBROlxuICAgICAgaWYgKGVuY29kaW5nLmJpbihuYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2Rpbmcuc2NhbGUobmFtZSkudHlwZSB8fCBcImxpbmVhclwiO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2FsZV9kb21haW4obmFtZSwgZW5jb2RpbmcsIG9wdCkge1xuICBpZiAoZW5jb2RpbmcudHlwZShuYW1lKSA9PT0gVCl7XG4gICAgc3dpdGNoKGVuY29kaW5nLmZuKG5hbWUpKXtcbiAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgIGNhc2UgXCJtaW51dGVcIjogIHJldHVybiB1dGlsLnJhbmdlKDAsIDYwKTtcbiAgICAgIGNhc2UgXCJob3VyXCI6ICAgIHJldHVybiB1dGlsLnJhbmdlKDAsIDI0KTtcbiAgICAgIGNhc2UgXCJkYXlcIjogICAgIHJldHVybiB1dGlsLnJhbmdlKDAsIDcpO1xuICAgICAgY2FzZSBcImRhdGVcIjogICAgcmV0dXJuIHV0aWwucmFuZ2UoMCwgMzIpO1xuICAgICAgY2FzZSBcIm1vbnRoXCI6ICAgcmV0dXJuIHV0aWwucmFuZ2UoMCwgMTIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAvLyBUT0RPOiBhZGQgaW5jbHVkZUVtcHR5Q29uZmlnIGhlcmVcbiAgICBpZiAob3B0LnN0YXRzKSB7XG4gICAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhvcHQuc3RhdHNbZW5jb2RpbmcuZmllbGROYW1lKG5hbWUpXSk7XG4gICAgICB2YXIgZG9tYWluID0gdXRpbC5yYW5nZShiaW5zLnN0YXJ0LCBiaW5zLnN0b3AsIGJpbnMuc3RlcCk7XG4gICAgICByZXR1cm4gbmFtZT09PVkgPyBkb21haW4ucmV2ZXJzZSgpIDogZG9tYWluO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lID09IG9wdC5zdGFjayA/XG4gICAge1xuICAgICAgZGF0YTogU1RBQ0tFRCxcbiAgICAgIGZpZWxkOiBcImRhdGEuXCIgKyAob3B0LmZhY2V0ID8gXCJtYXhfXCIgOlwiXCIpICsgXCJzdW1fXCIgKyBlbmNvZGluZy5maWVsZChuYW1lLCB0cnVlKVxuICAgIH06XG4gICAge2RhdGE6IFRBQkxFLCBmaWVsZDogZW5jb2RpbmcuZmllbGQobmFtZSl9O1xufVxuXG5mdW5jdGlvbiBzY2FsZV9yYW5nZShzLCBlbmNvZGluZywgb3B0KSB7XG4gIHZhciBzcGVjID0gZW5jb2Rpbmcuc2NhbGUocy5uYW1lKTtcbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFg6XG4gICAgICBpZiAocy50eXBlPT09XCJvcmRpbmFsXCIpIHtcbiAgICAgICAgcy5iYW5kV2lkdGggPSArZW5jb2RpbmcuY29uZmlnKFwiYmFuZFNpemVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gb3B0LmNlbGxXaWR0aCA/IFswLCBvcHQuY2VsbFdpZHRoXSA6IFwid2lkdGhcIjtcbiAgICAgICAgLy9UT0RPIHplcm8gYW5kIHJldmVyc2Ugc2hvdWxkIGJlY29tZSBnZW5lcmljLCBhbmQgd2UganVzdCByZWFkIGRlZmF1bHQgZnJvbSBlaXRoZXIgdGhlIHNjaGVtYSBvciB0aGUgc2NoZW1hIGdlbmVyYXRvclxuICAgICAgICBzLnplcm8gPSBzcGVjLnplcm8gfHwgZW5jb2RpbmcuY29uZmlnKFwiX3haZXJvXCIpO1xuICAgICAgICBzLnJldmVyc2UgPSBzcGVjLnJldmVyc2UgfHwgZW5jb2RpbmcuY29uZmlnKFwiX3hSZXZlcnNlXCIpO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlPT09XCJ0aW1lXCIpe1xuICAgICAgICBzLm5pY2UgPSBlbmNvZGluZy5mbihzLm5hbWUpIHx8IGVuY29kaW5nLmNvbmZpZyhcInRpbWVTY2FsZU5pY2VcIik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGU9PT1cIm9yZGluYWxcIikge1xuICAgICAgICBzLmJhbmRXaWR0aCA9ICtlbmNvZGluZy5jb25maWcoXCJiYW5kU2l6ZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMucmFuZ2UgPSBvcHQuY2VsbEhlaWdodCA/IFtvcHQuY2VsbEhlaWdodCwgMF0gOiBcImhlaWdodFwiO1xuICAgICAgICAvL1RPRE8gemVybyBhbmQgcmV2ZXJzZSBzaG91bGQgYmVjb21lIGdlbmVyaWMsIGFuZCB3ZSBqdXN0IHJlYWQgZGVmYXVsdCBmcm9tIGVpdGhlciB0aGUgc2NoZW1hIG9yIHRoZSBzY2hlbWEgZ2VuZXJhdG9yXG4gICAgICAgIHMuemVybyA9IHNwZWMuemVybyB8fCBlbmNvZGluZy5jb25maWcoXCJfeVplcm9cIik7XG4gICAgICAgIHMucmV2ZXJzZSA9IHNwZWMucmV2ZXJzZSB8fCBlbmNvZGluZy5jb25maWcoXCJfeVJldmVyc2VcIik7XG4gICAgICB9XG5cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuXG4gICAgICBpZiAocy50eXBlPT09XCJ0aW1lXCIpe1xuICAgICAgICBzLm5pY2UgPSBlbmNvZGluZy5mbihzLm5hbWUpIHx8IGVuY29kaW5nLmNvbmZpZyhcInRpbWVTY2FsZU5pY2VcIik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUk9XOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBvcHQuY2VsbEhlaWdodCB8fCBlbmNvZGluZy5jb25maWcoXCJjZWxsSGVpZ2h0XCIpO1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0w6IC8vIHN1cHBvcnQgb25seSBvcmRpbmFsXG4gICAgICBzLmJhbmRXaWR0aCA9IG9wdC5jZWxsV2lkdGggfHwgZW5jb2RpbmcuY29uZmlnKFwiY2VsbFdpZHRoXCIpO1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVpFOlxuICAgICAgaWYgKGVuY29kaW5nLmlzKFwiYmFyXCIpKSB7XG4gICAgICAgIHMucmFuZ2UgPSBbMywgK2VuY29kaW5nLmNvbmZpZyhcImJhbmRTaXplXCIpXTtcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXMoVEVYVCkpIHtcbiAgICAgICAgcy5yYW5nZSA9IFs4LCA0MF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gWzEwLCAxMDAwXTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcy5yYW5nZSA9IFwic2hhcGVzXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTE9SOlxuICAgICAgaWYgKHMudHlwZSA9PT0gXCJvcmRpbmFsXCIpIHtcbiAgICAgICAgcy5yYW5nZSA9IFwiY2F0ZWdvcnkxMFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5yYW5nZSA9IFtcIiNkZGZcIiwgXCJzdGVlbGJsdWVcIl07XG4gICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBTFBIQTpcbiAgICAgIHMucmFuZ2UgPSBbMC4yLCAxLjBdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmcgbmFtZTogXCIrcy5uYW1lKTtcbiAgfVxuXG4gIHN3aXRjaChzLm5hbWUpe1xuICAgIGNhc2UgUk9XOlxuICAgIGNhc2UgQ09MOlxuICAgICAgcy5wYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKFwiY2VsbFBhZGRpbmdcIik7XG4gICAgICBzLm91dGVyUGFkZGluZyA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFg6XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHMudHlwZSA9PT0gXCJvcmRpbmFsXCIpIHsgLy8mJiAhcy5iYW5kV2lkdGhcbiAgICAgICAgcy5wb2ludHMgPSB0cnVlO1xuICAgICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoXCJiYW5kUGFkZGluZ1wiKTtcbiAgICAgIH1cbiAgfVxufSIsIi8vIFBhY2thZ2Ugb2YgZGVmaW5pbmcgVmVnYWxpdGUgU3BlY2lmaWNhdGlvbidzIGpzb24gc2NoZW1hXG4vL1xudmFyIHNjaGVtYSA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuc2NoZW1hLnV0aWwgPSByZXF1aXJlKCcuL3NjaGVtYXV0aWwnKTtcblxuc2NoZW1hLm1hcmt0eXBlID0ge1xuICB0eXBlOiBcInN0cmluZ1wiLFxuICBlbnVtOiBbXCJwb2ludFwiLCBcImJhclwiLCBcImxpbmVcIiwgXCJhcmVhXCIsIFwiY2lyY2xlXCIsIFwic3F1YXJlXCIsIFwidGV4dFwiXVxufTtcblxuc2NoZW1hLmFnZ3IgPSB7XG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIGVudW06IFtcImF2Z1wiLCBcInN1bVwiLCBcIm1pblwiLCBcIm1heFwiLCBcImNvdW50XCJdLFxuICBzdXBwb3J0ZWRFbnVtczoge1xuICAgIFE6IFtcImF2Z1wiLCBcInN1bVwiLCBcIm1pblwiLCBcIm1heFwiLCBcImNvdW50XCJdLFxuICAgIE86IFtcImNvdW50XCJdLFxuICAgIFQ6IFtcImF2Z1wiLCBcIm1pblwiLCBcIm1heFwiLCBcImNvdW50XCJdLFxuICAgIFwiXCI6IFtcImNvdW50XCJdLFxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczoge1wiUVwiOiB0cnVlLCBcIk9cIjogdHJ1ZSwgXCJUXCI6IHRydWUsIFwiXCI6IHRydWV9XG59O1xuXG5zY2hlbWEudGltZWZucyA9IFtcIm1vbnRoXCIsIFwieWVhclwiLCBcImRheVwiLCBcImRhdGVcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCJdO1xuXG5zY2hlbWEuZm4gPSB7XG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIGVudW06IHNjaGVtYS50aW1lZm5zLFxuICBzdXBwb3J0ZWRUeXBlczoge1wiVFwiOiB0cnVlfVxufVxuXG4vL1RPRE8oa2FuaXR3KTogYWRkIG90aGVyIHR5cGUgb2YgZnVuY3Rpb24gaGVyZVxuXG5zY2hlbWEuc2NhbGVfdHlwZSA9IHtcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgZW51bTogW1wibGluZWFyXCIsIFwibG9nXCIsXCJwb3dcIiwgXCJzcXJ0XCIsIFwicXVhbnRpbGVcIl0sXG4gIGRlZmF1bHQ6IFwibGluZWFyXCIsXG4gIHN1cHBvcnRlZFR5cGVzOiB7XCJRXCI6IHRydWV9XG59O1xuXG5zY2hlbWEuZmllbGQgPSB7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHJlcXVpcmVkOiBbXCJuYW1lXCIsIFwidHlwZVwiXSxcbiAgcHJvcGVydGllczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjbG9uZSA9IHV0aWwuZHVwbGljYXRlO1xudmFyIG1lcmdlID0gc2NoZW1hLnV0aWwubWVyZ2U7XG5cbnZhciB0eXBpY2FsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZW51bTogW1wiT1wiLCBcIlFcIiwgXCJUXCJdXG4gICAgfSxcbiAgICBiaW46IHtcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBzdXBwb3J0ZWRUeXBlczoge1wiUVwiOiB0cnVlLCBcIk9cIjogdHJ1ZX1cbiAgICB9LFxuICAgIGFnZ3I6IHNjaGVtYS5hZ2dyLFxuICAgIGZuOiBzY2hlbWEuZm4sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGU6IHNjaGVtYS5zY2FsZV90eXBlLFxuICAgICAgICByZXZlcnNlOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICB6ZXJvOiB7XG4gICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5jbHVkZSB6ZXJvXCIsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHtcIlFcIjogdHJ1ZX1cbiAgICAgICAgfSxcbiAgICAgICAgbmljZToge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZW51bTogW1wic2Vjb25kXCIsIFwibWludXRlXCIsIFwiaG91clwiLCBcImRheVwiLCBcIndlZWtcIiwgXCJtb250aFwiLCBcInllYXJcIl0sXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHtcIlRcIjogdHJ1ZX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBvbmx5T3JkaW5hbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGVudW06IFtcIk9cIl1cbiAgICB9LFxuICAgIGJpbjoge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHN1cHBvcnRlZFR5cGVzOiB7XCJPXCI6IHRydWV9XG4gICAgfSxcbiAgICBhZ2dyOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZW51bTogW1wiY291bnRcIl0sXG4gICAgICBzdXBwb3J0ZWRUeXBlczoge1wiT1wiOiB0cnVlfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBheGlzTWl4aW4gPSB7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBheGlzOiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBncmlkOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICB0aXRsZTogeyB0eXBlOiBcImJvb2xlYW5cIiwgZGVmYXVsdDogdHJ1ZSB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBsZWdlbmRNaXhpbiA9IHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcHJvcGVydGllczoge1xuICAgIGxlZ2VuZDogeyB0eXBlOiBcImJvb2xlYW5cIiwgZGVmYXVsdDogdHJ1ZSB9XG4gIH1cbn1cblxudmFyIHRleHRNaXhpbiA9IHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcHJvcGVydGllczoge1xuICAgIHRleHQ6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHdlaWdodDoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZW51bTogW1wibm9ybWFsXCIsIFwiYm9sZFwiXSxcbiAgICAgICAgICBkZWZhdWx0OiBcIm5vcm1hbFwiLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7XCJUXCI6IHRydWV9XG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7XCJUXCI6IHRydWV9XG4gICAgICAgIH0sXG4gICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiSGFsdmV0aWNhIE5ldWVcIixcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczoge1wiVFwiOiB0cnVlfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB4ID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwgYXhpc01peGluKTtcbnZhciB5ID0gY2xvbmUoeCk7XG5cbnZhciByb3cgPSBjbG9uZShvbmx5T3JkaW5hbEZpZWxkKTtcbnZhciBjb2wgPSBjbG9uZShyb3cpO1xuXG52YXIgc2l6ZSA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIGxlZ2VuZE1peGluKTtcbnZhciBjb2xvciA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIGxlZ2VuZE1peGluKTtcbnZhciBhbHBoYSA9IGNsb25lKHR5cGljYWxGaWVsZCk7XG52YXIgc2hhcGUgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgbGVnZW5kTWl4aW4pO1xuXG52YXIgdGV4dCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHRleHRNaXhpbik7XG5cbnZhciBjZmcgPSB7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyB0ZW1wbGF0ZVxuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IFtcImludGVnZXJcIl1cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIF9taW5XaWR0aDoge1xuICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICBkZWZhdWx0OiAyMFxuICAgIH0sXG4gICAgX21pbkhlaWdodDoge1xuICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICBkZWZhdWx0OiAyMFxuICAgIH0sXG5cbiAgICAvLyBkYXRhIHNvdXJjZVxuICAgIGRhdGFGb3JtYXRUeXBlOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZW51bTogW1wianNvblwiLCBcImNzdlwiXSxcbiAgICAgIGRlZmF1bHQ6IFwianNvblwiXG4gICAgfSxcbiAgICB1c2VWZWdhU2VydmVyOiB7XG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkYXRhVXJsOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2ZWdhU2VydmVyVGFibGU6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZlZ2FTZXJ2ZXJVcmw6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkZWZhdWx0OiBcImh0dHA6Ly9sb2NhbGhvc3Q6MzAwMVwiXG4gICAgfVxuICB9XG59XG5cbi8qKiBAdHlwZSBPYmplY3QgU2NoZW1hIG9mIGEgdmVnYWxpdGUgc3BlY2lmaWNhdGlvbiAqL1xuc2NoZW1hLnNjaGVtYSA9IHtcbiAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcmVxdWlyZWQ6IFtcIm1hcmt0eXBlXCIsIFwiZW5jXCIsIFwiY2ZnXCJdLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWFya3R5cGU6IHNjaGVtYS5tYXJrdHlwZSxcbiAgICBlbmM6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfVxuICAgIH0sXG4gICAgY2ZnOiBjZmdcbiAgfVxufTtcblxuLyoqIEluc3RhbnRpYXRlIGEgdmVyYm9zZSB2bCBzcGVjIGZyb20gdGhlIHNjaGVtYSAqL1xuc2NoZW1hLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHNjaGVtYS51dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5zY2hlbWEpO1xufVxuIiwidmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDBcbn1cblxuLy8gaW5zdGFudGlhdGUgYSBzY2hlbWFcbnV0aWwuaW5zdGFudGlhdGUgPSBmdW5jdGlvbihzY2hlbWEsIHJlcXVpcmVkKSB7XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVxdXJpZWQgPSBzY2hlbWEucmVxdWlyZWQgPyBzY2hlbWEucmVxdWlyZWQgOiBbXTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgY2hpbGQgPSBzY2hlbWEucHJvcGVydGllc1tuYW1lXTtcbiAgICAgIGluc3RhbmNlW25hbWVdID0gdXRpbC5pbnN0YW50aWF0ZShjaGlsZCwgcmVxdXJpZWQuaW5kZXhPZihuYW1lKSAhPSAtMSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEuZGVmYXVsdDtcbiAgfSBlbHNlIGlmIChzY2hlbWEuZW51bSAmJiByZXF1aXJlZCkge1xuICAgIHJldHVybiBzY2hlbWEuZW51bVswXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBkZWZhdWx0cyBmcm9tIGFuIGluc3RhbmNlXG51dGlsLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihkZWZhdWx0cywgaW5zdGFuY2UpIHtcbiAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBpbnN0YW5jZSkge1xuICAgIGlmICghZGVmYXVsdHMgfHwgZGVmYXVsdHNbcHJvcF0gIT09IGluc3RhbmNlW3Byb3BdKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlW3Byb3BdID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGMgPSB1dGlsLmRpZmZlcmVuY2UoZGVmYXVsdHNbcHJvcF0sIGluc3RhbmNlW3Byb3BdKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGMpKVxuICAgICAgICAgIGNoYW5nZXNbcHJvcF0gPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IGluc3RhbmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbi8vIHJlY3Vyc2l2ZWx5IG1lcmdlcyBpbnN0YW5jZSBpbnRvIGRlZmF1bHRzXG51dGlsLm1lcmdlID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBpbnN0YW5jZSkge1xuICBpZiAodHlwZW9mIGluc3RhbmNlIT09J29iamVjdCcgfHwgaW5zdGFuY2U9PT1udWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgZm9yICh2YXIgcCBpbiBpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UuaGFzT3duUHJvcGVydHkocCkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaW5zdGFuY2VbcF09PT11bmRlZmluZWQgKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZVtwXSAhPT0gJ29iamVjdCcgfHwgaW5zdGFuY2VbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzW3BdID0gaW5zdGFuY2VbcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdHNbcF0gIT09ICdvYmplY3QnIHx8IGRlZmF1bHRzW3BdID09PSBudWxsKSB7XG4gICAgICBkZWZhdWx0c1twXSA9IHV0aWwubWVyZ2UoaW5zdGFuY2VbcF0uY29uc3RydWN0b3IgPT09IEFycmF5ID8gW10gOiB7fSwgaW5zdGFuY2VbcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLm1lcmdlKGRlZmF1bHRzW3BdLCBpbnN0YW5jZVtwXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cbiIsInZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0aW1lO1xuXG5mdW5jdGlvbiB0aW1lKHNwZWMsIGVuY29kaW5nLCBvcHQpe1xuICB2YXIgdGltZUZpZWxkcyA9IHt9LCB0aW1lRm4gPSB7fTtcblxuICAvLyBmaW5kIHVuaXF1ZSBmb3JtdWxhIHRyYW5zZm9ybWF0aW9uIGFuZCBiaW4gZnVuY3Rpb25cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihlbmNUeXBlLCBmaWVsZCl7XG4gICAgaWYoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC5mbil7XG4gICAgICB0aW1lRmllbGRzW2VuY29kaW5nLmZpZWxkKGVuY1R5cGUpXSA9IHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICBlbmNUeXBlOiBlbmNUeXBlXG4gICAgICB9O1xuICAgICAgdGltZUZuW2ZpZWxkLmZuXSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBhZGQgZm9ybXVsYSB0cmFuc2Zvcm1cbiAgdmFyIGRhdGEgPSBzcGVjLmRhdGFbMF0sXG4gICAgdHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gPSBkYXRhLnRyYW5zZm9ybSB8fCBbXTtcblxuICBmb3IgKHZhciBmIGluIHRpbWVGaWVsZHMpIHtcbiAgICB2YXIgdGYgPSB0aW1lRmllbGRzW2ZdO1xuICAgIHRpbWUudHJhbnNmb3JtKHRyYW5zZm9ybSwgZW5jb2RpbmcsIHRmLmVuY1R5cGUsIHRmLmZpZWxkKTtcbiAgfVxuXG4gIC8vIGFkZCBzY2FsZXNcbiAgdmFyIHNjYWxlcyA9IHNwZWMuc2NhbGVzID0gc3BlYy5zY2FsZXMgfHwgW107XG4gIGZvciAodmFyIGZuIGluIHRpbWVGbikge1xuICAgIHRpbWUuc2NhbGUoc2NhbGVzLCBmbiwgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBzcGVjO1xufVxuXG4vKipcbiAqIEByZXR1cm4ge1N0cmluZ30gZGF0ZSBiaW5uaW5nIGZvcm11bGEgb2YgdGhlIGdpdmVuIGZpZWxkXG4gKi9cbnRpbWUuZm9ybXVsYSA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICB2YXIgZGF0ZSA9IFwibmV3IERhdGUoZC5kYXRhLlwiK2ZpZWxkLm5hbWUrXCIpXCI7XG4gIHN3aXRjaChmaWVsZC5mbil7XG4gICAgY2FzZSBcInNlY29uZFwiOiAgcmV0dXJuIGRhdGUgKyBcIi5nZXRVVENTZWNvbmRzKClcIjtcbiAgICBjYXNlIFwibWludXRlXCI6ICByZXR1cm4gZGF0ZSArIFwiLmdldFVUQ01pbnV0ZXMoKVwiO1xuICAgIGNhc2UgXCJob3VyXCI6ICAgIHJldHVybiBkYXRlICsgXCIuZ2V0VVRDSG91cnMoKVwiO1xuICAgIGNhc2UgXCJkYXlcIjogICAgIHJldHVybiBkYXRlICsgXCIuZ2V0VVRDRGF5KClcIjtcbiAgICBjYXNlIFwiZGF0ZVwiOiAgICByZXR1cm4gZGF0ZSArIFwiLmdldFVUQ0RhdGUoKVwiO1xuICAgIGNhc2UgXCJtb250aFwiOiAgIHJldHVybiBkYXRlICsgXCIuZ2V0VVRDTW9udGgoKVwiO1xuICAgIGNhc2UgXCJ5ZWFyXCI6ICAgIHJldHVybiBkYXRlICsgXCIuZ2V0VVRDRnVsbFllYXIoKVwiO1xuICB9XG4gIC8vIFRPRE8gYWRkIGNvbnRpbnVvdXMgYmlubmluZ1xuICBjb25zb2xlLmVycm9yKFwibm8gZnVuY3Rpb24gc3BlY2lmaWVkIGZvciBkYXRlXCIpO1xufTtcblxuLyoqIGFkZCBmb3JtdWxhIHRyYW5zZm9ybXMgdG8gZGF0YSAqL1xudGltZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnNmb3JtLCBlbmNvZGluZywgZW5jVHlwZSwgZmllbGQpIHtcbiAgdHJhbnNmb3JtLnB1c2goe1xuICAgIHR5cGU6IFwiZm9ybXVsYVwiLFxuICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZChlbmNUeXBlKSxcbiAgICBleHByOiB0aW1lLmZvcm11bGEoZmllbGQpXG4gIH0pO1xufTtcblxudGltZS5zY2FsZSA9IGZ1bmN0aW9uIChzY2FsZXMsIGZuLCBlbmNvZGluZykge1xuICB2YXIgbGFiZWxMZW5ndGggPSBlbmNvZGluZy5jb25maWcoXCJ0aW1lU2NhbGVMYWJlbExlbmd0aFwiKTtcbiAgLy8gVE9ETyBhZGQgb3B0aW9uIGZvciBzaG9ydGVyIHNjYWxlIC8gY3VzdG9tIHJhbmdlXG4gIHN3aXRjaChmbil7XG4gICAgY2FzZSBcImRheVwiOlxuICAgICAgc2NhbGVzLnB1c2goe1xuICAgICAgICBuYW1lOiBcInRpbWUtZGF5XCIsXG4gICAgICAgIHR5cGU6IFwib3JkaW5hbFwiLFxuICAgICAgICBkb21haW46IHV0aWwucmFuZ2UoMCw3KSxcbiAgICAgICAgcmFuZ2U6IFtcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCJdLm1hcChcbiAgICAgICAgICBmdW5jdGlvbihzKXsgcmV0dXJuIHMuc3Vic3RyKDAsIGxhYmVsTGVuZ3RoKTt9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1vbnRoXCI6XG4gICAgICBzY2FsZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwidGltZS1tb250aFwiLFxuICAgICAgICB0eXBlOiBcIm9yZGluYWxcIixcbiAgICAgICAgZG9tYWluOiB1dGlsLnJhbmdlKDAsMTIpLFxuICAgICAgICByYW5nZTogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0ubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24ocyl7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG4iLCJ2YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnV0aWwua2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGsgPSBbXSwgeDtcbiAgZm9yICh4IGluIG9iaikgay5wdXNoKHgpO1xuICByZXR1cm4gaztcbn1cblxudXRpbC52YWxzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdiA9IFtdLCB4O1xuICBmb3IgKHggaW4gb2JqKSB2LnB1c2gob2JqW3hdKTtcbiAgcmV0dXJuIHY7XG59XG5cbnV0aWwucmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcihcImluZmluaXRlIHJhbmdlXCIpO1xuICB2YXIgcmFuZ2UgPSBbXSwgaSA9IC0xLCBqO1xuICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGopO1xuICBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGopO1xuICByZXR1cm4gcmFuZ2U7XG59XG5cbnV0aWwuZmluZCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuKSB7XG4gIHZhciBsID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4W3BhdHRlcm4ubmFtZV0gPT09IHBhdHRlcm4udmFsdWU7XG4gIH0pO1xuICByZXR1cm4gbC5sZW5ndGggJiYgbFswXSB8fCBudWxsO1xufVxuXG51dGlsLnVuaXEgPSBmdW5jdGlvbiAoZGF0YSwgZmllbGQpIHtcbiAgdmFyIG1hcCA9IHt9LCBjb3VudCA9IDAsIGksIGs7XG4gIGZvciAoaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBrID0gZGF0YVtpXVtmaWVsZF07XG4gICAgaWYgKCFtYXBba10pIHtcbiAgICAgIG1hcFtrXSA9IDE7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbnV0aWwubWlubWF4ID0gZnVuY3Rpb24gKGRhdGEsIGZpZWxkKSB7XG4gIHZhciBzdGF0cyA9IHttaW46ICtJbmZpbml0eSwgbWF4OiAtSW5maW5pdHl9O1xuICBmb3IgKGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHYgPSBkYXRhW2ldW2ZpZWxkXTtcbiAgICBpZiAodiA+IHN0YXRzLm1heCkgc3RhdHMubWF4ID0gdjtcbiAgICBpZiAodiA8IHN0YXRzLm1pbikgc3RhdHMubWluID0gdjtcbiAgfVxuICByZXR1cm4gc3RhdHM7XG59XG5cbnV0aWwuZHVwbGljYXRlID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnV0aWwuYW55ID0gZnVuY3Rpb24oYXJyLCBmKXtcbiAgdmFyIGk9MCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmKGYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnV0aWwuYWxsID0gZnVuY3Rpb24oYXJyLCBmKXtcbiAgdmFyIGk9MCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmKCFmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG51dGlsLm1lcmdlID0gZnVuY3Rpb24oZGVzdCwgc3JjKXtcbiAgcmV0dXJuIHV0aWwua2V5cyhzcmMpLnJlZHVjZShmdW5jdGlvbihjLCBrKXtcbiAgICBjW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiBjO1xuICB9LCBkZXN0KTtcbn07XG5cbnV0aWwuZ2V0YmlucyA9IGZ1bmN0aW9uIChzdGF0cykge1xuICByZXR1cm4gdmcuYmlucyh7XG4gICAgbWluOiBzdGF0cy5taW4sXG4gICAgbWF4OiBzdGF0cy5tYXgsXG4gICAgbWF4YmluczogTUFYX0JJTlNcbiAgfSk7XG59XG5cblxudXRpbC5lcnJvciA9IGZ1bmN0aW9uKG1zZyl7XG4gIGNvbnNvbGUuZXJyb3IoXCJbVkwgRXJyb3JdXCIsIG1zZyk7XG59XG5cbiJdfQ==\n","\"use strict\";\n\nvar global = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  schema = require('./schema');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config) {\n    // TODO: caching\n    var encDefaults = schema.util.instantiate(schema.schema.properties.enc);\n    var cfgDefaults = schema.util.instantiate(schema.schema.properties.cfg);\n\n    // Hack\n    for (var k in consts.DEFAULTS) {\n      cfgDefaults[k] = consts.DEFAULTS[k];\n    }\n\n    // remove field defs that we don't use in encoding\n    for (var k in encDefaults) {\n      if (!enc[k]) {\n        delete encDefaults[k];\n      }\n    }\n\n    this._marktype = marktype;\n    this._enc = schema.util.merge(encDefaults, enc);\n    this._cfg = schema.util.merge(cfgDefaults, config);\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(x) {\n    return this._enc[x] !== undefined;\n  };\n\n  proto.enc = function(x){\n    return this._enc[x];\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(x, nodata, nofn) {\n    if (!this.has(x)) return null;\n\n    var f = (nodata ? \"\" : \"data.\");\n\n    if (this._enc[x].aggr === \"count\") {\n      return f + \"count\";\n    } else if (!nofn && this._enc[x].bin) {\n      return f + \"bin_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].aggr) {\n      return f + this._enc[x].aggr + \"_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].fn){\n      return f + this._enc[x].fn + \"_\" + this._enc[x].name;\n    } else {\n      return f + this._enc[x].name;\n    }\n  };\n\n  proto.fieldName = function(x){\n    return this._enc[x].name;\n  }\n\n  proto.fieldTitle = function(x){\n    if (this._enc[x].aggr) {\n      return this._enc[x].aggr + \"(\" + this._enc[x].name + \")\";\n    } else {\n      return this._enc[x].name;\n    }\n  }\n\n  proto.scale = function(x){\n    return this._enc[x].scale || {};\n  }\n\n  proto.axis = function(x){\n    return this._enc[x].axis || {};\n  }\n\n  proto.aggr = function(x){\n    return this._enc[x].aggr;\n  }\n\n  proto.bin = function(x){\n    return this._enc[x].bin;\n  }\n\n  proto.legend = function(x){\n    return this._enc[x].legend;\n  }\n\n  proto.fn = function(x){\n    return this._enc[x].fn;\n  }\n\n  proto.any = function(f){\n    return util.any(this._enc, f);\n  }\n\n  proto.all = function(f){\n    return util.all(this._enc, f);\n  }\n\n  proto.length = function(){\n    return util.keys(this._enc).length;\n  }\n\n  proto.reduce = function(f, init){\n    var r = init, i=0;\n    for (k in this._enc){\n      r = f(r, this._enc[k], k, this._enc);\n    }\n    return r;\n  }\n\n  proto.forEach = function(f) {\n    var i=0, k;\n    for (k in this._enc) {\n      f(k, this._enc[k], i++);\n    }\n  };\n\n  proto.type = function(x) {\n    return this.has(x) ? this._enc[x].type : null;\n  };\n\n  proto.isType = function(x, t) {\n    var xt = this.type(x);\n    if (xt == null) return false;\n    return (xt & t) > 0;\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig){\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for(var e in enc){\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc\n    }\n\n    if(!excludeConfig){\n      spec.cfg = util.duplicate(this._cfg)\n    }\n\n    return spec;\n  };\n\n  proto.toShorthand = function(){\n    var enc = this._enc;\n    return this._marktype + \".\" + util.keys(enc).map(function(e){\n      var v = enc[e];\n        return e + \"-\" +\n          (v.aggr ? v.aggr+\"_\" : \"\") +\n          (v.fn ? v.fn+\"_\" : \"\") +\n          (v.bin ? \"bin_\" : \"\") +\n          (v.name || \"\") + \"-\" +\n          consts.dataTypeNames[v.type];\n      }\n    ).join(\".\");\n  }\n\n  Encoding.parseShorthand = function(shorthand, cfg){\n    var enc = shorthand.split(\".\"),\n      marktype = enc.shift();\n\n    enc = enc.reduce(function(m, e){\n      var split = e.split(\"-\"),\n        enctype = split[0],\n        o = {name: split[1], type: consts.dataTypes[split[2]]};\n\n      // check aggregate type\n      for(var i in schema.aggr.enum){\n        var a = schema.aggr.enum[i];\n        if(o.name.indexOf(a+\"_\") == 0){\n          o.name = o.name.substr(a.length+1);\n          if (a==\"count\" && o.name.length === 0) o.name = \"*\";\n          o.aggr = a;\n          break;\n        }\n      }\n      // check time fn\n      for(var i in schema.timefns){\n        var f = schema.timefns[i];\n        if(o.name && o.name.indexOf(f+\"_\") == 0){\n          o.name = o.name.substr(o.length+1);\n          o.fn = f;\n          break;\n        }\n      }\n\n      // check bin\n      if(o.name && o.name.indexOf(\"bin_\") == 0){\n        o.name = o.name.substr(4);\n        o.bin = true;\n      }\n\n      m[enctype] = o;\n      return m;\n    }, {});\n\n    return new Encoding(marktype, enc, cfg);\n  }\n\n  Encoding.fromSpec = function(spec, extraCfg) {\n    var enc = util.duplicate(spec.enc);\n\n    //convert type from string to bitcode (e.g, O=1)\n    for(var e in enc){\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, util.merge(spec.cfg, extraCfg || {}));\n  }\n\n  return Encoding;\n\n})();\n","var globals = require('./globals'),\n  util = require('./util');\n\nvar axis = module.exports = {};\n\naxis.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s===X || s===Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function (name, encoding, opt){\n  var type = name;\n  var isCol = name==COL, isRow = name==ROW;\n  if(isCol) type = \"x\";\n  if(isRow) type = \"y\";\n\n  var axis = {\n    type: type,\n    scale: name,\n  };\n\n  if (encoding.isType(name, Q)) {\n    //TODO(kanitw): better determine # of ticks\n    axis.ticks = 3;\n  }\n\n  if (encoding.axis(name).grid) {\n    axis.grid = true;\n    axis.layer = \"back\";\n  }\n\n  if (encoding.axis(name).title) {\n    //show title by default\n\n    axis = axis_title(axis, name, encoding, opt);\n  }\n\n  if(isRow || isCol){\n    axis.properties = {\n      ticks: { opacity: {value: 0} },\n      majorTicks: { opacity: {value: 0} },\n      axis: { opacity: {value: 0} }\n    };\n  }\n  if(isCol){\n    axis.offset = [opt.xAxisMargin || 0, encoding.config(\"yAxisMargin\")];\n    axis.orient = \"top\";\n  }\n\n  if (name==\"x\" && (encoding.isType(name, O|T) || encoding.bin(name))) {\n    axis.properties = {\n      labels: {\n        angle: {value: 270},\n        align: {value: \"right\"},\n        baseline: {value: \"middle\"}\n      }\n    };\n  }\n\n  // add custom label for time type\n  if (encoding.isType(name, T)) {\n    var fn = encoding.fn(name),\n      properties = axis.properties = axis.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    switch (fn) {\n      case \"day\":\n      case \"month\":\n        text.scale = \"time-\"+fn;\n        break;\n    }\n  }\n\n  return axis;\n};\n\nfunction axis_title(axis, name, encoding, opt){\n  axis.title = encoding.fieldTitle(name);\n  if(name==Y){\n    axis.titleOffset = 60;\n    // TODO: set appropriate titleOffset\n    // maybe based on some string length from stats\n  }\n  return axis;\n}\n","var globals = require('./globals'),\n  util = require('./util'),\n  axis = require('./axis'),\n  legends = require('./legends'),\n  marks = require('./marks'),\n  scale = require('./scale'),\n  time = require('./time');\n\nvar compile = module.exports = function(encoding, stats) {\n  var size = setSize(encoding, stats),\n    cellWidth = size.cellWidth,\n    cellHeight = size.cellHeight;\n\n  var hasAgg = encoding.any(function(v, k){\n    return v.aggr !== undefined;\n  });\n\n  var spec = template(encoding, size, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdef = markdef(mark, encoding, {\n      hasAggregate: hasAgg\n    });\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  group.marks.push(mdef);\n  // TODO: return value not used\n  binning(spec.data[0], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if(!preaggregatedData){\n    spec = time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec.data[0], encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isType(X, Q | T) && encoding.isType(Y, O)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    mdef.from.transform = [{type: \"sort\", by: encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding);\n    group.legends = legends.defs(encoding);\n  }\n  return spec;\n};\n\nfunction getCardinality(encoding, encType, stats){\n  var field = encoding.fieldName(encType);\n  if (encoding.bin(encType)) {\n    var bins = util.getbins(stats[field]);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  return stats[field].cardinality;\n}\n\nfunction setSize(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y);\n\n  // HACK to set chart size\n  // NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  // One solution is to update Vega to support auto-sizing\n  // In the meantime, auto-padding (mostly) does the trick\n  //\n  var colCardinality = hasCol ? getCardinality(encoding, COL, stats) : 1,\n    rowCardinality = hasRow ? getCardinality(encoding, ROW, stats) : 1;\n\n  var cellWidth = hasX ?\n      +encoding.config(\"cellWidth\") || encoding.config(\"width\") * 1.0 / colCardinality :\n      encoding.marktype() === \"text\" ?\n        +encoding.config(\"textCellWidth\") :\n        +encoding.config(\"bandSize\"),\n    cellHeight = hasY ?\n      +encoding.config(\"cellHeight\") || encoding.config(\"height\") * 1.0 / rowCardinality :\n      +encoding.config(\"bandSize\"),\n    cellPadding = encoding.config(\"cellPadding\"),\n    bandPadding = encoding.config(\"bandPadding\"),\n    width = encoding.config(\"_minWidth\"),\n    height = encoding.config(\"_minHeight\");\n\n  if (hasX && (encoding.isType(X, O) || encoding.bin(X))) { //ordinal field will override parent\n    // bands within cell use rangePoints()\n    var xCardinality = getCardinality(encoding, X, stats);\n    cellWidth = (xCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  width = cellWidth * ((1 + cellPadding) * (colCardinality-1) + 1);\n\n  if (hasY && (encoding.isType(Y, O) || encoding.bin(Y))) {\n    // bands within cell use rangePoint()\n    var yCardinality = getCardinality(encoding, Y, stats);\n    cellHeight = (yCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  height = cellHeight * ((1 + cellPadding) * (rowCardinality-1) + 1);\n\n  return {\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    width: width,\n    height:height\n  };\n}\n\nfunction facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats) {\n    var enter = group.properties.enter;\n    var facetKeys = [], cellAxes = [];\n\n    var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n    var xAxisMargin = encoding.has(Y) ? encoding.config(\"xAxisMargin\") : undefined;\n\n    enter.fill = {value: encoding.config(\"cellBackgroundColor\")};\n\n    //move \"from\" to cell level and add facet transform\n    group.from = {data: group.marks[0].from.data};\n\n    if (group.marks[0].from.transform) {\n      delete group.marks[0].from.data; //need to keep transform for subfacetting case\n    } else {\n      delete group.marks[0].from;\n    }\n    if (hasRow) {\n      if (!encoding.isType(ROW, O)) {\n        util.error(\"Row encoding should be ordinal.\");\n      }\n      enter.y = {scale: ROW, field: \"keys.\" + facetKeys.length};\n      enter.height = {\"value\": cellHeight}; // HACK\n\n      facetKeys.push(encoding.field(ROW));\n\n      var from;\n      if (hasCol) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(COL)]});\n      }\n\n      var axesGrp = groupdef(\"x-axes\", {\n          axes: encoding.has(X) ?  axis.defs([\"x\"], encoding) : undefined,\n          x: hasCol ? {scale: COL, field: \"keys.0\", offset: xAxisMargin} : {value: xAxisMargin},\n          width: hasCol && {\"value\": cellWidth}, //HACK?\n          from: from\n        });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || []);\n      spec.axes.push.apply(spec.axes, axis.defs([\"row\"], encoding));\n    } else { // doesn't have row\n      if(encoding.has(X)){\n        //keep x axis in the cell\n        cellAxes.push.apply(cellAxes, axis.defs([\"x\"], encoding));\n      }\n    }\n\n    if (hasCol) {\n      if (!encoding.isType(COL, O)) {\n        util.error(\"Col encoding should be ordinal.\");\n      }\n      enter.x = {scale: COL, field: \"keys.\" + facetKeys.length};\n      enter.width = {\"value\": cellWidth}; // HACK\n\n      facetKeys.push(encoding.field(COL));\n\n      var from;\n      if (hasRow) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(ROW)]});\n      }\n\n      var axesGrp = groupdef(\"y-axes\", {\n        axes: encoding.has(Y) ? axis.defs([\"y\"], encoding) : undefined,\n        y: hasRow && {scale: ROW, field: \"keys.0\"},\n        x: hasRow && {value: xAxisMargin},\n        height: hasRow && {\"value\": cellHeight}, //HACK?\n        from: from\n      });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || [])\n      spec.axes.push.apply(spec.axes, axis.defs([\"col\"], encoding, {\n        xAxisMargin: xAxisMargin\n      }));\n    } else { // doesn't have col\n      if(encoding.has(Y)){\n        cellAxes.push.apply(cellAxes, axis.defs([\"y\"], encoding));\n      }\n    }\n\n    if(hasRow){\n      if(enter.x) enter.x.offset= xAxisMargin;\n      else enter.x = {value: xAxisMargin};\n    }\n    if(hasCol){\n      //TODO fill here..\n    }\n\n    // assuming equal cellWidth here\n    // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n    spec.scales = (spec.scales ||[]).concat(scale.defs(\n      scale.names(enter).concat(scale.names(mdef.properties.update)),\n      encoding,\n      {cellWidth: cellWidth, cellHeight: cellHeight, stack: stack, facet:true, stats: stats}\n    )); // row/col scales + cell scales\n\n    if (cellAxes.length > 0) {\n      group.axes = cellAxes;\n    }\n\n    // add facet transform\n    var trans = (group.from.transform || (group.from.transform = []));\n    trans.unshift({type: \"facet\", keys: facetKeys});\n\n  return spec;\n  }\n\nfunction subfacet(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef(\"subfacet\", {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: \"facet\", keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: \"sort\", by: encoding.field(COLOR)});\n  }\n}\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n  encoding.forEach(function(vv, d) {\n    if (d.bin) bins[d.name] = d.name;\n  });\n  bins = util.keys(bins);\n\n  if (bins.length === 0 || opt.preaggregatedData) return false;\n\n  if (!spec.transform) spec.transform = [];\n  bins.forEach(function(d) {\n    spec.transform.push({\n      type: \"bin\",\n      field: \"data.\" + d,\n      output: \"data.bin_\" + d,\n      maxbins: MAX_BINS\n    });\n  });\n  return bins;\n}\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n  var dims = {}, meas = {}, detail = {}, facets={};\n  encoding.forEach(function(encType, field) {\n    if (field.aggr) {\n      if(field.aggr===\"count\"){\n        meas[\"count\"] = {op:\"count\", field:\"*\"};\n      }else{\n        meas[field.aggr+\"|\"+field.name] = {\n          op:field.aggr,\n          field:\"data.\"+field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType==ROW || encType == COL){\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!spec.transform) spec.transform = [];\n    spec.transform.push({\n      type: \"aggregate\",\n      groupby: dims,\n      fields: meas\n    });\n\n    if (encoding.marktype() === TEXT) {\n      meas.forEach( function (m) {\n        var fieldName = m.field.substr(5), //remove \"data.\"\n          field = \"data.\" + (m.op ? m.op + \"_\" : \"\") + fieldName;\n        spec.transform.push({\n          type: \"formula\",\n          field: field,\n          expr: \"d3.format('.2f')(d.\"+field+\")\"\n        });\n      });\n    }\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  }\n}\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n  if (!encoding.has(COLOR)) return false;\n\n  var dim = X, val = Y, idx = 1;\n  if (encoding.isType(X,Q|T) && !encoding.isType(Y,Q|T) && encoding.has(Y)) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: \"aggregate\",\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: \"sum\", field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if(facets && facets.length > 0){\n    stacked.transform.push({ //calculate max for each facet\n      type: \"aggregate\",\n      groupby: facets,\n      fields: [{op: \"max\", field: \"data.sum_\" + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: \"stack\",\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val+\"2\"}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val+\"2\"] = mdef.properties.enter[val+\"2\"] = {scale: val, field: val+\"2\"};\n\n  return val; //return stack encoding\n}\n\n\nfunction markdef(mark, encoding, opt) {\n  var p = mark.prop(encoding, opt)\n  return {\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  };\n}\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: \"group\",\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: \"width\"},\n        height: opt.height || {group: \"height\"}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction template(encoding, size, stats) { //hack use stats\n\n  var data = {name:TABLE, format: {type: encoding.config(\"dataFormatType\")}},\n    dataUrl = vl.data.getUrl(encoding, stats);\n  if(dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  encoding.forEach(function(encType, field){\n    if(field.type == T){\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = \"date\";\n    }else if(field.type == Q){\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === \"count\") {\n        var name = \"count\";\n      } else if(preaggregatedData && field.bin){\n        var name = \"bin_\" + field.name;\n      } else if(preaggregatedData && field.aggr){\n        var name = field.aggr + \"_\" + field.name;\n      } else{\n        var name = field.name;\n      }\n      data.format.parse[name] = \"number\";\n    }\n  });\n\n  return {\n    width: size.width,\n    height: size.height,\n    padding: \"auto\",\n    data: [data],\n    marks: [groupdef(\"cell\", {\n      width: size.cellWidth ? {value: size.cellWidth}: undefined,\n      height: size.cellHeight ? {value: size.cellHeight} : undefined\n    })]\n  };\n}\n","var globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT];\n\nconsts.dataTypes = {\"O\": O, \"Q\": Q, \"T\": T};\n\nconsts.dataTypeNames = [\"O\",\"Q\",\"T\"].reduce(function(r,x) {\n  r[consts.dataTypes[x]] = x; return r;\n},{});\n\nconsts.DEFAULTS = {\n  //small multiples\n  cellHeight: 200, // will be overwritten by bandWidth\n  cellWidth: 200, // will be overwritten by bandWidth\n  cellPadding: 0.1,\n  cellBackgroundColor: \"#fdfdfd\",\n  xAxisMargin: 80,\n  yAxisMargin: 0,\n  textCellWidth: 90,\n\n  // marks\n  bandSize: 21,\n  bandPadding: 1,\n  pointSize: 50,\n  pointShape: \"circle\",\n  strokeWidth: 2,\n  color: \"steelblue\",\n  textColor: \"black\",\n  textAlign: \"left\",\n  textBaseline: \"middle\",\n  textMargin: 4,\n  font: \"Helvetica Neue\",\n  fontSize: \"12\",\n  fontWeight: \"normal\",\n  fontStyle: \"normal\",\n  opacity: 1,\n  _thickOpacity: 0.5,\n  _thinOpacity: 0.2,\n\n  // scales\n  // TODO remove _xZero, ...\n  _xZero: true,\n  _xReverse: false,\n  _yZero: true,\n  _yReverse: false,\n  timeScaleNice: \"day\",\n  timeScaleLabelLength: 3\n};","// TODO rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar data = module.exports = {};\n\ndata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config(\"useVegaServer\")) {\n    // don't use vega server\n    return encoding.config(\"dataUrl\");\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = []\n  encoding.forEach(function(encType, field){\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    }\n    if (field.aggr) {\n      obj.aggr = field.aggr\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name]).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config(\"vegaServerTable\"),\n    fields: fields\n  }\n\n  return encoding.config(\"vegaServerUrl\") + \"/query/?q=\" + JSON.stringify(query)\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\ndata.getSchema = function(data){\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k){\n    // find non-null data\n    var i=0, datum = data[i][k];\n    while(datum === \"\" || datum === null || datum === undefined){\n      datum = data[++i][k];\n    }\n\n    //TODO(kanitw): better type inference here\n    var type = (typeof datum === \"number\") ? \"Q\":\n      isNaN(Date.parse(datum)) ? \"O\" : \"T\";\n\n    schema.push({name: k, type: type});\n  });\n\n  return schema;\n};\n\ndata.getStats = function(data){ // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = util.minmax(data, k);\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n    stats[k] = stat;\n  });\n  return stats;\n};\n","// declare global constant\nvar g = global || window;\n\ng.TABLE = \"table\";\ng.STACKED = \"stacked\";\ng.INDEX = \"index\";\n\ng.X = \"x\";\ng.Y = \"y\";\ng.ROW = \"row\";\ng.COL = \"col\";\ng.SIZE = \"size\";\ng.SHAPE = \"shape\";\ng.COLOR = \"color\";\ng.ALPHA = \"alpha\";\ng.TEXT = \"text\";\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n//TODO refactor this to be config?\ng.MAX_BINS = 20;","var global = require('./globals');\n\nvar legends = module.exports = {};\n\nlegends.defs = function(encoding) {\n  var _legends = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    _legends.push(legends.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: \"right\"\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    _legends.push(legends.def(SIZE, encoding, {\n      size: SIZE,\n      orient: _legends.length === 1 ? \"left\" : \"right\"\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (_legends.length === 2) {\n      // TODO: fix this\n      console.error(\"Vegalite currently only supports two _legends\");\n      return _legends;\n    }\n    _legends.push(legends.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: _legends.length === 1 ? \"left\" : \"right\"\n    }));\n  }\n\n  return _legends;\n};\n\nlegends.def = function(name, encoding, props){\n  var _legend = props;\n\n  _legend.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T)) {\n    var fn = encoding.fn(name),\n      properties = _legend.properties = _legend.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    switch (fn) {\n      case \"day\":\n      case \"month\":\n        text.scale = \"time-\"+fn;\n        break;\n    }\n  }\n\n  return _legend;\n};","var globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar marks = module.exports = {};\n\nmarks.bar = {\n  type: \"rect\",\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.line = {\n  type: \"line\",\n  line: true,\n  prop: line_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, color:1, alpha:1}\n};\n\nmarks.area = {\n  type: \"area\",\n  stack: true,\n  line: true,\n  requiredEncoding: [\"x\", \"y\"],\n  prop: area_props,\n  supportedEncoding: marks.line.supportedEncoding\n};\n\nmarks.circle = {\n  type: \"symbol\",\n  prop: filled_point_props(\"circle\"),\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.square = {\n  type: \"symbol\",\n  prop: filled_point_props(\"square\"),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: \"symbol\",\n  prop: point_props,\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1, shape:1}\n};\n\nmarks.text = {\n  type: \"text\",\n  prop: text_props,\n  requiredEncoding: [\"text\"],\n  supportedEncoding: {row:1, col:1, size:1, color:1, alpha:1, text:1}\n};\n\nfunction bar_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T) && !e.bin(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.has(Y) && (!e.isType(Y,Q|T) || e.bin(Y))) {\n      p.x2 = {scale: X, value: 0};\n    }\n  } else if (e.has(X)) {\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T) && !e.bin(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    p.yc = {group: \"height\"};\n  }\n\n  // width\n  if (!e.isType(X,Q|T)) {\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.width = {scale: X, band: true, offset: -1};\n      p.width = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(Y,O) && !e.bin(Y)) {\n    p.width = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // height\n  if (!e.isType(Y,Q|T)) {\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.height = {scale: Y, band: true, offset: -1};\n      p.height = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(X,O) && !e.bin(X)) {\n    p.height = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, opt) {\n  var p = {};\n  opt = opt || {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.config(\"pointSize\")};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.config(\"pointShape\")};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }else{\n    p.opacity = {\n      value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n    };\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction line_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction area_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.isType(Y,Q|T) && e.has(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: \"horizontal\"};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, opt) {\n    var p = {};\n    opt = opt || {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.config(\"bandSize\")/2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.config(\"bandSize\")/2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.config(\"pointSize\")};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.config(\"color\")};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    }else {\n      p.opacity = {\n        value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n      };\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(X)) {\n    p.fontSize = {value: e.config(\"fontSize\")};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"textColor\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    p.text = {field: e.field(TEXT)};\n  } else {\n    p.text = {value: \"Abc\"};\n  }\n\n  p.font = {value: e.config(\"font\")};\n  p.fontWeight = {value: e.config(\"fontWeight\")};\n  p.fontStyle = {value: e.config(\"fontStyle\")};\n  p.baseline = {value: e.config(\"textBaseline\")};\n\n  // align\n  if (e.has(X)) {\n    if (e.isType(X,O)) {\n      p.align = {value: \"left\"};\n      p.dx = {value: e.config(\"textMargin\")};\n    } else {\n      p.align = {value: \"center\"}\n    }\n  } else if (e.has(Y)) {\n    p.align = {value: \"left\"};\n    p.dx = {value: e.config(\"textMargin\")};\n  } else {\n    p.align = {value: e.config(\"textAlign\")};\n  }\n\n  return p;\n}","var globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar scale = module.exports = {};\n\nscale.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function (names, encoding, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, opt)\n    };\n    if (s.type === \"ordinal\" && !encoding.bin(name)) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function (name, encoding) {\n  var fn;\n  switch (encoding.type(name)) {\n    case O: return \"ordinal\";\n    case T:\n      switch(encoding.fn(name)){\n        case \"second\":\n        case \"minute\":\n        case \"hour\":\n        case \"day\":\n        case \"date\":\n        case \"month\":\n          return \"ordinal\";\n        case \"year\":\n          return \"linear\";\n      }\n      return \"time\";\n    case Q:\n      if (encoding.bin(name)) {\n        return \"ordinal\";\n      }\n      return encoding.scale(name).type || \"linear\";\n  }\n};\n\nfunction scale_domain(name, encoding, opt) {\n  if (encoding.type(name) === T){\n    switch(encoding.fn(name)){\n      case \"second\":\n      case \"minute\":  return util.range(0, 60);\n      case \"hour\":    return util.range(0, 24);\n      case \"day\":     return util.range(0, 7);\n      case \"date\":    return util.range(0, 32);\n      case \"month\":   return util.range(0, 12);\n    }\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)]);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name===Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: \"data.\" + (opt.facet ? \"max_\" :\"\") + \"sum_\" + encoding.field(name, true)\n    }:\n    {data: TABLE, field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type===\"ordinal\") {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellWidth ? [0, opt.cellWidth] : \"width\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_xZero\");\n        s.reverse = spec.reverse || encoding.config(\"_xReverse\");\n      }\n      s.round = true;\n      if (s.type===\"time\"){\n        s.nice = encoding.fn(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type===\"ordinal\") {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellHeight ? [opt.cellHeight, 0] : \"height\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_yZero\");\n        s.reverse = spec.reverse || encoding.config(\"_yReverse\");\n      }\n\n      s.round = true;\n\n      if (s.type===\"time\"){\n        s.nice = encoding.fn(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = opt.cellHeight || encoding.config(\"cellHeight\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = opt.cellWidth || encoding.config(\"cellWidth\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is(\"bar\")) {\n        s.range = [3, +encoding.config(\"bandSize\")];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else {\n        s.range = [10, 1000];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = \"shapes\";\n      break;\n    case COLOR:\n      if (s.type === \"ordinal\") {\n        s.range = \"category10\";\n      } else {\n        s.range = [\"#ddf\", \"steelblue\"];\n        s.zero = false;\n      }\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error(\"Unknown encoding name: \"+s.name);\n  }\n\n  switch(s.name){\n    case ROW:\n    case COL:\n      s.padding = encoding.config(\"cellPadding\");\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === \"ordinal\") { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.config(\"bandPadding\");\n      }\n  }\n}","// Package of defining Vegalite Specification's json schema\n//\nvar schema = module.exports = {},\n  util = require('./util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: \"string\",\n  enum: [\"point\", \"bar\", \"line\", \"area\", \"circle\", \"square\", \"text\"]\n};\n\nschema.aggr = {\n  type: \"string\",\n  enum: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n  supportedEnums: {\n    Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n    O: [\"count\"],\n    T: [\"avg\", \"min\", \"max\", \"count\"],\n    \"\": [\"count\"],\n  },\n  supportedTypes: {\"Q\": true, \"O\": true, \"T\": true, \"\": true}\n};\n\nschema.timefns = [\"month\", \"year\", \"day\", \"date\", \"hour\", \"minute\", \"second\"];\n\nschema.fn = {\n  type: \"string\",\n  enum: schema.timefns,\n  supportedTypes: {\"T\": true}\n}\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: \"string\",\n  enum: [\"linear\", \"log\",\"pow\", \"sqrt\", \"quantile\"],\n  default: \"linear\",\n  supportedTypes: {\"Q\": true}\n};\n\nschema.field = {\n  type: \"object\",\n  required: [\"name\", \"type\"],\n  properties: {\n    name: {\n      type: \"string\"\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nvar typicalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\", \"Q\", \"T\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"Q\": true, \"O\": true}\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    scale: {\n      type: \"object\",\n      properties: {\n        type: schema.scale_type,\n        reverse: { type: \"boolean\", default: false },\n        zero: {\n          type: \"boolean\",\n          description: \"Include zero\",\n          default: false,\n          supportedTypes: {\"Q\": true}\n        },\n        nice: {\n          type: \"string\",\n          enum: [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"year\"],\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"O\": true}\n    },\n    aggr: {\n      type: \"string\",\n      enum: [\"count\"],\n      supportedTypes: {\"O\": true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: \"object\",\n  properties: {\n    axis: {\n      type: \"object\",\n      properties: {\n        grid: { type: \"boolean\", default: false },\n        title: { type: \"boolean\", default: true }\n      }\n    }\n  }\n}\n\nvar legendMixin = {\n  type: \"object\",\n  properties: {\n    legend: { type: \"boolean\", default: true }\n  }\n}\n\nvar textMixin = {\n  type: \"object\",\n  properties: {\n    text: {\n      type: \"object\",\n      properties: {\n        weight: {\n          type: \"string\",\n          enum: [\"normal\", \"bold\"],\n          default: \"normal\",\n          supportedTypes: {\"T\": true}\n        },\n        size: {\n          type: \"integer\",\n          default: 10,\n          minimum: 0,\n          supportedTypes: {\"T\": true}\n        },\n        font: {\n          type: \"string\",\n          default: \"Halvetica Neue\",\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n}\n\nvar x = merge(clone(typicalField), axisMixin);\nvar y = clone(x);\n\nvar row = clone(onlyOrdinalField);\nvar col = clone(row);\n\nvar size = merge(clone(typicalField), legendMixin);\nvar color = merge(clone(typicalField), legendMixin);\nvar alpha = clone(typicalField);\nvar shape = merge(clone(onlyOrdinalField), legendMixin);\n\nvar text = merge(clone(typicalField), textMixin);\n\nvar cfg = {\n  type: \"object\",\n  properties: {\n    // template\n    width: {\n      type: \"integer\",\n      default: undefined\n    },\n    height: {\n      type: \"integer\",\n      default: undefined\n    },\n    viewport: {\n      type: \"array\",\n      items: {\n        type: [\"integer\"]\n      },\n      default: undefined\n    },\n    _minWidth: {\n      type: \"integer\",\n      default: 20\n    },\n    _minHeight: {\n      type: \"integer\",\n      default: 20\n    },\n\n    // data source\n    dataFormatType: {\n      type: \"string\",\n      enum: [\"json\", \"csv\"],\n      default: \"json\"\n    },\n    useVegaServer: {\n      type: \"boolean\",\n      default: false\n    },\n    dataUrl: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerTable: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerUrl: {\n      type: \"string\",\n      default: \"http://localhost:3001\"\n    }\n  }\n}\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: \"http://json-schema.org/draft-04/schema#\",\n  type: \"object\",\n  required: [\"marktype\", \"enc\", \"cfg\"],\n  properties: {\n    marktype: schema.marktype,\n    enc: {\n      type: \"object\",\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text\n      }\n    },\n    cfg: cfg\n  }\n};\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function(){\n  return schema.util.instantiate(schema.schema);\n}\n","var util = module.exports = {};\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0\n}\n\n// instantiate a schema\nutil.instantiate = function(schema, required) {\n  if (schema.type === 'object') {\n    var requried = schema.required ? schema.required : [];\n    var instance = {};\n    for (var name in schema.properties) {\n      var child = schema.properties[name];\n      instance[name] = util.instantiate(child, requried.indexOf(name) != -1);\n    };\n    return instance;\n  } else if ('default' in schema) {\n    return schema.default;\n  } else if (schema.enum && required) {\n    return schema.enum[0];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nutil.difference = function(defaults, instance) {\n  var changes = {};\n  for (var prop in instance) {\n    if (!defaults || defaults[prop] !== instance[prop]) {\n      if (typeof instance[prop] == \"object\") {\n        var c = util.difference(defaults[prop], instance[prop]);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else {\n        changes[prop] = instance[prop];\n      }\n    }\n  }\n  return changes;\n};\n\n// recursively merges instance into defaults\nutil.merge = function (defaults, instance) {\n  if (typeof instance!=='object' || instance===null) {\n    return defaults;\n  }\n\n  for (var p in instance) {\n    if (!instance.hasOwnProperty(p))\n      continue;\n    if (instance[p]===undefined )\n      continue;\n    if (typeof instance[p] !== 'object' || instance[p] === null) {\n      defaults[p] = instance[p];\n    } else if (typeof defaults[p] !== 'object' || defaults[p] === null) {\n      defaults[p] = util.merge(instance[p].constructor === Array ? [] : {}, instance[p]);\n    } else {\n      util.merge(defaults[p], instance[p]);\n    }\n  }\n  return defaults;\n}\n","var globals = require('./globals'),\n  util = require('./util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt){\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(encType, field){\n    if(field.type === T && field.fn){\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[0],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function (field) {\n  var date = \"new Date(d.data.\"+field.name+\")\";\n  switch(field.fn){\n    case \"second\":  return date + \".getUTCSeconds()\";\n    case \"minute\":  return date + \".getUTCMinutes()\";\n    case \"hour\":    return date + \".getUTCHours()\";\n    case \"day\":     return date + \".getUTCDay()\";\n    case \"date\":    return date + \".getUTCDate()\";\n    case \"month\":   return date + \".getUTCMonth()\";\n    case \"year\":    return date + \".getUTCFullYear()\";\n  }\n  // TODO add continuous binning\n  console.error(\"no function specified for date\");\n};\n\n/** add formula transforms to data */\ntime.transform = function (transform, encoding, encType, field) {\n  transform.push({\n    type: \"formula\",\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\ntime.scale = function (scales, fn, encoding) {\n  var labelLength = encoding.config(\"timeScaleLabelLength\");\n  // TODO add option for shorter scale / custom range\n  switch(fn){\n    case \"day\":\n      scales.push({\n        name: \"time-day\",\n        type: \"ordinal\",\n        domain: util.range(0,7),\n        range: [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"].map(\n          function(s){ return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case \"month\":\n      scales.push({\n        name: \"time-month\",\n        type: \"ordinal\",\n        domain: util.range(0,12),\n        range: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"].map(\n            function(s){ return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n","var util = module.exports = {};\n\nutil.keys = function (obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n}\n\nutil.vals = function (obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n}\n\nutil.range = function (start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n}\n\nutil.find = function (list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n}\n\nutil.uniq = function (data, field) {\n  var map = {}, count = 0, i, k;\n  for (i=0; i<data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n}\n\nutil.minmax = function (data, field) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (i=0; i<data.length; ++i) {\n    var v = data[i][field];\n    if (v > stats.max) stats.max = v;\n    if (v < stats.min) stats.min = v;\n  }\n  return stats;\n}\n\nutil.duplicate = function (obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.any = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(f(arr[k], k, i++)) return true;\n  }\n  return false;\n}\n\nutil.all = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(!f(arr[k], k, i++)) return false;\n  }\n  return true;\n}\n\nutil.merge = function(dest, src){\n  return util.keys(src).reduce(function(c, k){\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.getbins = function (stats) {\n  return vg.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: MAX_BINS\n  });\n}\n\n\nutil.error = function(msg){\n  console.error(\"[VL Error]\", msg);\n}\n\n"],"sourceRoot":"/source/"}