{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vegalite.js","src/Encoding.js","src/axis.js","src/compile.js","src/consts.js","src/data.js","src/globals.js","src/legends.js","src/marks.js","src/scale.js","src/schema.js","src/schemautil.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","merge","schema","Encoding","axis","compile","data","legends","marks","scale","./Encoding","./axis","./compile","./consts","./data","./globals","./legends","./marks","./scale","./schema","./util",2,"marktype","enc","config","encDefaults","instantiate","properties","cfgDefaults","cfg","k","DEFAULTS","this","_marktype","_enc","_cfg","proto","prototype","is","m","has","x","undefined","field","nodata","nofn","aggr","bin","name","fn","fieldName","fieldTitle","legend","any","all","keys","reduce","init","forEach","type","isType","xt","toSpec","excludeConfig","spec","duplicate","dataTypeNames","toShorthand","map","v","join","parseShorthand","shorthand","split","shift","enctype","dataTypes","indexOf","substr","timefns","fromSpec","extraCfg",3,"axis_def","encoding","opt","isCol","COL","isRow","ROW","ticks","grid","layer","title","axis_title","opacity","value","majorTicks","offset","xAxisMargin","orient","O","labels","angle","align","baseline","Y","titleOffset","names","props","X","defs","push",4,"getCardinality","encType","stats","bins","getbins","stop","start","step","cardinality","setSize","hasRow","hasCol","hasX","hasY","colCardinality","rowCardinality","cellWidth","cellHeight","cellPadding","bandPadding","width","height","xCardinality","yCardinality","facet","group","mdef","stack","enter","facetKeys","cellAxes","fill","from","transform","error","y","unshift","axesGrp","groupdef","axes","apply","scales","concat","update","trans","subfacet","details","g","COLOR","by","getTimeFn","console","timeTransform","func","expr","binning","vv","d","preaggregatedData","output","maxbins","MAX_BINS","aggregates","dims","meas","detail","facets","op","vals","groupby","fields","TEXT","aggregated","stacking","dim","val","idx","Q","T","stacked","STACKED","source","TABLE","point","y1","y0","markdef","mark","p","prop","_name","template","size","format","dataUrl","getUrl","url","parse","padding","hasAgg","hasAggregate","lineType","line","aggResult","hasDetails",5,"encodingTypes","SIZE","SHAPE","ALPHA","cellBackgroundColor","yAxisMargin","textCellWidth","bandSize","pointSize","pointShape","strokeWidth","color","textColor","textAlign","textBaseline","textMargin","font","fontSize","fontWeight","fontStyle","_thickOpacity","_thinOpacity","_xZero","_xReverse","_yZero","_yReverse","timeScaleNice",6,"obj","binSize","query","table","JSON","stringify","getSchema","datum","isNaN","Date","getStats","stat","minmax","uniq","count",7,"INDEX",8,"shape",9,"bar_props","x2","xc","y2","yc","point_props","stroke","line_props","area_props","filled_point_props","text_props","text","dx","bar","requiredEncoding","supportedEncoding","row","col","alpha","area","circle","square",10,"scale_type","scale_domain","domain","range","reverse","scale_range","bandWidth","zero","round","nice","outerPadding","points","sort",11,"enum","supportedEnums","supportedTypes","default","required","clone","typicalField","description","onlyOrdinalField","axisMixin","legendMixin","textMixin","weight","minimum","viewport","items","_minWidth","_minHeight","dataFormatType","useVegaServer","vegaServerTable","vegaServerUrl","$schema","./schemautil",12,"isEmpty","Object","instance","child","difference","defaults","changes","c","hasOwnProperty","constructor","Array",13,"arguments","Infinity","j","find","list","pattern","filter","min","max","arr","dest","src","vg","msg"],"mappings":"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","file":"vegalite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var globals = require(\"./globals\"),\n    util = require(\"./util\"),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.schema = require('./schema');\nvl.Encoding = require('./Encoding');\nvl.axis = require('./axis');\nvl.compile = require('./compile');\nvl.data = require('./data');\nvl.legends = require('./legends');\nvl.marks = require('./marks')\nvl.scale = require('./scale');\n\nmodule.exports = vl;\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar globals = require(\"./globals\"),\n    util = require(\"./util\"),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.schema = require('./schema');\nvl.Encoding = require('./Encoding');\nvl.axis = require('./axis');\nvl.compile = require('./compile');\nvl.data = require('./data');\nvl.legends = require('./legends');\nvl.marks = require('./marks')\nvl.scale = require('./scale');\n\nmodule.exports = vl;\n\n},{\"./Encoding\":2,\"./axis\":3,\"./compile\":4,\"./consts\":5,\"./data\":6,\"./globals\":7,\"./legends\":8,\"./marks\":9,\"./scale\":10,\"./schema\":11,\"./util\":13}],2:[function(require,module,exports){\n\"use strict\";\n\nvar global = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  schema = require('./schema');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config) {\n    // TODO: caching\n    var encDefaults = schema.util.instantiate(schema.schema.properties.enc);\n    var cfgDefaults = schema.util.instantiate(schema.schema.properties.cfg);\n\n    // Hack\n    for (var k in consts.DEFAULTS) {\n      cfgDefaults[k] = consts.DEFAULTS[k];\n    }\n\n    // remove field defs that we don't use in encoding\n    for (var k in encDefaults) {\n      if (!enc[k]) {\n        delete encDefaults[k];\n      }\n    }\n\n    this._marktype = marktype;\n    this._enc = schema.util.merge(encDefaults, enc);\n    this._cfg = schema.util.merge(cfgDefaults, config);\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(x) {\n    return this._enc[x] !== undefined;\n  };\n\n  proto.enc = function(x){\n    return this._enc[x];\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(x, nodata, nofn) {\n    if (!this.has(x)) return null;\n\n    var f = (nodata ? \"\" : \"data.\");\n\n    if (this._enc[x].aggr === \"count\") {\n      return f + \"count\";\n    } else if (!nofn && this._enc[x].bin) {\n      return f + \"bin_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].aggr) {\n      return f + this._enc[x].aggr + \"_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].fn){\n      return f + this._enc[x].fn + \"_\" + this._enc[x].name;\n    } else {\n      return f + this._enc[x].name;\n    }\n  };\n\n  proto.fieldName = function(x){\n    return this._enc[x].name;\n  }\n\n  proto.fieldTitle = function(x){\n    if (this._enc[x].aggr) {\n      return this._enc[x].aggr + \"(\" + this._enc[x].name + \")\";\n    } else {\n      return this._enc[x].name;\n    }\n  }\n\n  proto.scale = function(x){\n    return this._enc[x].scale || {};\n  }\n\n  proto.axis = function(x){\n    return this._enc[x].axis || {};\n  }\n\n  proto.aggr = function(x){\n    return this._enc[x].aggr;\n  }\n\n  proto.bin = function(x){\n    return this._enc[x].bin;\n  }\n\n  proto.legend = function(x){\n    return this._enc[x].legend;\n  }\n\n  proto.fn = function(x){\n    return this._enc[x].fn;\n  }\n\n  proto.any = function(f){\n    return util.any(this._enc, f);\n  }\n\n  proto.all = function(f){\n    return util.all(this._enc, f);\n  }\n\n  proto.length = function(){\n    return util.keys(this._enc).length;\n  }\n\n  proto.reduce = function(f, init){\n    var r = init, i=0;\n    for (k in this._enc){\n      r = f(r, this._enc[k], k, this._enc);\n    }\n    return r;\n  }\n\n  proto.forEach = function(f) {\n    var i=0, k;\n    for (k in this._enc) {\n      f(k, this._enc[k], i++);\n    }\n  };\n\n  proto.type = function(x) {\n    return this.has(x) ? this._enc[x].type : null;\n  };\n\n  proto.isType = function(x, t) {\n    var xt = this.type(x);\n    if (xt == null) return false;\n    return (xt & t) > 0;\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig){\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for(var e in enc){\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc\n    }\n\n    if(!excludeConfig){\n      spec.cfg = util.duplicate(this._cfg)\n    }\n\n    return spec;\n  };\n\n  proto.toShorthand = function(){\n    var enc = this._enc;\n    return this._marktype + \".\" + util.keys(enc).map(function(e){\n      var v = enc[e];\n        return e + \"-\" +\n          (v.aggr ? v.aggr+\"_\" : \"\") +\n          (v.fn ? v.fn+\"_\" : \"\") +\n          (v.bin ? \"bin_\" : \"\") +\n          (v.name || \"\") + \"-\" +\n          consts.dataTypeNames[v.type];\n      }\n    ).join(\".\");\n  }\n\n  Encoding.parseShorthand = function(shorthand, cfg){\n    var enc = shorthand.split(\".\"),\n      marktype = enc.shift();\n\n    enc = enc.reduce(function(m, e){\n      var split = e.split(\"-\"),\n        enctype = split[0],\n        o = {name: split[1], type: consts.dataTypes[split[2]]};\n\n      // check aggregate type\n      for(var i in schema.aggr.enum){\n        var a = schema.aggr.enum[i];\n        if(o.name.indexOf(a+\"_\") == 0){\n          o.name = o.name.substr(a.length+1);\n          if (a==\"count\" && o.name.length === 0) o.name = \"*\";\n          o.aggr = a;\n          break;\n        }\n      }\n      // check time fn\n      for(var i in schema.timefns){\n        var f = schema.timefns[i];\n        if(o.name && o.name.indexOf(f+\"_\") == 0){\n          o.name = o.name.substr(o.length+1);\n          o.fn = f;\n          break;\n        }\n      }\n\n      // check bin\n      if(o.name && o.name.indexOf(\"bin_\") == 0){\n        o.name = o.name.substr(4);\n        o.bin = true;\n      }\n\n      m[enctype] = o;\n      return m;\n    }, {});\n\n    return new Encoding(marktype, enc, cfg);\n  }\n\n  Encoding.fromSpec = function(spec, extraCfg) {\n    var enc = util.duplicate(spec.enc);\n\n    //convert type from string to bitcode (e.g, O=1)\n    for(var e in enc){\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, util.merge(spec.cfg, extraCfg || {}));\n  }\n\n  return Encoding;\n\n})();\n\n},{\"./consts\":5,\"./globals\":7,\"./schema\":11,\"./util\":13}],3:[function(require,module,exports){\nvar globals = require('./globals'),\n  util = require('./util');\n\nvar axis = module.exports = {};\n\naxis.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s===X || s===Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\naxis.defs = function(names, encoding, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis_def(name, encoding, opt));\n    return a;\n  }, []);\n}\n\nfunction axis_def(name, encoding, opt){\n  var type = name, axis;\n  var isCol = name==COL, isRow = name==ROW;\n  if(isCol) type = \"x\";\n  if(isRow) type = \"y\";\n\n  var axis = {\n    type: type,\n    scale: name,\n    ticks: 3 //TODO(kanitw): better determine # of ticks\n  };\n\n  if (encoding.axis(name).grid) {\n    axis.grid = true;\n    axis.layer = \"back\";\n  }\n\n  if (encoding.axis(name).title) {\n    //show title by default\n\n    axis = axis_title(axis, name, encoding, opt);\n  }\n\n  if(isRow || isCol){\n    axis.properties = {\n      ticks: { opacity: {value: 0} },\n      majorTicks: { opacity: {value: 0} },\n      axis: { opacity: {value: 0} }\n    };\n  }\n  if(isCol){\n    axis.offset = [opt.xAxisMargin || 0, encoding.config(\"yAxisMargin\")];\n    axis.orient = \"top\";\n  }\n\n  if (name==\"x\" && (encoding.isType(name, O) || encoding.bin(name))) {\n    axis.properties = {\n      labels: {\n        angle: {value: 270},\n        align: {value: \"right\"},\n        baseline: {value: \"middle\"}\n      }\n    }\n  }\n\n  return axis;\n}\n\nfunction axis_title(axis, name, encoding, opt){\n  axis.title = encoding.fieldTitle(name);\n  if(name==Y){\n    axis.titleOffset = 60;\n    // TODO: set appropriate titleOffset\n    // maybe based on some string length from stats\n  }\n  return axis;\n}\n\n},{\"./globals\":7,\"./util\":13}],4:[function(require,module,exports){\nvar globals = require('./globals'),\n  util = require('./util'),\n  axis = require('./axis'),\n  legends = require('./legends'),\n  marks = require('./marks'),\n  scale = require('./scale');\n\nvar compile = module.exports = function(encoding, stats) {\n  var size = setSize(encoding, stats),\n    cellWidth = size.cellWidth,\n    cellHeight = size.cellHeight;\n\n  var hasAgg = encoding.any(function(v, k){\n    return v.aggr !== undefined;\n  });\n\n  var spec = template(encoding, size, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdef = markdef(mark, encoding, {\n      hasAggregate: hasAgg\n    });\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  group.marks.push(mdef);\n  // TODO: return value not used\n  binning(spec.data[0], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if(!preaggregatedData){\n    encoding.forEach(function(encType, field){\n      if(field.type === T && field.fn){\n        timeTransform(spec.data[0], encoding, encType, field);\n      }\n    });\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec.data[0], encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isType(X, Q | T) && encoding.isType(Y, O)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    mdef.from.transform = [{type: \"sort\", by: encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding);\n    group.legends = legends.defs(encoding);\n  }\n  return spec;\n};\n\nfunction getCardinality(encoding, encType, stats){\n  var field = encoding.fieldName(encType);\n  if (encoding.bin(encType)) {\n    var bins = util.getbins(stats[field]);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  return stats[field].cardinality;\n}\n\nfunction setSize(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y);\n\n  // HACK to set chart size\n  // NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  // One solution is to update Vega to support auto-sizing\n  // In the meantime, auto-padding (mostly) does the trick\n  //\n  var colCardinality = hasCol ? getCardinality(encoding, COL, stats) : 1,\n    rowCardinality = hasRow ? getCardinality(encoding, ROW, stats) : 1;\n\n  var cellWidth = hasX ?\n      +encoding.config(\"cellWidth\") || encoding.config(\"width\") * 1.0 / colCardinality :\n      encoding.marktype() === \"text\" ?\n        +encoding.config(\"textCellWidth\") :\n        +encoding.config(\"bandSize\"),\n    cellHeight = hasY ?\n      +encoding.config(\"cellHeight\") || encoding.config(\"height\") * 1.0 / rowCardinality :\n      +encoding.config(\"bandSize\"),\n    cellPadding = encoding.config(\"cellPadding\"),\n    bandPadding = encoding.config(\"bandPadding\"),\n    width = encoding.config(\"_minWidth\"),\n    height = encoding.config(\"_minHeight\");\n\n  if (hasX && (encoding.isType(X, O) || encoding.bin(X))) { //ordinal field will override parent\n    // bands within cell use rangePoints()\n    var xCardinality = getCardinality(encoding, X, stats);\n    cellWidth = (xCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  width = cellWidth * ((1 + cellPadding) * (colCardinality-1) + 1);\n\n  if (hasY && (encoding.isType(Y, O) || encoding.bin(Y))) {\n    // bands within cell use rangePoint()\n    var yCardinality = getCardinality(encoding, Y, stats);\n    cellHeight = (yCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  height = cellHeight * ((1 + cellPadding) * (rowCardinality-1) + 1);\n\n  return {\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    width: width,\n    height:height\n  };\n}\n\nfunction facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats) {\n    var enter = group.properties.enter;\n    var facetKeys = [], cellAxes = [];\n\n    var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n    var xAxisMargin = encoding.has(Y) ? encoding.config(\"xAxisMargin\") : undefined;\n\n    enter.fill = {value: encoding.config(\"cellBackgroundColor\")};\n\n    //move \"from\" to cell level and add facet transform\n    group.from = {data: group.marks[0].from.data};\n\n    if (group.marks[0].from.transform) {\n      delete group.marks[0].from.data; //need to keep transform for subfacetting case\n    } else {\n      delete group.marks[0].from;\n    }\n    if (hasRow) {\n      if (!encoding.isType(ROW, O)) {\n        util.error(\"Row encoding should be ordinal.\");\n      }\n      enter.y = {scale: ROW, field: \"keys.\" + facetKeys.length};\n      enter.height = {\"value\": cellHeight}; // HACK\n\n      facetKeys.push(encoding.field(ROW));\n\n      var from;\n      if (hasCol) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(COL)]});\n      }\n\n      var axesGrp = groupdef(\"x-axes\", {\n          axes: encoding.has(X) ?  axis.defs([\"x\"], encoding) : undefined,\n          x: hasCol ? {scale: COL, field: \"keys.0\", offset: xAxisMargin} : {value: xAxisMargin},\n          width: hasCol && {\"value\": cellWidth}, //HACK?\n          from: from\n        });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || []);\n      spec.axes.push.apply(spec.axes, axis.defs([\"row\"], encoding));\n    } else { // doesn't have row\n      if(encoding.has(X)){\n        //keep x axis in the cell\n        cellAxes.push.apply(cellAxes, axis.defs([\"x\"], encoding));\n      }\n    }\n\n    if (hasCol) {\n      if (!encoding.isType(COL, O)) {\n        util.error(\"Col encoding should be ordinal.\");\n      }\n      enter.x = {scale: COL, field: \"keys.\" + facetKeys.length};\n      enter.width = {\"value\": cellWidth}; // HACK\n\n      facetKeys.push(encoding.field(COL));\n\n      var from;\n      if (hasRow) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(ROW)]});\n      }\n\n      var axesGrp = groupdef(\"y-axes\", {\n        axes: encoding.has(Y) ? axis.defs([\"y\"], encoding) : undefined,\n        y: hasRow && {scale: ROW, field: \"keys.0\"},\n        x: hasRow && {value: xAxisMargin},\n        height: hasRow && {\"value\": cellHeight}, //HACK?\n        from: from\n      });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || [])\n      spec.axes.push.apply(spec.axes, axis.defs([\"col\"], encoding, {\n        xAxisMargin: xAxisMargin\n      }));\n    } else { // doesn't have col\n      if(encoding.has(Y)){\n        cellAxes.push.apply(cellAxes, axis.defs([\"y\"], encoding));\n      }\n    }\n\n    if(hasRow){\n      if(enter.x) enter.x.offset= xAxisMargin;\n      else enter.x = {value: xAxisMargin};\n    }\n    if(hasCol){\n      //TODO fill here..\n    }\n\n    // assuming equal cellWidth here\n    // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n    spec.scales = (spec.scales ||[]).concat(scale.defs(\n      scale.names(enter).concat(scale.names(mdef.properties.update)),\n      encoding,\n      {cellWidth: cellWidth, cellHeight: cellHeight, stack: stack, facet:true, stats: stats}\n    )); // row/col scales + cell scales\n\n    if (cellAxes.length > 0) {\n      group.axes = cellAxes;\n    }\n\n    // add facet transform\n    var trans = (group.from.transform || (group.from.transform = []));\n    trans.unshift({type: \"facet\", keys: facetKeys});\n\n  return spec;\n  }\n\nfunction subfacet(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef(\"subfacet\", {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: \"facet\", keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: \"sort\", by: encoding.field(COLOR)});\n  }\n}\n\nfunction getTimeFn(fn){\n  switch(fn){\n    case \"second\": return \"getUTCSeconds\";\n    case \"minute\": return \"getUTCMinutes\";\n    case \"hour\": return \"getUTCHours\";\n    case \"day\": return \"getUTCDay\";\n    case \"date\": return \"getUTCDate\";\n    case \"month\": return \"getUTCMonth\";\n    case \"year\": return \"getUTCFullYear\";\n  }\n  console.error(\"no function specified for date\");\n}\n\nfunction timeTransform(spec, encoding, encType, field){\n  var func = getTimeFn(field.fn);\n\n  spec.transform = spec.transform || [];\n  spec.transform.push({\n    type: \"formula\",\n    field: encoding.field(encType),\n    expr: \"new Date(d.data.\"+field.name+\").\"+func+\"()\"\n  });\n  return spec;\n}\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n  encoding.forEach(function(vv, d) {\n    if (d.bin) bins[d.name] = d.name;\n  });\n  bins = util.keys(bins);\n\n  if (bins.length === 0 || opt.preaggregatedData) return false;\n\n  if (!spec.transform) spec.transform = [];\n  bins.forEach(function(d) {\n    spec.transform.push({\n      type: \"bin\",\n      field: \"data.\" + d,\n      output: \"data.bin_\" + d,\n      maxbins: MAX_BINS\n    });\n  });\n  return bins;\n}\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n  var dims = {}, meas = {}, detail = {}, facets={};\n  encoding.forEach(function(encType, field) {\n    if (field.aggr) {\n      if(field.aggr===\"count\"){\n        meas[\"count\"] = {op:\"count\", field:\"*\"};\n      }else{\n        meas[field.aggr+\"|\"+field.name] = {\n          op:field.aggr,\n          field:\"data.\"+field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType==ROW || encType == COL){\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!spec.transform) spec.transform = [];\n    spec.transform.push({\n      type: \"aggregate\",\n      groupby: dims,\n      fields: meas\n    });\n\n    if (encoding.marktype() === TEXT) {\n      meas.forEach( function (m) {\n        var fieldName = m.field.substr(5), //remove \"data.\"\n          field = \"data.\" + (m.op ? m.op + \"_\" : \"\") + fieldName;\n        spec.transform.push({\n          type: \"formula\",\n          field: field,\n          expr: \"d3.format('.2f')(d.\"+field+\")\"\n        });\n      });\n    }\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  }\n}\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n  if (!encoding.has(COLOR)) return false;\n\n  var dim = X, val = Y, idx = 1;\n  if (encoding.isType(X,Q|T) && !encoding.isType(Y,Q|T) && encoding.has(Y)) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: \"aggregate\",\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: \"sum\", field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if(facets && facets.length > 0){\n    stacked.transform.push({ //calculate max for each facet\n      type: \"aggregate\",\n      groupby: facets,\n      fields: [{op: \"max\", field: \"data.sum_\" + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: \"stack\",\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val+\"2\"}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val+\"2\"] = mdef.properties.enter[val+\"2\"] = {scale: val, field: val+\"2\"};\n\n  return val; //return stack encoding\n}\n\n\nfunction markdef(mark, encoding, opt) {\n  var p = mark.prop(encoding, opt)\n  return {\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  };\n}\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: \"group\",\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: \"width\"},\n        height: opt.height || {group: \"height\"}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction template(encoding, size, stats) { //hack use stats\n\n  var data = {name:TABLE, format: {type: encoding.config(\"dataFormatType\")}},\n    dataUrl = vl.data.getUrl(encoding, stats);\n  if(dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  encoding.forEach(function(encType, field){\n    if(field.type == T){\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = \"date\";\n    }else if(field.type == Q){\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === \"count\") {\n        var name = \"count\";\n      } else if(preaggregatedData && field.bin){\n        var name = \"bin_\" + field.name;\n      } else if(preaggregatedData && field.aggr){\n        var name = field.aggr + \"_\" + field.name;\n      } else{\n        var name = field.name;\n      }\n      data.format.parse[name] = \"number\";\n    }\n  });\n\n  return {\n    width: size.width,\n    height: size.height,\n    padding: \"auto\",\n    data: [data],\n    marks: [groupdef(\"cell\", {\n      width: size.cellWidth ? {value: size.cellWidth}: undefined,\n      height: size.cellHeight ? {value: size.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"./axis\":3,\"./globals\":7,\"./legends\":8,\"./marks\":9,\"./scale\":10,\"./util\":13}],5:[function(require,module,exports){\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT];\n\nconsts.dataTypes = {\"O\": O, \"Q\": Q, \"T\": T};\n\nconsts.dataTypeNames = [\"O\",\"Q\",\"T\"].reduce(function(r,x) {\n  r[consts.dataTypes[x]] = x; return r;\n},{});\n\nconsts.DEFAULTS = {\n  //small multiples\n  cellHeight: 200, // will be overwritten by bandWidth\n  cellWidth: 200, // will be overwritten by bandWidth\n  cellPadding: 0.1,\n  cellBackgroundColor: \"#fdfdfd\",\n  xAxisMargin: 80,\n  yAxisMargin: 0,\n  textCellWidth: 90,\n\n  // marks\n  bandSize: 21,\n  bandPadding: 1,\n  pointSize: 50,\n  pointShape: \"circle\",\n  strokeWidth: 2,\n  color: \"steelblue\",\n  textColor: \"black\",\n  textAlign: \"left\",\n  textBaseline: \"middle\",\n  textMargin: 4,\n  font: \"Helvetica Neue\",\n  fontSize: \"12\",\n  fontWeight: \"normal\",\n  fontStyle: \"normal\",\n  opacity: 1,\n  _thickOpacity: 0.5,\n  _thinOpacity: 0.2,\n\n  // scales\n  // TODO remove _xZero, ...\n  _xZero: true,\n  _xReverse: false,\n  _yZero: true,\n  _yReverse: false,\n  timeScaleNice: \"day\"\n};\n},{\"./globals\":7}],6:[function(require,module,exports){\n// TODO rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar data = module.exports = {};\n\ndata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config(\"useVegaServer\")) {\n    // don't use vega server\n    return encoding.config(\"dataUrl\");\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = []\n  encoding.forEach(function(encType, field){\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    }\n    if (field.aggr) {\n      obj.aggr = field.aggr\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name]).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config(\"vegaServerTable\"),\n    fields: fields\n  }\n\n  return encoding.config(\"vegaServerUrl\") + \"/query/?q=\" + JSON.stringify(query)\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\ndata.getSchema = function(data){\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k){\n    // find non-null data\n    var i=0, datum = data[i][k];\n    while(datum === \"\" || datum === null || datum === undefined){\n      datum = data[++i][k];\n    }\n\n    //TODO(kanitw): better type inference here\n    var type = (typeof datum === \"number\") ? \"Q\":\n      isNaN(Date.parse(datum)) ? \"O\" : \"T\";\n\n    schema.push({name: k, type: type});\n  });\n\n  return schema;\n};\n\ndata.getStats = function(data){ // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = util.minmax(data, k);\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n    stats[k] = stat;\n  });\n  return stats;\n};\n\n},{\"./util\":13}],7:[function(require,module,exports){\n(function (global){\n// declare global constant\nvar g = global || window;\n\ng.TABLE = \"table\";\ng.STACKED = \"stacked\";\ng.INDEX = \"index\";\n\ng.X = \"x\";\ng.Y = \"y\";\ng.ROW = \"row\";\ng.COL = \"col\";\ng.SIZE = \"size\";\ng.SHAPE = \"shape\";\ng.COLOR = \"color\";\ng.ALPHA = \"alpha\";\ng.TEXT = \"text\";\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n//TODO refactor this to be config?\ng.MAX_BINS = 20;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],8:[function(require,module,exports){\nvar global = require('./globals');\n\nvar legends = module.exports = {};\n\nlegends.defs = function(encoding) {\n  var legends = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    legends.push({\n      fill: COLOR,\n      title: encoding.fieldTitle(COLOR),\n      orient: \"right\"\n    });\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    legends.push({\n      size: SIZE,\n      title: encoding.fieldTitle(SIZE),\n      orient: legends.length === 1 ? \"left\" : \"right\"\n    });\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (legends.length === 2) {\n      // TODO: fix this\n      console.error(\"Vegalite currently only supports two legends\");\n      return legends;\n    }\n    legends.push({\n      shape: SHAPE,\n      title: encoding.fieldTitle(SHAPE),\n      orient: legends.length === 1 ? \"left\" : \"right\"\n    });\n  }\n\n  return legends;\n}\n},{\"./globals\":7}],9:[function(require,module,exports){\nvar globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar marks = module.exports = {};\n\nmarks.bar = {\n  type: \"rect\",\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.line = {\n  type: \"line\",\n  line: true,\n  prop: line_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, color:1, alpha:1}\n};\n\nmarks.area = {\n  type: \"area\",\n  stack: true,\n  line: true,\n  requiredEncoding: [\"x\", \"y\"],\n  prop: area_props,\n  supportedEncoding: marks.line.supportedEncoding\n};\n\nmarks.circle = {\n  type: \"symbol\",\n  prop: filled_point_props(\"circle\"),\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.square = {\n  type: \"symbol\",\n  prop: filled_point_props(\"square\"),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: \"symbol\",\n  prop: point_props,\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1, shape:1}\n};\n\nmarks.text = {\n  type: \"text\",\n  prop: text_props,\n  requiredEncoding: [\"text\"],\n  supportedEncoding: {row:1, col:1, size:1, color:1, alpha:1, text:1}\n};\n\nfunction bar_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T) && !e.bin(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.has(Y) && (!e.isType(Y,Q|T) || e.bin(Y))) {\n      p.x2 = {scale: X, value: 0};\n    }\n  } else if (e.has(X)) {\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T) && !e.bin(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    p.yc = {group: \"height\"};\n  }\n\n  // width\n  if (!e.isType(X,Q|T)) {\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.width = {scale: X, band: true, offset: -1};\n      p.width = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(Y,O) && !e.bin(Y)) {\n    p.width = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // height\n  if (!e.isType(Y,Q|T)) {\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.height = {scale: Y, band: true, offset: -1};\n      p.height = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(X,O) && !e.bin(X)) {\n    p.height = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, opt) {\n  var p = {};\n  opt = opt || {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.config(\"pointSize\")};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.config(\"pointShape\")};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }else{\n    p.opacity = {\n      value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n    };\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction line_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction area_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.isType(Y,Q|T) && e.has(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: \"horizontal\"};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, opt) {\n    var p = {};\n    opt = opt || {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.config(\"bandSize\")/2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.config(\"bandSize\")/2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.config(\"pointSize\")};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.config(\"color\")};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    }else {\n      p.opacity = {\n        value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n      };\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(X)) {\n    p.fontSize = {value: e.config(\"fontSize\")};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"textColor\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    p.text = {field: e.field(TEXT)};\n  } else {\n    p.text = {value: \"Abc\"};\n  }\n\n  p.font = {value: e.config(\"font\")};\n  p.fontWeight = {value: e.config(\"fontWeight\")};\n  p.fontStyle = {value: e.config(\"fontStyle\")};\n  p.baseline = {value: e.config(\"textBaseline\")};\n\n  // align\n  if (e.has(X)) {\n    if (e.isType(X,O)) {\n      p.align = {value: \"left\"};\n      p.dx = {value: e.config(\"textMargin\")};\n    } else {\n      p.align = {value: \"center\"}\n    }\n  } else if (e.has(Y)) {\n    p.align = {value: \"left\"};\n    p.dx = {value: e.config(\"textMargin\")};\n  } else {\n    p.align = {value: e.config(\"textAlign\")};\n  }\n\n  return p;\n}\n},{\"./globals\":7,\"./util\":13}],10:[function(require,module,exports){\nvar globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar scale = module.exports = {};\n\nscale.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\nscale.defs = function (names, encoding, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale_type(name, encoding),\n      domain: scale_domain(name, encoding, opt)\n    };\n    if (s.type === \"ordinal\" && !encoding.bin(name)) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, opt);\n\n    return (a.push(s), a);\n  }, []);\n}\n\nfunction scale_type(name, encoding) {\n  switch (encoding.type(name)) {\n    case O: return \"ordinal\";\n    case T:\n      if (encoding.fn(name)) {\n        return \"linear\";\n      }\n      return \"time\";\n    case Q:\n      if (encoding.bin(name)) {\n        return \"ordinal\";\n      }\n      return encoding.scale(name).type || \"linear\";\n  }\n}\n\nfunction scale_domain(name, encoding, opt) {\n  if (encoding.type(name) === T){\n    switch(encoding.fn(name)){\n      case \"second\":\n      case \"minute\": return [0, 59];\n      case \"hour\": return [0, 23];\n      case \"day\": return [0, 6];\n      case \"date\": return [1, 31];\n      case \"month\": return [0, 11];\n    }\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)]);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name===Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: \"data.\" + (opt.facet ? \"max_\" :\"\") + \"sum_\" + encoding.field(name, true)\n    }:\n    {data: TABLE, field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellWidth ? [0, opt.cellWidth] : \"width\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_xZero\");\n        s.reverse = spec.reverse || encoding.config(\"_xReverse\");\n      }\n      s.round = true;\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellHeight ? [opt.cellHeight, 0] : \"height\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_yZero\");\n        s.reverse = spec.reverse || encoding.config(\"_yReverse\");\n      }\n\n      s.round = true;\n\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name);\n      }else{\n        s.nice = true;\n      }\n      break;\n    case ROW:\n      s.bandWidth = opt.cellHeight || encoding.config(\"cellHeight\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL:\n      s.bandWidth = opt.cellWidth || encoding.config(\"cellWidth\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is(\"bar\")) {\n        s.range = [3, +encoding.config(\"bandSize\")];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else {\n        s.range = [10, 1000];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = \"shapes\";\n      break;\n    case COLOR:\n      if (encoding.isType(s.name, O)) {\n        s.range = \"category10\";\n      } else {\n        s.range = [\"#ddf\", \"steelblue\"];\n        s.zero = false;\n      }\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error(\"Unknown encoding name: \"+s.name);\n  }\n\n  switch(s.name){\n    case ROW:\n    case COL:\n      s.padding = encoding.config(\"cellPadding\");\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name) ) { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.config(\"bandPadding\");\n      }\n  }\n}\n},{\"./globals\":7,\"./util\":13}],11:[function(require,module,exports){\n// Package of defining Vegalite Specification's json schema\n//\nvar schema = module.exports = {},\n  util = require('./util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: \"string\",\n  enum: [\"point\", \"bar\", \"line\", \"area\", \"circle\", \"square\", \"text\"]\n};\n\nschema.aggr = {\n  type: \"string\",\n  enum: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n  supportedEnums: {\n    Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n    O: [\"count\"],\n    T: [\"avg\", \"min\", \"max\", \"count\"],\n    \"\": [\"count\"],\n  },\n  supportedTypes: {\"Q\": true, \"O\": true, \"T\": true, \"\": true}\n};\n\nschema.timefns = [\"month\", \"year\", \"day\", \"date\", \"hour\", \"minute\", \"second\"];\n\nschema.fn = {\n  type: \"string\",\n  enum: schema.timefns,\n  supportedTypes: {\"T\": true}\n}\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: \"string\",\n  enum: [\"linear\", \"log\",\"pow\", \"sqrt\", \"quantile\"],\n  default: \"linear\",\n  supportedTypes: {\"Q\": true}\n};\n\nschema.field = {\n  type: \"object\",\n  required: [\"name\", \"type\"],\n  properties: {\n    name: {\n      type: \"string\"\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nvar typicalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\", \"Q\", \"T\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"Q\": true, \"O\": true}\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    scale: {\n      type: \"object\",\n      properties: {\n        type: schema.scale_type,\n        reverse: { type: \"boolean\", default: false },\n        zero: {\n          type: \"boolean\",\n          description: \"Include zero\",\n          default: false,\n          supportedTypes: {\"Q\": true}\n        },\n        nice: {\n          type: \"string\",\n          enum: [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"year\"],\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"O\": true}\n    },\n    aggr: {\n      type: \"string\",\n      enum: [\"count\"],\n      supportedTypes: {\"O\": true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: \"object\",\n  properties: {\n    axis: {\n      type: \"object\",\n      properties: {\n        grid: { type: \"boolean\", default: false },\n        title: { type: \"boolean\", default: true }\n      }\n    }\n  }\n}\n\nvar legendMixin = {\n  type: \"object\",\n  properties: {\n    legend: { type: \"boolean\", default: true }\n  }\n}\n\nvar textMixin = {\n  type: \"object\",\n  properties: {\n    text: {\n      type: \"object\",\n      properties: {\n        weight: {\n          type: \"string\",\n          enum: [\"normal\", \"bold\"],\n          default: \"normal\",\n          supportedTypes: {\"T\": true}\n        },\n        size: {\n          type: \"integer\",\n          default: 10,\n          minimum: 0,\n          supportedTypes: {\"T\": true}\n        },\n        font: {\n          type: \"string\",\n          default: \"Halvetica Neue\",\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n}\n\nvar x = merge(clone(typicalField), axisMixin);\nvar y = clone(x);\n\nvar row = clone(onlyOrdinalField);\nvar col = clone(row);\n\nvar size = merge(clone(typicalField), legendMixin);\nvar color = merge(clone(typicalField), legendMixin);\nvar alpha = clone(typicalField);\nvar shape = merge(clone(onlyOrdinalField), legendMixin);\n\nvar text = merge(clone(typicalField), textMixin);\n\nvar cfg = {\n  type: \"object\",\n  properties: {\n    // template\n    width: {\n      type: \"integer\",\n      default: undefined\n    },\n    height: {\n      type: \"integer\",\n      default: undefined\n    },\n    viewport: {\n      type: \"array\",\n      items: {\n        type: [\"integer\"]\n      },\n      default: undefined\n    },\n    _minWidth: {\n      type: \"integer\",\n      default: 20\n    },\n    _minHeight: {\n      type: \"integer\",\n      default: 20\n    },\n\n    // data source\n    dataFormatType: {\n      type: \"string\",\n      enum: [\"json\", \"csv\"],\n      default: \"json\"\n    },\n    useVegaServer: {\n      type: \"boolean\",\n      default: false\n    },\n    dataUrl: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerTable: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerUrl: {\n      type: \"string\",\n      default: \"http://localhost:3001\"\n    }\n  }\n}\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: \"http://json-schema.org/draft-04/schema#\",\n  type: \"object\",\n  required: [\"marktype\", \"enc\", \"cfg\"],\n  properties: {\n    marktype: schema.marktype,\n    enc: {\n      type: \"object\",\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text\n      }\n    },\n    cfg: cfg\n  }\n};\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function(){\n  return schema.util.instantiate(schema.schema);\n}\n\n},{\"./schemautil\":12,\"./util\":13}],12:[function(require,module,exports){\nvar util = module.exports = {};\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0\n}\n\n// instantiate a schema\nutil.instantiate = function(schema, required) {\n  if (schema.type === 'object') {\n    schema.required = schema.required ? schema.required : [];\n    var instance = {};\n    for (var name in schema.properties) {\n      var child = schema.properties[name];\n      instance[name] = util.instantiate(child, schema.required.indexOf(name) != -1);\n    };\n    return instance;\n  } else if ('default' in schema) {\n    return schema.default;\n  } else if (schema.enum && required) {\n    return schema.enum[0];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nutil.difference = function(defaults, instance) {\n  var changes = {};\n  for (var prop in instance) {\n    if (!defaults || defaults[prop] !== instance[prop]) {\n      if (typeof instance[prop] == \"object\") {\n        var c = util.difference(defaults[prop], instance[prop]);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else {\n        changes[prop] = instance[prop];\n      }\n    }\n  }\n  return changes;\n};\n\n// recursively merges instance into defaults\nutil.merge = function (defaults, instance) {\n  if (typeof instance!=='object' || instance===null) {\n    return defaults;\n  }\n\n  for (var p in instance) {\n    if (!instance.hasOwnProperty(p))\n      continue;\n    if (instance[p]===undefined )\n      continue;\n    if (typeof instance[p] !== 'object' || instance[p] === null) {\n      defaults[p] = instance[p];\n    } else if (typeof defaults[p] !== 'object' || defaults[p] === null) {\n      defaults[p] = util.merge(instance[p].constructor === Array ? [] : {}, instance[p]);\n    } else {\n      util.merge(defaults[p], instance[p]);\n    }\n  }\n  return defaults;\n}\n\n},{}],13:[function(require,module,exports){\nvar util = module.exports = {};\n\nutil.keys = function (obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n}\n\nutil.vals = function (obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n}\n\nutil.range = function (start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n}\n\nutil.find = function (list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n}\n\nutil.uniq = function (data, field) {\n  var map = {}, count = 0, i, k;\n  for (i=0; i<data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n}\n\nutil.minmax = function (data, field) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (i=0; i<data.length; ++i) {\n    var v = data[i][field];\n    if (v > stats.max) stats.max = v;\n    if (v < stats.min) stats.min = v;\n  }\n  return stats;\n}\n\nutil.duplicate = function (obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.any = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(f(arr[k], k, i++)) return true;\n  }\n  return false;\n}\n\nutil.all = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(!f(arr[k], k, i++)) return false;\n  }\n  return true;\n}\n\nutil.merge = function(dest, src){\n  return util.keys(src).reduce(function(c, k){\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.getbins = function (stats) {\n  return vg.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: MAX_BINS\n  });\n}\n\n\nutil.error = function(msg){\n  console.error(\"[VL Error]\", msg);\n}\n\n\n},{}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJzcmMvRW5jb2RpbmcuanMiLCJzcmMvYXhpcy5qcyIsInNyYy9jb21waWxlLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9kYXRhLmpzIiwic3JjL2dsb2JhbHMuanMiLCJzcmMvbGVnZW5kcy5qcyIsInNyYy9tYXJrcy5qcyIsInNyYy9zY2FsZS5qcyIsInNyYy9zY2hlbWEuanMiLCJzcmMvc2NoZW1hdXRpbC5qcyIsInNyYy91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGdsb2JhbHMgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyk7XG5cbnZhciB2bCA9IHV0aWwubWVyZ2UoY29uc3RzLCB1dGlsKTtcblxudmwuc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbnZsLkVuY29kaW5nID0gcmVxdWlyZSgnLi9FbmNvZGluZycpO1xudmwuYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpO1xudmwuY29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZScpO1xudmwuZGF0YSA9IHJlcXVpcmUoJy4vZGF0YScpO1xudmwubGVnZW5kcyA9IHJlcXVpcmUoJy4vbGVnZW5kcycpO1xudmwubWFya3MgPSByZXF1aXJlKCcuL21hcmtzJylcbnZsLnNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL2dsb2JhbHMnKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuXG52YXIgRW5jb2RpbmcgPSBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBFbmNvZGluZyhtYXJrdHlwZSwgZW5jLCBjb25maWcpIHtcbiAgICAvLyBUT0RPOiBjYWNoaW5nXG4gICAgdmFyIGVuY0RlZmF1bHRzID0gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuYyk7XG4gICAgdmFyIGNmZ0RlZmF1bHRzID0gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmNmZyk7XG5cbiAgICAvLyBIYWNrXG4gICAgZm9yICh2YXIgayBpbiBjb25zdHMuREVGQVVMVFMpIHtcbiAgICAgIGNmZ0RlZmF1bHRzW2tdID0gY29uc3RzLkRFRkFVTFRTW2tdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBmaWVsZCBkZWZzIHRoYXQgd2UgZG9uJ3QgdXNlIGluIGVuY29kaW5nXG4gICAgZm9yICh2YXIgayBpbiBlbmNEZWZhdWx0cykge1xuICAgICAgaWYgKCFlbmNba10pIHtcbiAgICAgICAgZGVsZXRlIGVuY0RlZmF1bHRzW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcmt0eXBlID0gbWFya3R5cGU7XG4gICAgdGhpcy5fZW5jID0gc2NoZW1hLnV0aWwubWVyZ2UoZW5jRGVmYXVsdHMsIGVuYyk7XG4gICAgdGhpcy5fY2ZnID0gc2NoZW1hLnV0aWwubWVyZ2UoY2ZnRGVmYXVsdHMsIGNvbmZpZyk7XG4gIH1cblxuICB2YXIgcHJvdG8gPSBFbmNvZGluZy5wcm90b3R5cGU7XG5cbiAgcHJvdG8ubWFya3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGU7XG4gIH07XG5cbiAgcHJvdG8uaXMgPSBmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt0eXBlID09PSBtO1xuICB9O1xuXG4gIHByb3RvLmhhcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcHJvdG8uZW5jID0gZnVuY3Rpb24oeCl7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1t4XTtcbiAgfTtcblxuICAvLyBnZXQgXCJmaWVsZFwiIHByb3BlcnR5IGZvciB2ZWdhXG4gIHByb3RvLmZpZWxkID0gZnVuY3Rpb24oeCwgbm9kYXRhLCBub2ZuKSB7XG4gICAgaWYgKCF0aGlzLmhhcyh4KSkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgZiA9IChub2RhdGEgPyBcIlwiIDogXCJkYXRhLlwiKTtcblxuICAgIGlmICh0aGlzLl9lbmNbeF0uYWdnciA9PT0gXCJjb3VudFwiKSB7XG4gICAgICByZXR1cm4gZiArIFwiY291bnRcIjtcbiAgICB9IGVsc2UgaWYgKCFub2ZuICYmIHRoaXMuX2VuY1t4XS5iaW4pIHtcbiAgICAgIHJldHVybiBmICsgXCJiaW5fXCIgKyB0aGlzLl9lbmNbeF0ubmFtZTtcbiAgICB9IGVsc2UgaWYgKCFub2ZuICYmIHRoaXMuX2VuY1t4XS5hZ2dyKSB7XG4gICAgICByZXR1cm4gZiArIHRoaXMuX2VuY1t4XS5hZ2dyICsgXCJfXCIgKyB0aGlzLl9lbmNbeF0ubmFtZTtcbiAgICB9IGVsc2UgaWYgKCFub2ZuICYmIHRoaXMuX2VuY1t4XS5mbil7XG4gICAgICByZXR1cm4gZiArIHRoaXMuX2VuY1t4XS5mbiArIFwiX1wiICsgdGhpcy5fZW5jW3hdLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW3hdLm5hbWU7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLmZpZWxkTmFtZSA9IGZ1bmN0aW9uKHgpe1xuICAgIHJldHVybiB0aGlzLl9lbmNbeF0ubmFtZTtcbiAgfVxuXG4gIHByb3RvLmZpZWxkVGl0bGUgPSBmdW5jdGlvbih4KXtcbiAgICBpZiAodGhpcy5fZW5jW3hdLmFnZ3IpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmNbeF0uYWdnciArIFwiKFwiICsgdGhpcy5fZW5jW3hdLm5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5uYW1lO1xuICAgIH1cbiAgfVxuXG4gIHByb3RvLnNjYWxlID0gZnVuY3Rpb24oeCl7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5zY2FsZSB8fCB7fTtcbiAgfVxuXG4gIHByb3RvLmF4aXMgPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdLmF4aXMgfHwge307XG4gIH1cblxuICBwcm90by5hZ2dyID0gZnVuY3Rpb24oeCl7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5hZ2dyO1xuICB9XG5cbiAgcHJvdG8uYmluID0gZnVuY3Rpb24oeCl7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5iaW47XG4gIH1cblxuICBwcm90by5sZWdlbmQgPSBmdW5jdGlvbih4KXtcbiAgICByZXR1cm4gdGhpcy5fZW5jW3hdLmxlZ2VuZDtcbiAgfVxuXG4gIHByb3RvLmZuID0gZnVuY3Rpb24oeCl7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1t4XS5mbjtcbiAgfVxuXG4gIHByb3RvLmFueSA9IGZ1bmN0aW9uKGYpe1xuICAgIHJldHVybiB1dGlsLmFueSh0aGlzLl9lbmMsIGYpO1xuICB9XG5cbiAgcHJvdG8uYWxsID0gZnVuY3Rpb24oZil7XG4gICAgcmV0dXJuIHV0aWwuYWxsKHRoaXMuX2VuYywgZik7XG4gIH1cblxuICBwcm90by5sZW5ndGggPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB1dGlsLmtleXModGhpcy5fZW5jKS5sZW5ndGg7XG4gIH1cblxuICBwcm90by5yZWR1Y2UgPSBmdW5jdGlvbihmLCBpbml0KXtcbiAgICB2YXIgciA9IGluaXQsIGk9MDtcbiAgICBmb3IgKGsgaW4gdGhpcy5fZW5jKXtcbiAgICAgIHIgPSBmKHIsIHRoaXMuX2VuY1trXSwgaywgdGhpcy5fZW5jKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBwcm90by5mb3JFYWNoID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBpPTAsIGs7XG4gICAgZm9yIChrIGluIHRoaXMuX2VuYykge1xuICAgICAgZihrLCB0aGlzLl9lbmNba10sIGkrKyk7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLnR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKHgpID8gdGhpcy5fZW5jW3hdLnR5cGUgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLmlzVHlwZSA9IGZ1bmN0aW9uKHgsIHQpIHtcbiAgICB2YXIgeHQgPSB0aGlzLnR5cGUoeCk7XG4gICAgaWYgKHh0ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKHh0ICYgdCkgPiAwO1xuICB9O1xuXG4gIHByb3RvLmNvbmZpZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnW25hbWVdO1xuICB9O1xuXG4gIHByb3RvLnRvU3BlYyA9IGZ1bmN0aW9uKGV4Y2x1ZGVDb25maWcpe1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9lbmMpLFxuICAgICAgc3BlYztcblxuICAgIC8vIGNvbnZlcnQgdHlwZSdzIGJpdGNvZGUgdG8gdHlwZSBuYW1lXG4gICAgZm9yKHZhciBlIGluIGVuYyl7XG4gICAgICBlbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZU5hbWVzW2VuY1tlXS50eXBlXTtcbiAgICB9XG5cbiAgICBzcGVjID0ge1xuICAgICAgbWFya3R5cGU6IHRoaXMuX21hcmt0eXBlLFxuICAgICAgZW5jOiBlbmNcbiAgICB9XG5cbiAgICBpZighZXhjbHVkZUNvbmZpZyl7XG4gICAgICBzcGVjLmNmZyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2NmZylcbiAgICB9XG5cbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICBwcm90by50b1Nob3J0aGFuZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVuYyA9IHRoaXMuX2VuYztcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgKyBcIi5cIiArIHV0aWwua2V5cyhlbmMpLm1hcChmdW5jdGlvbihlKXtcbiAgICAgIHZhciB2ID0gZW5jW2VdO1xuICAgICAgICByZXR1cm4gZSArIFwiLVwiICtcbiAgICAgICAgICAodi5hZ2dyID8gdi5hZ2dyK1wiX1wiIDogXCJcIikgK1xuICAgICAgICAgICh2LmZuID8gdi5mbitcIl9cIiA6IFwiXCIpICtcbiAgICAgICAgICAodi5iaW4gPyBcImJpbl9cIiA6IFwiXCIpICtcbiAgICAgICAgICAodi5uYW1lIHx8IFwiXCIpICsgXCItXCIgK1xuICAgICAgICAgIGNvbnN0cy5kYXRhVHlwZU5hbWVzW3YudHlwZV07XG4gICAgICB9XG4gICAgKS5qb2luKFwiLlwiKTtcbiAgfVxuXG4gIEVuY29kaW5nLnBhcnNlU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kLCBjZmcpe1xuICAgIHZhciBlbmMgPSBzaG9ydGhhbmQuc3BsaXQoXCIuXCIpLFxuICAgICAgbWFya3R5cGUgPSBlbmMuc2hpZnQoKTtcblxuICAgIGVuYyA9IGVuYy5yZWR1Y2UoZnVuY3Rpb24obSwgZSl7XG4gICAgICB2YXIgc3BsaXQgPSBlLnNwbGl0KFwiLVwiKSxcbiAgICAgICAgZW5jdHlwZSA9IHNwbGl0WzBdLFxuICAgICAgICBvID0ge25hbWU6IHNwbGl0WzFdLCB0eXBlOiBjb25zdHMuZGF0YVR5cGVzW3NwbGl0WzJdXX07XG5cbiAgICAgIC8vIGNoZWNrIGFnZ3JlZ2F0ZSB0eXBlXG4gICAgICBmb3IodmFyIGkgaW4gc2NoZW1hLmFnZ3IuZW51bSl7XG4gICAgICAgIHZhciBhID0gc2NoZW1hLmFnZ3IuZW51bVtpXTtcbiAgICAgICAgaWYoby5uYW1lLmluZGV4T2YoYStcIl9cIikgPT0gMCl7XG4gICAgICAgICAgby5uYW1lID0gby5uYW1lLnN1YnN0cihhLmxlbmd0aCsxKTtcbiAgICAgICAgICBpZiAoYT09XCJjb3VudFwiICYmIG8ubmFtZS5sZW5ndGggPT09IDApIG8ubmFtZSA9IFwiKlwiO1xuICAgICAgICAgIG8uYWdnciA9IGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNoZWNrIHRpbWUgZm5cbiAgICAgIGZvcih2YXIgaSBpbiBzY2hlbWEudGltZWZucyl7XG4gICAgICAgIHZhciBmID0gc2NoZW1hLnRpbWVmbnNbaV07XG4gICAgICAgIGlmKG8ubmFtZSAmJiBvLm5hbWUuaW5kZXhPZihmK1wiX1wiKSA9PSAwKXtcbiAgICAgICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKG8ubGVuZ3RoKzEpO1xuICAgICAgICAgIG8uZm4gPSBmO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGJpblxuICAgICAgaWYoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKFwiYmluX1wiKSA9PSAwKXtcbiAgICAgICAgby5uYW1lID0gby5uYW1lLnN1YnN0cig0KTtcbiAgICAgICAgby5iaW4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBtW2VuY3R5cGVdID0gbztcbiAgICAgIHJldHVybiBtO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiBuZXcgRW5jb2RpbmcobWFya3R5cGUsIGVuYywgY2ZnKTtcbiAgfVxuXG4gIEVuY29kaW5nLmZyb21TcGVjID0gZnVuY3Rpb24oc3BlYywgZXh0cmFDZmcpIHtcbiAgICB2YXIgZW5jID0gdXRpbC5kdXBsaWNhdGUoc3BlYy5lbmMpO1xuXG4gICAgLy9jb252ZXJ0IHR5cGUgZnJvbSBzdHJpbmcgdG8gYml0Y29kZSAoZS5nLCBPPTEpXG4gICAgZm9yKHZhciBlIGluIGVuYyl7XG4gICAgICBlbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZXNbZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoc3BlYy5tYXJrdHlwZSwgZW5jLCB1dGlsLm1lcmdlKHNwZWMuY2ZnLCBleHRyYUNmZyB8fCB7fSkpO1xuICB9XG5cbiAgcmV0dXJuIEVuY29kaW5nO1xuXG59KSgpO1xuIiwidmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgYXhpcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmF4aXMubmFtZXMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgcmV0dXJuIHV0aWwua2V5cyh1dGlsLmtleXMocHJvcHMpLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7XG4gICAgdmFyIHMgPSBwcm9wc1t4XS5zY2FsZTtcbiAgICBpZiAocz09PVggfHwgcz09PVkpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn1cblxuYXhpcy5kZWZzID0gZnVuY3Rpb24obmFtZXMsIGVuY29kaW5nLCBvcHQpIHtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihhLCBuYW1lKSB7XG4gICAgYS5wdXNoKGF4aXNfZGVmKG5hbWUsIGVuY29kaW5nLCBvcHQpKTtcbiAgICByZXR1cm4gYTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBheGlzX2RlZihuYW1lLCBlbmNvZGluZywgb3B0KXtcbiAgdmFyIHR5cGUgPSBuYW1lLCBheGlzO1xuICB2YXIgaXNDb2wgPSBuYW1lPT1DT0wsIGlzUm93ID0gbmFtZT09Uk9XO1xuICBpZihpc0NvbCkgdHlwZSA9IFwieFwiO1xuICBpZihpc1JvdykgdHlwZSA9IFwieVwiO1xuXG4gIHZhciBheGlzID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2NhbGU6IG5hbWUsXG4gICAgdGlja3M6IDMgLy9UT0RPKGthbml0dyk6IGJldHRlciBkZXRlcm1pbmUgIyBvZiB0aWNrc1xuICB9O1xuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmdyaWQpIHtcbiAgICBheGlzLmdyaWQgPSB0cnVlO1xuICAgIGF4aXMubGF5ZXIgPSBcImJhY2tcIjtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLnRpdGxlKSB7XG4gICAgLy9zaG93IHRpdGxlIGJ5IGRlZmF1bHRcblxuICAgIGF4aXMgPSBheGlzX3RpdGxlKGF4aXMsIG5hbWUsIGVuY29kaW5nLCBvcHQpO1xuICB9XG5cbiAgaWYoaXNSb3cgfHwgaXNDb2wpe1xuICAgIGF4aXMucHJvcGVydGllcyA9IHtcbiAgICAgIHRpY2tzOiB7IG9wYWNpdHk6IHt2YWx1ZTogMH0gfSxcbiAgICAgIG1ham9yVGlja3M6IHsgb3BhY2l0eToge3ZhbHVlOiAwfSB9LFxuICAgICAgYXhpczogeyBvcGFjaXR5OiB7dmFsdWU6IDB9IH1cbiAgICB9O1xuICB9XG4gIGlmKGlzQ29sKXtcbiAgICBheGlzLm9mZnNldCA9IFtvcHQueEF4aXNNYXJnaW4gfHwgMCwgZW5jb2RpbmcuY29uZmlnKFwieUF4aXNNYXJnaW5cIildO1xuICAgIGF4aXMub3JpZW50ID0gXCJ0b3BcIjtcbiAgfVxuXG4gIGlmIChuYW1lPT1cInhcIiAmJiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIE8pIHx8IGVuY29kaW5nLmJpbihuYW1lKSkpIHtcbiAgICBheGlzLnByb3BlcnRpZXMgPSB7XG4gICAgICBsYWJlbHM6IHtcbiAgICAgICAgYW5nbGU6IHt2YWx1ZTogMjcwfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogXCJyaWdodFwifSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gYXhpc190aXRsZShheGlzLCBuYW1lLCBlbmNvZGluZywgb3B0KXtcbiAgYXhpcy50aXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSk7XG4gIGlmKG5hbWU9PVkpe1xuICAgIGF4aXMudGl0bGVPZmZzZXQgPSA2MDtcbiAgICAvLyBUT0RPOiBzZXQgYXBwcm9wcmlhdGUgdGl0bGVPZmZzZXRcbiAgICAvLyBtYXliZSBiYXNlZCBvbiBzb21lIHN0cmluZyBsZW5ndGggZnJvbSBzdGF0c1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuIiwidmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICBheGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGxlZ2VuZHMgPSByZXF1aXJlKCcuL2xlZ2VuZHMnKSxcbiAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyksXG4gIHNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG52YXIgY29tcGlsZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBzaXplID0gc2V0U2l6ZShlbmNvZGluZywgc3RhdHMpLFxuICAgIGNlbGxXaWR0aCA9IHNpemUuY2VsbFdpZHRoLFxuICAgIGNlbGxIZWlnaHQgPSBzaXplLmNlbGxIZWlnaHQ7XG5cbiAgdmFyIGhhc0FnZyA9IGVuY29kaW5nLmFueShmdW5jdGlvbih2LCBrKXtcbiAgICByZXR1cm4gdi5hZ2dyICE9PSB1bmRlZmluZWQ7XG4gIH0pO1xuXG4gIHZhciBzcGVjID0gdGVtcGxhdGUoZW5jb2RpbmcsIHNpemUsIHN0YXRzKSxcbiAgICBncm91cCA9IHNwZWMubWFya3NbMF0sXG4gICAgbWFyayA9IG1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLFxuICAgIG1kZWYgPSBtYXJrZGVmKG1hcmssIGVuY29kaW5nLCB7XG4gICAgICBoYXNBZ2dyZWdhdGU6IGhhc0FnZ1xuICAgIH0pO1xuXG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSwgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCk7XG5cbiAgdmFyIHByZWFnZ3JlZ2F0ZWREYXRhID0gZW5jb2RpbmcuY29uZmlnKFwidXNlVmVnYVNlcnZlclwiKTtcblxuICBncm91cC5tYXJrcy5wdXNoKG1kZWYpO1xuICAvLyBUT0RPOiByZXR1cm4gdmFsdWUgbm90IHVzZWRcbiAgYmlubmluZyhzcGVjLmRhdGFbMF0sIGVuY29kaW5nLCB7cHJlYWdncmVnYXRlZERhdGE6IHByZWFnZ3JlZ2F0ZWREYXRhfSk7XG5cbiAgdmFyIGxpbmVUeXBlID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0ubGluZTtcblxuICBpZighcHJlYWdncmVnYXRlZERhdGEpe1xuICAgIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSwgZmllbGQpe1xuICAgICAgaWYoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC5mbil7XG4gICAgICAgIHRpbWVUcmFuc2Zvcm0oc3BlYy5kYXRhWzBdLCBlbmNvZGluZywgZW5jVHlwZSwgZmllbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmZhY2V0c1xuICB2YXIgYWdnUmVzdWx0ID0gYWdncmVnYXRlcyhzcGVjLmRhdGFbMF0sIGVuY29kaW5nLCB7cHJlYWdncmVnYXRlZERhdGE6IHByZWFnZ3JlZ2F0ZWREYXRhfSksXG4gICAgZGV0YWlscyA9IGFnZ1Jlc3VsdC5kZXRhaWxzLFxuICAgIGhhc0RldGFpbHMgPSBkZXRhaWxzICYmIGRldGFpbHMubGVuZ3RoID4gMCxcbiAgICBzdGFjayA9IGhhc0RldGFpbHMgJiYgc3RhY2tpbmcoc3BlYywgZW5jb2RpbmcsIG1kZWYsIGFnZ1Jlc3VsdC5mYWNldHMpO1xuXG4gIGlmIChoYXNEZXRhaWxzICYmIChzdGFjayB8fCBsaW5lVHlwZSkpIHtcbiAgICAvL3N1YmZhY2V0IHRvIGdyb3VwIHN0YWNrIC8gbGluZSB0b2dldGhlciBpbiBvbmUgZ3JvdXBcbiAgICBzdWJmYWNldChncm91cCwgbWRlZiwgZGV0YWlscywgc3RhY2ssIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIGF1dG8tc29ydCBsaW5lL2FyZWEgdmFsdWVzXG4gIC8vVE9ETyhrYW5pdHcpOiBoYXZlIHNvbWUgY29uZmlnIHRvIHR1cm4gb2ZmIGF1dG8tc29ydCBmb3IgbGluZSAoZm9yIGxpbmUgY2hhcnQgdGhhdCBlbmNvZGVzIHRlbXBvcmFsIGluZm9ybWF0aW9uKVxuICBpZiAobGluZVR5cGUpIHtcbiAgICB2YXIgZiA9IChlbmNvZGluZy5pc1R5cGUoWCwgUSB8IFQpICYmIGVuY29kaW5nLmlzVHlwZShZLCBPKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkgbWRlZi5mcm9tID0ge307XG4gICAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7dHlwZTogXCJzb3J0XCIsIGJ5OiBlbmNvZGluZy5maWVsZChmKX1dO1xuICB9XG5cbiAgLy8gU21hbGwgTXVsdGlwbGVzXG4gIGlmIChoYXNSb3cgfHwgaGFzQ29sKSB7XG4gICAgc3BlYyA9IGZhY2V0KGdyb3VwLCBlbmNvZGluZywgY2VsbEhlaWdodCwgY2VsbFdpZHRoLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwLnNjYWxlcyA9IHNjYWxlLmRlZnMoc2NhbGUubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSksIGVuY29kaW5nLFxuICAgICAge3N0YWNrOiBzdGFjaywgc3RhdHM6IHN0YXRzfSk7XG4gICAgZ3JvdXAuYXhlcyA9IGF4aXMuZGVmcyhheGlzLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZyk7XG4gICAgZ3JvdXAubGVnZW5kcyA9IGxlZ2VuZHMuZGVmcyhlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5mdW5jdGlvbiBnZXRDYXJkaW5hbGl0eShlbmNvZGluZywgZW5jVHlwZSwgc3RhdHMpe1xuICB2YXIgZmllbGQgPSBlbmNvZGluZy5maWVsZE5hbWUoZW5jVHlwZSk7XG4gIGlmIChlbmNvZGluZy5iaW4oZW5jVHlwZSkpIHtcbiAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhzdGF0c1tmaWVsZF0pO1xuICAgIHJldHVybiAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gIH1cbiAgcmV0dXJuIHN0YXRzW2ZpZWxkXS5jYXJkaW5hbGl0eTtcbn1cblxuZnVuY3Rpb24gc2V0U2l6ZShlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLFxuICAgICAgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCksXG4gICAgICBoYXNYID0gZW5jb2RpbmcuaGFzKFgpLFxuICAgICAgaGFzWSA9IGVuY29kaW5nLmhhcyhZKTtcblxuICAvLyBIQUNLIHRvIHNldCBjaGFydCBzaXplXG4gIC8vIE5PVEU6IHRoaXMgZmFpbHMgZm9yIHBsb3RzIGRyaXZlbiBieSBkZXJpdmVkIHZhbHVlcyAoZS5nLiwgYWdncmVnYXRlcylcbiAgLy8gT25lIHNvbHV0aW9uIGlzIHRvIHVwZGF0ZSBWZWdhIHRvIHN1cHBvcnQgYXV0by1zaXppbmdcbiAgLy8gSW4gdGhlIG1lYW50aW1lLCBhdXRvLXBhZGRpbmcgKG1vc3RseSkgZG9lcyB0aGUgdHJpY2tcbiAgLy9cbiAgdmFyIGNvbENhcmRpbmFsaXR5ID0gaGFzQ29sID8gZ2V0Q2FyZGluYWxpdHkoZW5jb2RpbmcsIENPTCwgc3RhdHMpIDogMSxcbiAgICByb3dDYXJkaW5hbGl0eSA9IGhhc1JvdyA/IGdldENhcmRpbmFsaXR5KGVuY29kaW5nLCBST1csIHN0YXRzKSA6IDE7XG5cbiAgdmFyIGNlbGxXaWR0aCA9IGhhc1ggP1xuICAgICAgK2VuY29kaW5nLmNvbmZpZyhcImNlbGxXaWR0aFwiKSB8fCBlbmNvZGluZy5jb25maWcoXCJ3aWR0aFwiKSAqIDEuMCAvIGNvbENhcmRpbmFsaXR5IDpcbiAgICAgIGVuY29kaW5nLm1hcmt0eXBlKCkgPT09IFwidGV4dFwiID9cbiAgICAgICAgK2VuY29kaW5nLmNvbmZpZyhcInRleHRDZWxsV2lkdGhcIikgOlxuICAgICAgICArZW5jb2RpbmcuY29uZmlnKFwiYmFuZFNpemVcIiksXG4gICAgY2VsbEhlaWdodCA9IGhhc1kgP1xuICAgICAgK2VuY29kaW5nLmNvbmZpZyhcImNlbGxIZWlnaHRcIikgfHwgZW5jb2RpbmcuY29uZmlnKFwiaGVpZ2h0XCIpICogMS4wIC8gcm93Q2FyZGluYWxpdHkgOlxuICAgICAgK2VuY29kaW5nLmNvbmZpZyhcImJhbmRTaXplXCIpLFxuICAgIGNlbGxQYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKFwiY2VsbFBhZGRpbmdcIiksXG4gICAgYmFuZFBhZGRpbmcgPSBlbmNvZGluZy5jb25maWcoXCJiYW5kUGFkZGluZ1wiKSxcbiAgICB3aWR0aCA9IGVuY29kaW5nLmNvbmZpZyhcIl9taW5XaWR0aFwiKSxcbiAgICBoZWlnaHQgPSBlbmNvZGluZy5jb25maWcoXCJfbWluSGVpZ2h0XCIpO1xuXG4gIGlmIChoYXNYICYmIChlbmNvZGluZy5pc1R5cGUoWCwgTykgfHwgZW5jb2RpbmcuYmluKFgpKSkgeyAvL29yZGluYWwgZmllbGQgd2lsbCBvdmVycmlkZSBwYXJlbnRcbiAgICAvLyBiYW5kcyB3aXRoaW4gY2VsbCB1c2UgcmFuZ2VQb2ludHMoKVxuICAgIHZhciB4Q2FyZGluYWxpdHkgPSBnZXRDYXJkaW5hbGl0eShlbmNvZGluZywgWCwgc3RhdHMpO1xuICAgIGNlbGxXaWR0aCA9ICh4Q2FyZGluYWxpdHkgKyBiYW5kUGFkZGluZykgKiArZW5jb2RpbmcuY29uZmlnKFwiYmFuZFNpemVcIik7XG4gIH1cbiAgLy8gQ2VsbCBiYW5kcyB1c2UgcmFuZ2VCYW5kcygpLiBUaGVyZSBhcmUgbi0xIHBhZGRpbmcuICBPdXRlcnBhZGRpbmcgPSAwIGZvciBjZWxsc1xuICB3aWR0aCA9IGNlbGxXaWR0aCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChjb2xDYXJkaW5hbGl0eS0xKSArIDEpO1xuXG4gIGlmIChoYXNZICYmIChlbmNvZGluZy5pc1R5cGUoWSwgTykgfHwgZW5jb2RpbmcuYmluKFkpKSkge1xuICAgIC8vIGJhbmRzIHdpdGhpbiBjZWxsIHVzZSByYW5nZVBvaW50KClcbiAgICB2YXIgeUNhcmRpbmFsaXR5ID0gZ2V0Q2FyZGluYWxpdHkoZW5jb2RpbmcsIFksIHN0YXRzKTtcbiAgICBjZWxsSGVpZ2h0ID0gKHlDYXJkaW5hbGl0eSArIGJhbmRQYWRkaW5nKSAqICtlbmNvZGluZy5jb25maWcoXCJiYW5kU2l6ZVwiKTtcbiAgfVxuICAvLyBDZWxsIGJhbmRzIHVzZSByYW5nZUJhbmRzKCkuIFRoZXJlIGFyZSBuLTEgcGFkZGluZy4gIE91dGVycGFkZGluZyA9IDAgZm9yIGNlbGxzXG4gIGhlaWdodCA9IGNlbGxIZWlnaHQgKiAoKDEgKyBjZWxsUGFkZGluZykgKiAocm93Q2FyZGluYWxpdHktMSkgKyAxKTtcblxuICByZXR1cm4ge1xuICAgIGNlbGxXaWR0aDogY2VsbFdpZHRoLFxuICAgIGNlbGxIZWlnaHQ6IGNlbGxIZWlnaHQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDpoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBjZWxsSGVpZ2h0LCBjZWxsV2lkdGgsIHNwZWMsIG1kZWYsIHN0YWNrLCBzdGF0cykge1xuICAgIHZhciBlbnRlciA9IGdyb3VwLnByb3BlcnRpZXMuZW50ZXI7XG4gICAgdmFyIGZhY2V0S2V5cyA9IFtdLCBjZWxsQXhlcyA9IFtdO1xuXG4gICAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLCBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKTtcblxuICAgIHZhciB4QXhpc01hcmdpbiA9IGVuY29kaW5nLmhhcyhZKSA/IGVuY29kaW5nLmNvbmZpZyhcInhBeGlzTWFyZ2luXCIpIDogdW5kZWZpbmVkO1xuXG4gICAgZW50ZXIuZmlsbCA9IHt2YWx1ZTogZW5jb2RpbmcuY29uZmlnKFwiY2VsbEJhY2tncm91bmRDb2xvclwiKX07XG5cbiAgICAvL21vdmUgXCJmcm9tXCIgdG8gY2VsbCBsZXZlbCBhbmQgYWRkIGZhY2V0IHRyYW5zZm9ybVxuICAgIGdyb3VwLmZyb20gPSB7ZGF0YTogZ3JvdXAubWFya3NbMF0uZnJvbS5kYXRhfTtcblxuICAgIGlmIChncm91cC5tYXJrc1swXS5mcm9tLnRyYW5zZm9ybSkge1xuICAgICAgZGVsZXRlIGdyb3VwLm1hcmtzWzBdLmZyb20uZGF0YTsgLy9uZWVkIHRvIGtlZXAgdHJhbnNmb3JtIGZvciBzdWJmYWNldHRpbmcgY2FzZVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgZ3JvdXAubWFya3NbMF0uZnJvbTtcbiAgICB9XG4gICAgaWYgKGhhc1Jvdykge1xuICAgICAgaWYgKCFlbmNvZGluZy5pc1R5cGUoUk9XLCBPKSkge1xuICAgICAgICB1dGlsLmVycm9yKFwiUm93IGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLlwiKTtcbiAgICAgIH1cbiAgICAgIGVudGVyLnkgPSB7c2NhbGU6IFJPVywgZmllbGQ6IFwia2V5cy5cIiArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgICAgZW50ZXIuaGVpZ2h0ID0ge1widmFsdWVcIjogY2VsbEhlaWdodH07IC8vIEhBQ0tcblxuICAgICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGQoUk9XKSk7XG5cbiAgICAgIHZhciBmcm9tO1xuICAgICAgaWYgKGhhc0NvbCkge1xuICAgICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICAgIGZyb20udHJhbnNmb3JtID0gZnJvbS50cmFuc2Zvcm0gfHwgW107XG4gICAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6IFwiZmFjZXRcIiwga2V5czogW2VuY29kaW5nLmZpZWxkKENPTCldfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBheGVzR3JwID0gZ3JvdXBkZWYoXCJ4LWF4ZXNcIiwge1xuICAgICAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhYKSA/ICBheGlzLmRlZnMoW1wieFwiXSwgZW5jb2RpbmcpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHg6IGhhc0NvbCA/IHtzY2FsZTogQ09MLCBmaWVsZDogXCJrZXlzLjBcIiwgb2Zmc2V0OiB4QXhpc01hcmdpbn0gOiB7dmFsdWU6IHhBeGlzTWFyZ2lufSxcbiAgICAgICAgICB3aWR0aDogaGFzQ29sICYmIHtcInZhbHVlXCI6IGNlbGxXaWR0aH0sIC8vSEFDSz9cbiAgICAgICAgICBmcm9tOiBmcm9tXG4gICAgICAgIH0pO1xuXG4gICAgICBzcGVjLm1hcmtzLnB1c2goYXhlc0dycCk7XG4gICAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICAgIHNwZWMuYXhlcy5wdXNoLmFwcGx5KHNwZWMuYXhlcywgYXhpcy5kZWZzKFtcInJvd1wiXSwgZW5jb2RpbmcpKTtcbiAgICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgcm93XG4gICAgICBpZihlbmNvZGluZy5oYXMoWCkpe1xuICAgICAgICAvL2tlZXAgeCBheGlzIGluIHRoZSBjZWxsXG4gICAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbXCJ4XCJdLCBlbmNvZGluZykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNDb2wpIHtcbiAgICAgIGlmICghZW5jb2RpbmcuaXNUeXBlKENPTCwgTykpIHtcbiAgICAgICAgdXRpbC5lcnJvcihcIkNvbCBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC5cIik7XG4gICAgICB9XG4gICAgICBlbnRlci54ID0ge3NjYWxlOiBDT0wsIGZpZWxkOiBcImtleXMuXCIgKyBmYWNldEtleXMubGVuZ3RofTtcbiAgICAgIGVudGVyLndpZHRoID0ge1widmFsdWVcIjogY2VsbFdpZHRofTsgLy8gSEFDS1xuXG4gICAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZChDT0wpKTtcblxuICAgICAgdmFyIGZyb207XG4gICAgICBpZiAoaGFzUm93KSB7XG4gICAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogXCJmYWNldFwiLCBrZXlzOiBbZW5jb2RpbmcuZmllbGQoUk9XKV19KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF4ZXNHcnAgPSBncm91cGRlZihcInktYXhlc1wiLCB7XG4gICAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhZKSA/IGF4aXMuZGVmcyhbXCJ5XCJdLCBlbmNvZGluZykgOiB1bmRlZmluZWQsXG4gICAgICAgIHk6IGhhc1JvdyAmJiB7c2NhbGU6IFJPVywgZmllbGQ6IFwia2V5cy4wXCJ9LFxuICAgICAgICB4OiBoYXNSb3cgJiYge3ZhbHVlOiB4QXhpc01hcmdpbn0sXG4gICAgICAgIGhlaWdodDogaGFzUm93ICYmIHtcInZhbHVlXCI6IGNlbGxIZWlnaHR9LCAvL0hBQ0s/XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgIH0pO1xuXG4gICAgICBzcGVjLm1hcmtzLnB1c2goYXhlc0dycCk7XG4gICAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKVxuICAgICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoW1wiY29sXCJdLCBlbmNvZGluZywge1xuICAgICAgICB4QXhpc01hcmdpbjogeEF4aXNNYXJnaW5cbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgY29sXG4gICAgICBpZihlbmNvZGluZy5oYXMoWSkpe1xuICAgICAgICBjZWxsQXhlcy5wdXNoLmFwcGx5KGNlbGxBeGVzLCBheGlzLmRlZnMoW1wieVwiXSwgZW5jb2RpbmcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihoYXNSb3cpe1xuICAgICAgaWYoZW50ZXIueCkgZW50ZXIueC5vZmZzZXQ9IHhBeGlzTWFyZ2luO1xuICAgICAgZWxzZSBlbnRlci54ID0ge3ZhbHVlOiB4QXhpc01hcmdpbn07XG4gICAgfVxuICAgIGlmKGhhc0NvbCl7XG4gICAgICAvL1RPRE8gZmlsbCBoZXJlLi5cbiAgICB9XG5cbiAgICAvLyBhc3N1bWluZyBlcXVhbCBjZWxsV2lkdGggaGVyZVxuICAgIC8vIFRPRE86IHN1cHBvcnQgaGV0ZXJvZ2Vub3VzIGNlbGxXaWR0aCAobWF5YmUgYnkgdXNpbmcgbXVsdGlwbGUgc2NhbGVzPylcbiAgICBzcGVjLnNjYWxlcyA9IChzcGVjLnNjYWxlcyB8fFtdKS5jb25jYXQoc2NhbGUuZGVmcyhcbiAgICAgIHNjYWxlLm5hbWVzKGVudGVyKS5jb25jYXQoc2NhbGUubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSkpLFxuICAgICAgZW5jb2RpbmcsXG4gICAgICB7Y2VsbFdpZHRoOiBjZWxsV2lkdGgsIGNlbGxIZWlnaHQ6IGNlbGxIZWlnaHQsIHN0YWNrOiBzdGFjaywgZmFjZXQ6dHJ1ZSwgc3RhdHM6IHN0YXRzfVxuICAgICkpOyAvLyByb3cvY29sIHNjYWxlcyArIGNlbGwgc2NhbGVzXG5cbiAgICBpZiAoY2VsbEF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgZ3JvdXAuYXhlcyA9IGNlbGxBeGVzO1xuICAgIH1cblxuICAgIC8vIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgICB2YXIgdHJhbnMgPSAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gfHwgKGdyb3VwLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgICB0cmFucy51bnNoaWZ0KHt0eXBlOiBcImZhY2V0XCIsIGtleXM6IGZhY2V0S2V5c30pO1xuXG4gIHJldHVybiBzcGVjO1xuICB9XG5cbmZ1bmN0aW9uIHN1YmZhY2V0KGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpIHtcbiAgdmFyIG0gPSBncm91cC5tYXJrcyxcbiAgICBnID0gZ3JvdXBkZWYoXCJzdWJmYWNldFwiLCB7bWFya3M6IG19KTtcblxuICBncm91cC5tYXJrcyA9IFtnXTtcbiAgZy5mcm9tID0gbWRlZi5mcm9tO1xuICBkZWxldGUgbWRlZi5mcm9tO1xuXG4gIC8vVE9ETyB0ZXN0IExPRCAtLSB3ZSBzaG91bGQgc3VwcG9ydCBzdGFjayAvIGxpbmUgd2l0aG91dCBjb2xvciAoTE9EKSBmaWVsZFxuICB2YXIgdHJhbnMgPSAoZy5mcm9tLnRyYW5zZm9ybSB8fCAoZy5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6IFwiZmFjZXRcIiwga2V5czogZGV0YWlsc30pO1xuXG4gIGlmIChzdGFjayAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdHJhbnMudW5zaGlmdCh7dHlwZTogXCJzb3J0XCIsIGJ5OiBlbmNvZGluZy5maWVsZChDT0xPUil9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lRm4oZm4pe1xuICBzd2l0Y2goZm4pe1xuICAgIGNhc2UgXCJzZWNvbmRcIjogcmV0dXJuIFwiZ2V0VVRDU2Vjb25kc1wiO1xuICAgIGNhc2UgXCJtaW51dGVcIjogcmV0dXJuIFwiZ2V0VVRDTWludXRlc1wiO1xuICAgIGNhc2UgXCJob3VyXCI6IHJldHVybiBcImdldFVUQ0hvdXJzXCI7XG4gICAgY2FzZSBcImRheVwiOiByZXR1cm4gXCJnZXRVVENEYXlcIjtcbiAgICBjYXNlIFwiZGF0ZVwiOiByZXR1cm4gXCJnZXRVVENEYXRlXCI7XG4gICAgY2FzZSBcIm1vbnRoXCI6IHJldHVybiBcImdldFVUQ01vbnRoXCI7XG4gICAgY2FzZSBcInllYXJcIjogcmV0dXJuIFwiZ2V0VVRDRnVsbFllYXJcIjtcbiAgfVxuICBjb25zb2xlLmVycm9yKFwibm8gZnVuY3Rpb24gc3BlY2lmaWVkIGZvciBkYXRlXCIpO1xufVxuXG5mdW5jdGlvbiB0aW1lVHJhbnNmb3JtKHNwZWMsIGVuY29kaW5nLCBlbmNUeXBlLCBmaWVsZCl7XG4gIHZhciBmdW5jID0gZ2V0VGltZUZuKGZpZWxkLmZuKTtcblxuICBzcGVjLnRyYW5zZm9ybSA9IHNwZWMudHJhbnNmb3JtIHx8IFtdO1xuICBzcGVjLnRyYW5zZm9ybS5wdXNoKHtcbiAgICB0eXBlOiBcImZvcm11bGFcIixcbiAgICBmaWVsZDogZW5jb2RpbmcuZmllbGQoZW5jVHlwZSksXG4gICAgZXhwcjogXCJuZXcgRGF0ZShkLmRhdGEuXCIrZmllbGQubmFtZStcIikuXCIrZnVuYytcIigpXCJcbiAgfSk7XG4gIHJldHVybiBzcGVjO1xufVxuXG5mdW5jdGlvbiBiaW5uaW5nKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgYmlucyA9IHt9O1xuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKHZ2LCBkKSB7XG4gICAgaWYgKGQuYmluKSBiaW5zW2QubmFtZV0gPSBkLm5hbWU7XG4gIH0pO1xuICBiaW5zID0gdXRpbC5rZXlzKGJpbnMpO1xuXG4gIGlmIChiaW5zLmxlbmd0aCA9PT0gMCB8fCBvcHQucHJlYWdncmVnYXRlZERhdGEpIHJldHVybiBmYWxzZTtcblxuICBpZiAoIXNwZWMudHJhbnNmb3JtKSBzcGVjLnRyYW5zZm9ybSA9IFtdO1xuICBiaW5zLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIHNwZWMudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogXCJiaW5cIixcbiAgICAgIGZpZWxkOiBcImRhdGEuXCIgKyBkLFxuICAgICAgb3V0cHV0OiBcImRhdGEuYmluX1wiICsgZCxcbiAgICAgIG1heGJpbnM6IE1BWF9CSU5TXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYmlucztcbn1cblxuZnVuY3Rpb24gYWdncmVnYXRlcyhzcGVjLCBlbmNvZGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGRpbXMgPSB7fSwgbWVhcyA9IHt9LCBkZXRhaWwgPSB7fSwgZmFjZXRzPXt9O1xuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGVuY1R5cGUsIGZpZWxkKSB7XG4gICAgaWYgKGZpZWxkLmFnZ3IpIHtcbiAgICAgIGlmKGZpZWxkLmFnZ3I9PT1cImNvdW50XCIpe1xuICAgICAgICBtZWFzW1wiY291bnRcIl0gPSB7b3A6XCJjb3VudFwiLCBmaWVsZDpcIipcIn07XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbWVhc1tmaWVsZC5hZ2dyK1wifFwiK2ZpZWxkLm5hbWVdID0ge1xuICAgICAgICAgIG9wOmZpZWxkLmFnZ3IsXG4gICAgICAgICAgZmllbGQ6XCJkYXRhLlwiK2ZpZWxkLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGltc1tmaWVsZC5uYW1lXSA9IGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpO1xuICAgICAgaWYgKGVuY1R5cGU9PVJPVyB8fCBlbmNUeXBlID09IENPTCl7XG4gICAgICAgIGZhY2V0c1tmaWVsZC5uYW1lXSA9IGRpbXNbZmllbGQubmFtZV07XG4gICAgICB9ZWxzZSBpZiAoZW5jVHlwZSAhPT0gWCAmJiBlbmNUeXBlICE9PSBZKSB7XG4gICAgICAgIGRldGFpbFtmaWVsZC5uYW1lXSA9IGRpbXNbZmllbGQubmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGltcyA9IHV0aWwudmFscyhkaW1zKTtcbiAgbWVhcyA9IHV0aWwudmFscyhtZWFzKTtcblxuICBpZiAobWVhcy5sZW5ndGggPiAwICYmICFvcHQucHJlYWdncmVnYXRlZERhdGEpIHtcbiAgICBpZiAoIXNwZWMudHJhbnNmb3JtKSBzcGVjLnRyYW5zZm9ybSA9IFtdO1xuICAgIHNwZWMudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICAgIGdyb3VwYnk6IGRpbXMsXG4gICAgICBmaWVsZHM6IG1lYXNcbiAgICB9KTtcblxuICAgIGlmIChlbmNvZGluZy5tYXJrdHlwZSgpID09PSBURVhUKSB7XG4gICAgICBtZWFzLmZvckVhY2goIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHZhciBmaWVsZE5hbWUgPSBtLmZpZWxkLnN1YnN0cig1KSwgLy9yZW1vdmUgXCJkYXRhLlwiXG4gICAgICAgICAgZmllbGQgPSBcImRhdGEuXCIgKyAobS5vcCA/IG0ub3AgKyBcIl9cIiA6IFwiXCIpICsgZmllbGROYW1lO1xuICAgICAgICBzcGVjLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImZvcm11bGFcIixcbiAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgZXhwcjogXCJkMy5mb3JtYXQoJy4yZicpKGQuXCIrZmllbGQrXCIpXCJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXRhaWxzOiB1dGlsLnZhbHMoZGV0YWlsKSxcbiAgICBkaW1zOiBkaW1zLFxuICAgIGZhY2V0czogdXRpbC52YWxzKGZhY2V0cyksXG4gICAgYWdncmVnYXRlZDogbWVhcy5sZW5ndGggPiAwXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhY2tpbmcoc3BlYywgZW5jb2RpbmcsIG1kZWYsIGZhY2V0cykge1xuICBpZiAoIW1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLnN0YWNrKSByZXR1cm4gZmFsc2U7XG4gIGlmICghZW5jb2RpbmcuaGFzKENPTE9SKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkaW0gPSBYLCB2YWwgPSBZLCBpZHggPSAxO1xuICBpZiAoZW5jb2RpbmcuaXNUeXBlKFgsUXxUKSAmJiAhZW5jb2RpbmcuaXNUeXBlKFksUXxUKSAmJiBlbmNvZGluZy5oYXMoWSkpIHtcbiAgICBkaW0gPSBZO1xuICAgIHZhbCA9IFg7XG4gICAgaWR4ID0gMDtcbiAgfVxuXG4gIC8vIGFkZCB0cmFuc2Zvcm0gdG8gY29tcHV0ZSBzdW1zIGZvciBzY2FsZVxuICB2YXIgc3RhY2tlZCA9IHtcbiAgICBuYW1lOiBTVEFDS0VELFxuICAgIHNvdXJjZTogVEFCTEUsXG4gICAgdHJhbnNmb3JtOiBbe1xuICAgICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICAgIGdyb3VwYnk6IFtlbmNvZGluZy5maWVsZChkaW0pXS5jb25jYXQoZmFjZXRzKSwgLy8gZGltIGFuZCBvdGhlciBmYWNldHNcbiAgICAgIGZpZWxkczogW3tvcDogXCJzdW1cIiwgZmllbGQ6IGVuY29kaW5nLmZpZWxkKHZhbCl9XSAvLyBUT0RPIGNoZWNrIGlmIGZpZWxkIHdpdGggYWdnciBpcyBjb3JyZWN0P1xuICAgIH1dXG4gIH07XG5cbiAgaWYoZmFjZXRzICYmIGZhY2V0cy5sZW5ndGggPiAwKXtcbiAgICBzdGFja2VkLnRyYW5zZm9ybS5wdXNoKHsgLy9jYWxjdWxhdGUgbWF4IGZvciBlYWNoIGZhY2V0XG4gICAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgICAgZ3JvdXBieTogZmFjZXRzLFxuICAgICAgZmllbGRzOiBbe29wOiBcIm1heFwiLCBmaWVsZDogXCJkYXRhLnN1bV9cIiArIGVuY29kaW5nLmZpZWxkKHZhbCwgdHJ1ZSl9XVxuICAgIH0pO1xuICB9XG5cbiAgc3BlYy5kYXRhLnB1c2goc3RhY2tlZCk7XG5cbiAgLy8gYWRkIHN0YWNrIHRyYW5zZm9ybSB0byBtYXJrXG4gIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe1xuICAgIHR5cGU6IFwic3RhY2tcIixcbiAgICBwb2ludDogZW5jb2RpbmcuZmllbGQoZGltKSxcbiAgICBoZWlnaHQ6IGVuY29kaW5nLmZpZWxkKHZhbCksXG4gICAgb3V0cHV0OiB7eTE6IHZhbCwgeTA6IHZhbCtcIjJcIn1cbiAgfV07XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdXBlciBoYWNrLWlzaCAtLSBjb25zb2xpZGF0ZSBpbnRvIG1vZHVsYXIgbWFyayBwcm9wZXJ0aWVzP1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbF0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWwrXCIyXCJdID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbCtcIjJcIl0gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbCtcIjJcIn07XG5cbiAgcmV0dXJuIHZhbDsgLy9yZXR1cm4gc3RhY2sgZW5jb2Rpbmdcbn1cblxuXG5mdW5jdGlvbiBtYXJrZGVmKG1hcmssIGVuY29kaW5nLCBvcHQpIHtcbiAgdmFyIHAgPSBtYXJrLnByb3AoZW5jb2RpbmcsIG9wdClcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBtYXJrLnR5cGUsXG4gICAgZnJvbToge2RhdGE6IFRBQkxFfSxcbiAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IHAsIHVwZGF0ZTogcH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBfbmFtZTogbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgdHlwZTogXCJncm91cFwiLFxuICAgIGZyb206IG9wdC5mcm9tLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IG9wdC54IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgeTogb3B0LnkgfHwgdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogb3B0LndpZHRoIHx8IHtncm91cDogXCJ3aWR0aFwifSxcbiAgICAgICAgaGVpZ2h0OiBvcHQuaGVpZ2h0IHx8IHtncm91cDogXCJoZWlnaHRcIn1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjYWxlczogb3B0LnNjYWxlcyB8fCB1bmRlZmluZWQsXG4gICAgYXhlczogb3B0LmF4ZXMgfHwgdW5kZWZpbmVkLFxuICAgIG1hcmtzOiBvcHQubWFya3MgfHwgW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGUoZW5jb2RpbmcsIHNpemUsIHN0YXRzKSB7IC8vaGFjayB1c2Ugc3RhdHNcblxuICB2YXIgZGF0YSA9IHtuYW1lOlRBQkxFLCBmb3JtYXQ6IHt0eXBlOiBlbmNvZGluZy5jb25maWcoXCJkYXRhRm9ybWF0VHlwZVwiKX19LFxuICAgIGRhdGFVcmwgPSB2bC5kYXRhLmdldFVybChlbmNvZGluZywgc3RhdHMpO1xuICBpZihkYXRhVXJsKSBkYXRhLnVybCA9IGRhdGFVcmw7XG5cbiAgdmFyIHByZWFnZ3JlZ2F0ZWREYXRhID0gZW5jb2RpbmcuY29uZmlnKFwidXNlVmVnYVNlcnZlclwiKTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGVuY1R5cGUsIGZpZWxkKXtcbiAgICBpZihmaWVsZC50eXBlID09IFQpe1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW2ZpZWxkLm5hbWVdID0gXCJkYXRlXCI7XG4gICAgfWVsc2UgaWYoZmllbGQudHlwZSA9PSBRKXtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlID0gZGF0YS5mb3JtYXQucGFyc2UgfHwge307XG4gICAgICBpZiAoZmllbGQuYWdnciA9PT0gXCJjb3VudFwiKSB7XG4gICAgICAgIHZhciBuYW1lID0gXCJjb3VudFwiO1xuICAgICAgfSBlbHNlIGlmKHByZWFnZ3JlZ2F0ZWREYXRhICYmIGZpZWxkLmJpbil7XG4gICAgICAgIHZhciBuYW1lID0gXCJiaW5fXCIgKyBmaWVsZC5uYW1lO1xuICAgICAgfSBlbHNlIGlmKHByZWFnZ3JlZ2F0ZWREYXRhICYmIGZpZWxkLmFnZ3Ipe1xuICAgICAgICB2YXIgbmFtZSA9IGZpZWxkLmFnZ3IgKyBcIl9cIiArIGZpZWxkLm5hbWU7XG4gICAgICB9IGVsc2V7XG4gICAgICAgIHZhciBuYW1lID0gZmllbGQubmFtZTtcbiAgICAgIH1cbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlW25hbWVdID0gXCJudW1iZXJcIjtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICBwYWRkaW5nOiBcImF1dG9cIixcbiAgICBkYXRhOiBbZGF0YV0sXG4gICAgbWFya3M6IFtncm91cGRlZihcImNlbGxcIiwge1xuICAgICAgd2lkdGg6IHNpemUuY2VsbFdpZHRoID8ge3ZhbHVlOiBzaXplLmNlbGxXaWR0aH06IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogc2l6ZS5jZWxsSGVpZ2h0ID8ge3ZhbHVlOiBzaXplLmNlbGxIZWlnaHR9IDogdW5kZWZpbmVkXG4gICAgfSldXG4gIH07XG59XG4iLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuY29uc3RzLmVuY29kaW5nVHlwZXMgPSBbWCwgWSwgUk9XLCBDT0wsIFNJWkUsIFNIQVBFLCBDT0xPUiwgQUxQSEEsIFRFWFRdO1xuXG5jb25zdHMuZGF0YVR5cGVzID0ge1wiT1wiOiBPLCBcIlFcIjogUSwgXCJUXCI6IFR9O1xuXG5jb25zdHMuZGF0YVR5cGVOYW1lcyA9IFtcIk9cIixcIlFcIixcIlRcIl0ucmVkdWNlKGZ1bmN0aW9uKHIseCkge1xuICByW2NvbnN0cy5kYXRhVHlwZXNbeF1dID0geDsgcmV0dXJuIHI7XG59LHt9KTtcblxuY29uc3RzLkRFRkFVTFRTID0ge1xuICAvL3NtYWxsIG11bHRpcGxlc1xuICBjZWxsSGVpZ2h0OiAyMDAsIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoXG4gIGNlbGxXaWR0aDogMjAwLCAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aFxuICBjZWxsUGFkZGluZzogMC4xLFxuICBjZWxsQmFja2dyb3VuZENvbG9yOiBcIiNmZGZkZmRcIixcbiAgeEF4aXNNYXJnaW46IDgwLFxuICB5QXhpc01hcmdpbjogMCxcbiAgdGV4dENlbGxXaWR0aDogOTAsXG5cbiAgLy8gbWFya3NcbiAgYmFuZFNpemU6IDIxLFxuICBiYW5kUGFkZGluZzogMSxcbiAgcG9pbnRTaXplOiA1MCxcbiAgcG9pbnRTaGFwZTogXCJjaXJjbGVcIixcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIGNvbG9yOiBcInN0ZWVsYmx1ZVwiLFxuICB0ZXh0Q29sb3I6IFwiYmxhY2tcIixcbiAgdGV4dEFsaWduOiBcImxlZnRcIixcbiAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICB0ZXh0TWFyZ2luOiA0LFxuICBmb250OiBcIkhlbHZldGljYSBOZXVlXCIsXG4gIGZvbnRTaXplOiBcIjEyXCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgb3BhY2l0eTogMSxcbiAgX3RoaWNrT3BhY2l0eTogMC41LFxuICBfdGhpbk9wYWNpdHk6IDAuMixcblxuICAvLyBzY2FsZXNcbiAgLy8gVE9ETyByZW1vdmUgX3haZXJvLCAuLi5cbiAgX3haZXJvOiB0cnVlLFxuICBfeFJldmVyc2U6IGZhbHNlLFxuICBfeVplcm86IHRydWUsXG4gIF95UmV2ZXJzZTogZmFsc2UsXG4gIHRpbWVTY2FsZU5pY2U6IFwiZGF5XCJcbn07IiwiLy8gVE9ETyByZW5hbWUgZ2V0RGF0YVVybCB0byB2bC5kYXRhLmdldFVybCgpID9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIGRhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5kYXRhLmdldFVybCA9IGZ1bmN0aW9uIGdldERhdGFVcmwoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIGlmICghZW5jb2RpbmcuY29uZmlnKFwidXNlVmVnYVNlcnZlclwiKSkge1xuICAgIC8vIGRvbid0IHVzZSB2ZWdhIHNlcnZlclxuICAgIHJldHVybiBlbmNvZGluZy5jb25maWcoXCJkYXRhVXJsXCIpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmxlbmd0aCgpID09PSAwKSB7XG4gICAgLy8gbm8gZmllbGRzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpZWxkcyA9IFtdXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZW5jVHlwZSwgZmllbGQpe1xuICAgIHZhciBvYmogPSB7XG4gICAgICBuYW1lOiBlbmNvZGluZy5maWVsZChlbmNUeXBlLCB0cnVlKSxcbiAgICAgIGZpZWxkOiBmaWVsZC5uYW1lXG4gICAgfVxuICAgIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgICBvYmouYWdnciA9IGZpZWxkLmFnZ3JcbiAgICB9XG4gICAgaWYgKGZpZWxkLmJpbikge1xuICAgICAgb2JqLmJpblNpemUgPSB1dGlsLmdldGJpbnMoc3RhdHNbZmllbGQubmFtZV0pLnN0ZXA7XG4gICAgfVxuICAgIGZpZWxkcy5wdXNoKG9iaik7XG4gIH0pO1xuXG4gIHZhciBxdWVyeSA9IHtcbiAgICB0YWJsZTogZW5jb2RpbmcuY29uZmlnKFwidmVnYVNlcnZlclRhYmxlXCIpLFxuICAgIGZpZWxkczogZmllbGRzXG4gIH1cblxuICByZXR1cm4gZW5jb2RpbmcuY29uZmlnKFwidmVnYVNlcnZlclVybFwiKSArIFwiL3F1ZXJ5Lz9xPVwiICsgSlNPTi5zdHJpbmdpZnkocXVlcnkpXG59O1xuXG4vKipcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBkYXRhIGluIEpTT04vamF2YXNjcmlwdCBvYmplY3QgZm9ybWF0XG4gKiBAcmV0dXJuIEFycmF5IG9mIHtuYW1lOiBfX25hbWVfXywgdHlwZTogXCJudW1iZXJ8dGV4dHx0aW1lfGxvY2F0aW9uXCJ9XG4gKi9cbmRhdGEuZ2V0U2NoZW1hID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBzY2hlbWEgPSBbXSxcbiAgICBmaWVsZHMgPSB1dGlsLmtleXMoZGF0YVswXSk7XG5cbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oayl7XG4gICAgLy8gZmluZCBub24tbnVsbCBkYXRhXG4gICAgdmFyIGk9MCwgZGF0dW0gPSBkYXRhW2ldW2tdO1xuICAgIHdoaWxlKGRhdHVtID09PSBcIlwiIHx8IGRhdHVtID09PSBudWxsIHx8IGRhdHVtID09PSB1bmRlZmluZWQpe1xuICAgICAgZGF0dW0gPSBkYXRhWysraV1ba107XG4gICAgfVxuXG4gICAgLy9UT0RPKGthbml0dyk6IGJldHRlciB0eXBlIGluZmVyZW5jZSBoZXJlXG4gICAgdmFyIHR5cGUgPSAodHlwZW9mIGRhdHVtID09PSBcIm51bWJlclwiKSA/IFwiUVwiOlxuICAgICAgaXNOYU4oRGF0ZS5wYXJzZShkYXR1bSkpID8gXCJPXCIgOiBcIlRcIjtcblxuICAgIHNjaGVtYS5wdXNoKHtuYW1lOiBrLCB0eXBlOiB0eXBlfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG5kYXRhLmdldFN0YXRzID0gZnVuY3Rpb24oZGF0YSl7IC8vIGhhY2tcbiAgdmFyIHN0YXRzID0ge30sXG4gICAgZmllbGRzID0gdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgc3RhdCA9IHV0aWwubWlubWF4KGRhdGEsIGspO1xuICAgIHN0YXQuY2FyZGluYWxpdHkgPSB1dGlsLnVuaXEoZGF0YSwgayk7XG4gICAgc3RhdC5jb3VudCA9IGRhdGEubGVuZ3RoO1xuICAgIHN0YXRzW2tdID0gc3RhdDtcbiAgfSk7XG4gIHJldHVybiBzdGF0cztcbn07XG4iLCIvLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLlRBQkxFID0gXCJ0YWJsZVwiO1xuZy5TVEFDS0VEID0gXCJzdGFja2VkXCI7XG5nLklOREVYID0gXCJpbmRleFwiO1xuXG5nLlggPSBcInhcIjtcbmcuWSA9IFwieVwiO1xuZy5ST1cgPSBcInJvd1wiO1xuZy5DT0wgPSBcImNvbFwiO1xuZy5TSVpFID0gXCJzaXplXCI7XG5nLlNIQVBFID0gXCJzaGFwZVwiO1xuZy5DT0xPUiA9IFwiY29sb3JcIjtcbmcuQUxQSEEgPSBcImFscGhhXCI7XG5nLlRFWFQgPSBcInRleHRcIjtcblxuZy5PID0gMTtcbmcuUSA9IDI7XG5nLlQgPSA0O1xuXG4vL1RPRE8gcmVmYWN0b3IgdGhpcyB0byBiZSBjb25maWc/XG5nLk1BWF9CSU5TID0gMjA7IiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgbGVnZW5kcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmxlZ2VuZHMuZGVmcyA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHZhciBsZWdlbmRzID0gW107XG5cbiAgLy8gVE9ETzogc3VwcG9ydCBhbHBoYVxuXG4gIGlmIChlbmNvZGluZy5oYXMoQ09MT1IpICYmIGVuY29kaW5nLmxlZ2VuZChDT0xPUikpIHtcbiAgICBsZWdlbmRzLnB1c2goe1xuICAgICAgZmlsbDogQ09MT1IsXG4gICAgICB0aXRsZTogZW5jb2RpbmcuZmllbGRUaXRsZShDT0xPUiksXG4gICAgICBvcmllbnQ6IFwicmlnaHRcIlxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmhhcyhTSVpFKSAmJiBlbmNvZGluZy5sZWdlbmQoU0laRSkpIHtcbiAgICBsZWdlbmRzLnB1c2goe1xuICAgICAgc2l6ZTogU0laRSxcbiAgICAgIHRpdGxlOiBlbmNvZGluZy5maWVsZFRpdGxlKFNJWkUpLFxuICAgICAgb3JpZW50OiBsZWdlbmRzLmxlbmd0aCA9PT0gMSA/IFwibGVmdFwiIDogXCJyaWdodFwiXG4gICAgfSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNIQVBFKSAmJiBlbmNvZGluZy5sZWdlbmQoU0hBUEUpKSB7XG4gICAgaWYgKGxlZ2VuZHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBUT0RPOiBmaXggdGhpc1xuICAgICAgY29uc29sZS5lcnJvcihcIlZlZ2FsaXRlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHR3byBsZWdlbmRzXCIpO1xuICAgICAgcmV0dXJuIGxlZ2VuZHM7XG4gICAgfVxuICAgIGxlZ2VuZHMucHVzaCh7XG4gICAgICBzaGFwZTogU0hBUEUsXG4gICAgICB0aXRsZTogZW5jb2RpbmcuZmllbGRUaXRsZShTSEFQRSksXG4gICAgICBvcmllbnQ6IGxlZ2VuZHMubGVuZ3RoID09PSAxID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCJcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsZWdlbmRzO1xufSIsInZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKSxcbiAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBtYXJrcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbm1hcmtzLmJhciA9IHtcbiAgdHlwZTogXCJyZWN0XCIsXG4gIHN0YWNrOiB0cnVlLFxuICBwcm9wOiBiYXJfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFtcInhcIiwgXCJ5XCJdLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzoxLCBjb2w6MSwgeDoxLCB5OjEsIHNpemU6MSwgY29sb3I6MSwgYWxwaGE6MX1cbn07XG5cbm1hcmtzLmxpbmUgPSB7XG4gIHR5cGU6IFwibGluZVwiLFxuICBsaW5lOiB0cnVlLFxuICBwcm9wOiBsaW5lX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbXCJ4XCIsIFwieVwiXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6MSwgY29sOjEsIHg6MSwgeToxLCBjb2xvcjoxLCBhbHBoYToxfVxufTtcblxubWFya3MuYXJlYSA9IHtcbiAgdHlwZTogXCJhcmVhXCIsXG4gIHN0YWNrOiB0cnVlLFxuICBsaW5lOiB0cnVlLFxuICByZXF1aXJlZEVuY29kaW5nOiBbXCJ4XCIsIFwieVwiXSxcbiAgcHJvcDogYXJlYV9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IG1hcmtzLmxpbmUuc3VwcG9ydGVkRW5jb2Rpbmdcbn07XG5cbm1hcmtzLmNpcmNsZSA9IHtcbiAgdHlwZTogXCJzeW1ib2xcIixcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKFwiY2lyY2xlXCIpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzoxLCBjb2w6MSwgeDoxLCB5OjEsIHNpemU6MSwgY29sb3I6MSwgYWxwaGE6MX1cbn07XG5cbm1hcmtzLnNxdWFyZSA9IHtcbiAgdHlwZTogXCJzeW1ib2xcIixcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKFwic3F1YXJlXCIpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzogbWFya3MuY2lyY2xlLnN1cHBvcnRlZEVuY29kaW5nXG59O1xuXG5tYXJrcy5wb2ludCA9IHtcbiAgdHlwZTogXCJzeW1ib2xcIixcbiAgcHJvcDogcG9pbnRfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OjEsIGNvbDoxLCB4OjEsIHk6MSwgc2l6ZToxLCBjb2xvcjoxLCBhbHBoYToxLCBzaGFwZToxfVxufTtcblxubWFya3MudGV4dCA9IHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIHByb3A6IHRleHRfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFtcInRleHRcIl0sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OjEsIGNvbDoxLCBzaXplOjEsIGNvbG9yOjEsIGFscGhhOjEsIHRleHQ6MX1cbn07XG5cbmZ1bmN0aW9uIGJhcl9wcm9wcyhlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5pc1R5cGUoWCxRfFQpICYmICFlLmJpbihYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmhhcyhZKSAmJiAoIWUuaXNUeXBlKFksUXxUKSB8fCBlLmJpbihZKSkpIHtcbiAgICAgIHAueDIgPSB7c2NhbGU6IFgsIHZhbHVlOiAwfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnhjID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gIH0gZWxzZSB7XG4gICAgcC54YyA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmlzVHlwZShZLFF8VCkgJiYgIWUuYmluKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gICAgcC55MiA9IHtzY2FsZTogWSwgdmFsdWU6IDB9O1xuICB9IGVsc2UgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIHAueWMgPSB7Z3JvdXA6IFwiaGVpZ2h0XCJ9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmlzVHlwZShYLFF8VCkpIHtcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAud2lkdGggPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcC53aWR0aCA9IHtzY2FsZTogWCwgYmFuZDogdHJ1ZSwgb2Zmc2V0OiAtMX07XG4gICAgICBwLndpZHRoID0ge3ZhbHVlOiArZS5jb25maWcoXCJiYW5kU2l6ZVwiKSwgb2Zmc2V0OiAtMX07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmlzVHlwZShZLE8pICYmICFlLmJpbihZKSkge1xuICAgIHAud2lkdGggPSB7dmFsdWU6ICtlLmNvbmZpZyhcImJhbmRTaXplXCIpLCBvZmZzZXQ6IC0xfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaXNUeXBlKFksUXxUKSkge1xuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5oZWlnaHQgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcC5oZWlnaHQgPSB7c2NhbGU6IFksIGJhbmQ6IHRydWUsIG9mZnNldDogLTF9O1xuICAgICAgcC5oZWlnaHQgPSB7dmFsdWU6ICtlLmNvbmZpZyhcImJhbmRTaXplXCIpLCBvZmZzZXQ6IC0xfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWUuaXNUeXBlKFgsTykgJiYgIWUuYmluKFgpKSB7XG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6ICtlLmNvbmZpZyhcImJhbmRTaXplXCIpLCBvZmZzZXQ6IC0xfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS5jb25maWcoXCJjb2xvclwiKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwb2ludF9wcm9wcyhlLCBvcHQpIHtcbiAgdmFyIHAgPSB7fTtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3ZhbHVlOiBlLmNvbmZpZyhcImJhbmRTaXplXCIpLzJ9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuY29uZmlnKFwiYmFuZFNpemVcIikvMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS5jb25maWcoXCJwb2ludFNpemVcIil9O1xuICB9XG5cbiAgLy8gc2hhcGVcbiAgaWYgKGUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7c2NhbGU6IFNIQVBFLCBmaWVsZDogZS5maWVsZChTSEFQRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBlLmNvbmZpZyhcInBvaW50U2hhcGVcIil9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLmNvbmZpZyhcImNvbG9yXCIpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9ZWxzZXtcbiAgICBwLm9wYWNpdHkgPSB7XG4gICAgICB2YWx1ZTogZS5jb25maWcoXCJvcGFjaXR5XCIpIHx8IGUuY29uZmlnKG9wdC5oYXNBZ2dyZWdhdGUgPyBcIl90aGlja09wYWNpdHlcIiA6IFwiX3RoaW5PcGFjaXR5XCIpXG4gICAgfTtcbiAgfVxuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKFwic3Ryb2tlV2lkdGhcIil9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBsaW5lX3Byb3BzKGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHtncm91cDogXCJoZWlnaHRcIn07XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7dmFsdWU6IGUuY29uZmlnKFwiY29sb3JcIil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH1cblxuICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZyhcInN0cm9rZVdpZHRoXCIpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYXJlYV9wcm9wcyhlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5pc1R5cGUoWCxRfFQpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgaWYgKCFlLmlzVHlwZShZLFF8VCkgJiYgZS5oYXMoWSkpIHtcbiAgICAgIHAueDIgPSB7c2NhbGU6IFgsIHZhbHVlOiAwfTtcbiAgICAgIHAub3JpZW50ID0ge3ZhbHVlOiBcImhvcml6b250YWxcIn07XG4gICAgfVxuICB9IGVsc2UgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gIH0gZWxzZSB7XG4gICAgcC54ID0ge3ZhbHVlOiAwfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaXNUeXBlKFksUXxUKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIHAueTIgPSB7c2NhbGU6IFksIHZhbHVlOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIHAueSA9IHtncm91cDogXCJoZWlnaHRcIn07XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS5jb25maWcoXCJjb2xvclwiKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBmaWxsZWRfcG9pbnRfcHJvcHMoc2hhcGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUsIG9wdCkge1xuICAgIHZhciBwID0ge307XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgLy8geFxuICAgIGlmIChlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5jb25maWcoXCJiYW5kU2l6ZVwiKS8yfTtcbiAgICB9XG5cbiAgICAvLyB5XG4gICAgaWYgKGUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3ZhbHVlOiBlLmNvbmZpZyhcImJhbmRTaXplXCIpLzJ9O1xuICAgIH1cblxuICAgIC8vIHNpemVcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnNpemUgPSB7dmFsdWU6IGUuY29uZmlnKFwicG9pbnRTaXplXCIpfTtcbiAgICB9XG5cbiAgICAvLyBzaGFwZVxuICAgIHAuc2hhcGUgPSB7dmFsdWU6IHNoYXBlfTtcblxuICAgIC8vIGZpbGxcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3ZhbHVlOiBlLmNvbmZpZyhcImNvbG9yXCIpfTtcbiAgICB9XG5cbiAgICAvLyBhbHBoYVxuICAgIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gICAgfWVsc2Uge1xuICAgICAgcC5vcGFjaXR5ID0ge1xuICAgICAgICB2YWx1ZTogZS5jb25maWcoXCJvcGFjaXR5XCIpIHx8IGUuY29uZmlnKG9wdC5oYXNBZ2dyZWdhdGUgPyBcIl90aGlja09wYWNpdHlcIiA6IFwiX3RoaW5PcGFjaXR5XCIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5jb25maWcoXCJiYW5kU2l6ZVwiKS8yfTtcbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiBlLmNvbmZpZyhcImJhbmRTaXplXCIpLzJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgcC5mb250U2l6ZSA9IHt2YWx1ZTogZS5jb25maWcoXCJmb250U2l6ZVwiKX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUuY29uZmlnKFwidGV4dENvbG9yXCIpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9XG5cbiAgLy8gdGV4dFxuICBpZiAoZS5oYXMoVEVYVCkpIHtcbiAgICBwLnRleHQgPSB7ZmllbGQ6IGUuZmllbGQoVEVYVCl9O1xuICB9IGVsc2Uge1xuICAgIHAudGV4dCA9IHt2YWx1ZTogXCJBYmNcIn07XG4gIH1cblxuICBwLmZvbnQgPSB7dmFsdWU6IGUuY29uZmlnKFwiZm9udFwiKX07XG4gIHAuZm9udFdlaWdodCA9IHt2YWx1ZTogZS5jb25maWcoXCJmb250V2VpZ2h0XCIpfTtcbiAgcC5mb250U3R5bGUgPSB7dmFsdWU6IGUuY29uZmlnKFwiZm9udFN0eWxlXCIpfTtcbiAgcC5iYXNlbGluZSA9IHt2YWx1ZTogZS5jb25maWcoXCJ0ZXh0QmFzZWxpbmVcIil9O1xuXG4gIC8vIGFsaWduXG4gIGlmIChlLmhhcyhYKSkge1xuICAgIGlmIChlLmlzVHlwZShYLE8pKSB7XG4gICAgICBwLmFsaWduID0ge3ZhbHVlOiBcImxlZnRcIn07XG4gICAgICBwLmR4ID0ge3ZhbHVlOiBlLmNvbmZpZyhcInRleHRNYXJnaW5cIil9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLmFsaWduID0ge3ZhbHVlOiBcImNlbnRlclwifVxuICAgIH1cbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkge1xuICAgIHAuYWxpZ24gPSB7dmFsdWU6IFwibGVmdFwifTtcbiAgICBwLmR4ID0ge3ZhbHVlOiBlLmNvbmZpZyhcInRleHRNYXJnaW5cIil9O1xuICB9IGVsc2Uge1xuICAgIHAuYWxpZ24gPSB7dmFsdWU6IGUuY29uZmlnKFwidGV4dEFsaWduXCIpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufSIsInZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKSxcbiAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBzY2FsZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnNjYWxlLm5hbWVzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIGlmIChwcm9wc1t4XSAmJiBwcm9wc1t4XS5zY2FsZSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufVxuXG5zY2FsZS5kZWZzID0gZnVuY3Rpb24gKG5hbWVzLCBlbmNvZGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGEsIG5hbWUpIHtcbiAgICB2YXIgcyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0eXBlOiBzY2FsZV90eXBlKG5hbWUsIGVuY29kaW5nKSxcbiAgICAgIGRvbWFpbjogc2NhbGVfZG9tYWluKG5hbWUsIGVuY29kaW5nLCBvcHQpXG4gICAgfTtcbiAgICBpZiAocy50eXBlID09PSBcIm9yZGluYWxcIiAmJiAhZW5jb2RpbmcuYmluKG5hbWUpKSB7XG4gICAgICBzLnNvcnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNjYWxlX3JhbmdlKHMsIGVuY29kaW5nLCBvcHQpO1xuXG4gICAgcmV0dXJuIChhLnB1c2gocyksIGEpO1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlX3R5cGUobmFtZSwgZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChlbmNvZGluZy50eXBlKG5hbWUpKSB7XG4gICAgY2FzZSBPOiByZXR1cm4gXCJvcmRpbmFsXCI7XG4gICAgY2FzZSBUOlxuICAgICAgaWYgKGVuY29kaW5nLmZuKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBcImxpbmVhclwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwidGltZVwiO1xuICAgIGNhc2UgUTpcbiAgICAgIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwib3JkaW5hbFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kaW5nLnNjYWxlKG5hbWUpLnR5cGUgfHwgXCJsaW5lYXJcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2FsZV9kb21haW4obmFtZSwgZW5jb2RpbmcsIG9wdCkge1xuICBpZiAoZW5jb2RpbmcudHlwZShuYW1lKSA9PT0gVCl7XG4gICAgc3dpdGNoKGVuY29kaW5nLmZuKG5hbWUpKXtcbiAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgIGNhc2UgXCJtaW51dGVcIjogcmV0dXJuIFswLCA1OV07XG4gICAgICBjYXNlIFwiaG91clwiOiByZXR1cm4gWzAsIDIzXTtcbiAgICAgIGNhc2UgXCJkYXlcIjogcmV0dXJuIFswLCA2XTtcbiAgICAgIGNhc2UgXCJkYXRlXCI6IHJldHVybiBbMSwgMzFdO1xuICAgICAgY2FzZSBcIm1vbnRoXCI6IHJldHVybiBbMCwgMTFdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAvLyBUT0RPOiBhZGQgaW5jbHVkZUVtcHR5Q29uZmlnIGhlcmVcbiAgICBpZiAob3B0LnN0YXRzKSB7XG4gICAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhvcHQuc3RhdHNbZW5jb2RpbmcuZmllbGROYW1lKG5hbWUpXSk7XG4gICAgICB2YXIgZG9tYWluID0gdXRpbC5yYW5nZShiaW5zLnN0YXJ0LCBiaW5zLnN0b3AsIGJpbnMuc3RlcCk7XG4gICAgICByZXR1cm4gbmFtZT09PVkgPyBkb21haW4ucmV2ZXJzZSgpIDogZG9tYWluO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lID09IG9wdC5zdGFjayA/XG4gICAge1xuICAgICAgZGF0YTogU1RBQ0tFRCxcbiAgICAgIGZpZWxkOiBcImRhdGEuXCIgKyAob3B0LmZhY2V0ID8gXCJtYXhfXCIgOlwiXCIpICsgXCJzdW1fXCIgKyBlbmNvZGluZy5maWVsZChuYW1lLCB0cnVlKVxuICAgIH06XG4gICAge2RhdGE6IFRBQkxFLCBmaWVsZDogZW5jb2RpbmcuZmllbGQobmFtZSl9O1xufVxuXG5mdW5jdGlvbiBzY2FsZV9yYW5nZShzLCBlbmNvZGluZywgb3B0KSB7XG4gIHZhciBzcGVjID0gZW5jb2Rpbmcuc2NhbGUocy5uYW1lKTtcbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFg6XG4gICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSwgTykgfHwgZW5jb2RpbmcuYmluKHMubmFtZSkpIHtcbiAgICAgICAgcy5iYW5kV2lkdGggPSArZW5jb2RpbmcuY29uZmlnKFwiYmFuZFNpemVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gb3B0LmNlbGxXaWR0aCA/IFswLCBvcHQuY2VsbFdpZHRoXSA6IFwid2lkdGhcIjtcbiAgICAgICAgLy9UT0RPIHplcm8gYW5kIHJldmVyc2Ugc2hvdWxkIGJlY29tZSBnZW5lcmljLCBhbmQgd2UganVzdCByZWFkIGRlZmF1bHQgZnJvbSBlaXRoZXIgdGhlIHNjaGVtYSBvciB0aGUgc2NoZW1hIGdlbmVyYXRvclxuICAgICAgICBzLnplcm8gPSBzcGVjLnplcm8gfHwgZW5jb2RpbmcuY29uZmlnKFwiX3haZXJvXCIpO1xuICAgICAgICBzLnJldmVyc2UgPSBzcGVjLnJldmVyc2UgfHwgZW5jb2RpbmcuY29uZmlnKFwiX3hSZXZlcnNlXCIpO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSwgVCkpe1xuICAgICAgICBzLm5pY2UgPSBlbmNvZGluZy5hZ2dyKHMubmFtZSkgfHwgZW5jb2RpbmcuY29uZmlnKFwidGltZVNjYWxlTmljZVwiKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsIE8pIHx8IGVuY29kaW5nLmJpbihzLm5hbWUpKSB7XG4gICAgICAgIHMuYmFuZFdpZHRoID0gK2VuY29kaW5nLmNvbmZpZyhcImJhbmRTaXplXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5yYW5nZSA9IG9wdC5jZWxsSGVpZ2h0ID8gW29wdC5jZWxsSGVpZ2h0LCAwXSA6IFwiaGVpZ2h0XCI7XG4gICAgICAgIC8vVE9ETyB6ZXJvIGFuZCByZXZlcnNlIHNob3VsZCBiZWNvbWUgZ2VuZXJpYywgYW5kIHdlIGp1c3QgcmVhZCBkZWZhdWx0IGZyb20gZWl0aGVyIHRoZSBzY2hlbWEgb3IgdGhlIHNjaGVtYSBnZW5lcmF0b3JcbiAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvIHx8IGVuY29kaW5nLmNvbmZpZyhcIl95WmVyb1wiKTtcbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlIHx8IGVuY29kaW5nLmNvbmZpZyhcIl95UmV2ZXJzZVwiKTtcbiAgICAgIH1cblxuICAgICAgcy5yb3VuZCA9IHRydWU7XG5cbiAgICAgIGlmIChlbmNvZGluZy5pc1R5cGUocy5uYW1lLCBUKSl7XG4gICAgICAgIHMubmljZSA9IGVuY29kaW5nLmFnZ3Iocy5uYW1lKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBST1c6XG4gICAgICBzLmJhbmRXaWR0aCA9IG9wdC5jZWxsSGVpZ2h0IHx8IGVuY29kaW5nLmNvbmZpZyhcImNlbGxIZWlnaHRcIik7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTDpcbiAgICAgIHMuYmFuZFdpZHRoID0gb3B0LmNlbGxXaWR0aCB8fCBlbmNvZGluZy5jb25maWcoXCJjZWxsV2lkdGhcIik7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNJWkU6XG4gICAgICBpZiAoZW5jb2RpbmcuaXMoXCJiYXJcIikpIHtcbiAgICAgICAgcy5yYW5nZSA9IFszLCArZW5jb2RpbmcuY29uZmlnKFwiYmFuZFNpemVcIildO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5pcyhURVhUKSkge1xuICAgICAgICBzLnJhbmdlID0gWzgsIDQwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMucmFuZ2UgPSBbMTAsIDEwMDBdO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0hBUEU6XG4gICAgICBzLnJhbmdlID0gXCJzaGFwZXNcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MT1I6XG4gICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSwgTykpIHtcbiAgICAgICAgcy5yYW5nZSA9IFwiY2F0ZWdvcnkxMFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5yYW5nZSA9IFtcIiNkZGZcIiwgXCJzdGVlbGJsdWVcIl07XG4gICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBTFBIQTpcbiAgICAgIHMucmFuZ2UgPSBbMC4yLCAxLjBdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmcgbmFtZTogXCIrcy5uYW1lKTtcbiAgfVxuXG4gIHN3aXRjaChzLm5hbWUpe1xuICAgIGNhc2UgUk9XOlxuICAgIGNhc2UgQ09MOlxuICAgICAgcy5wYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKFwiY2VsbFBhZGRpbmdcIik7XG4gICAgICBzLm91dGVyUGFkZGluZyA9IDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFg6XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsIE8pIHx8IGVuY29kaW5nLmJpbihzLm5hbWUpICkgeyAvLyYmICFzLmJhbmRXaWR0aFxuICAgICAgICBzLnBvaW50cyA9IHRydWU7XG4gICAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZyhcImJhbmRQYWRkaW5nXCIpO1xuICAgICAgfVxuICB9XG59IiwiLy8gUGFja2FnZSBvZiBkZWZpbmluZyBWZWdhbGl0ZSBTcGVjaWZpY2F0aW9uJ3MganNvbiBzY2hlbWFcbi8vXG52YXIgc2NoZW1hID0gbW9kdWxlLmV4cG9ydHMgPSB7fSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5zY2hlbWEudXRpbCA9IHJlcXVpcmUoJy4vc2NoZW1hdXRpbCcpO1xuXG5zY2hlbWEubWFya3R5cGUgPSB7XG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIGVudW06IFtcInBvaW50XCIsIFwiYmFyXCIsIFwibGluZVwiLCBcImFyZWFcIiwgXCJjaXJjbGVcIiwgXCJzcXVhcmVcIiwgXCJ0ZXh0XCJdXG59O1xuXG5zY2hlbWEuYWdnciA9IHtcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgZW51bTogW1wiYXZnXCIsIFwic3VtXCIsIFwibWluXCIsIFwibWF4XCIsIFwiY291bnRcIl0sXG4gIHN1cHBvcnRlZEVudW1zOiB7XG4gICAgUTogW1wiYXZnXCIsIFwic3VtXCIsIFwibWluXCIsIFwibWF4XCIsIFwiY291bnRcIl0sXG4gICAgTzogW1wiY291bnRcIl0sXG4gICAgVDogW1wiYXZnXCIsIFwibWluXCIsIFwibWF4XCIsIFwiY291bnRcIl0sXG4gICAgXCJcIjogW1wiY291bnRcIl0sXG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB7XCJRXCI6IHRydWUsIFwiT1wiOiB0cnVlLCBcIlRcIjogdHJ1ZSwgXCJcIjogdHJ1ZX1cbn07XG5cbnNjaGVtYS50aW1lZm5zID0gW1wibW9udGhcIiwgXCJ5ZWFyXCIsIFwiZGF5XCIsIFwiZGF0ZVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIl07XG5cbnNjaGVtYS5mbiA9IHtcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgZW51bTogc2NoZW1hLnRpbWVmbnMsXG4gIHN1cHBvcnRlZFR5cGVzOiB7XCJUXCI6IHRydWV9XG59XG5cbi8vVE9ETyhrYW5pdHcpOiBhZGQgb3RoZXIgdHlwZSBvZiBmdW5jdGlvbiBoZXJlXG5cbnNjaGVtYS5zY2FsZV90eXBlID0ge1xuICB0eXBlOiBcInN0cmluZ1wiLFxuICBlbnVtOiBbXCJsaW5lYXJcIiwgXCJsb2dcIixcInBvd1wiLCBcInNxcnRcIiwgXCJxdWFudGlsZVwiXSxcbiAgZGVmYXVsdDogXCJsaW5lYXJcIixcbiAgc3VwcG9ydGVkVHlwZXM6IHtcIlFcIjogdHJ1ZX1cbn07XG5cbnNjaGVtYS5maWVsZCA9IHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcmVxdWlyZWQ6IFtcIm5hbWVcIiwgXCJ0eXBlXCJdLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgIH1cbiAgfVxufTtcblxudmFyIGNsb25lID0gdXRpbC5kdXBsaWNhdGU7XG52YXIgbWVyZ2UgPSBzY2hlbWEudXRpbC5tZXJnZTtcblxudmFyIHR5cGljYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBlbnVtOiBbXCJPXCIsIFwiUVwiLCBcIlRcIl1cbiAgICB9LFxuICAgIGJpbjoge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIHN1cHBvcnRlZFR5cGVzOiB7XCJRXCI6IHRydWUsIFwiT1wiOiB0cnVlfVxuICAgIH0sXG4gICAgYWdncjogc2NoZW1hLmFnZ3IsXG4gICAgZm46IHNjaGVtYS5mbixcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogc2NoZW1hLnNjYWxlX3R5cGUsXG4gICAgICAgIHJldmVyc2U6IHsgdHlwZTogXCJib29sZWFuXCIsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHplcm86IHtcbiAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJbmNsdWRlIHplcm9cIixcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczoge1wiUVwiOiB0cnVlfVxuICAgICAgICB9LFxuICAgICAgICBuaWNlOiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBlbnVtOiBbXCJzZWNvbmRcIiwgXCJtaW51dGVcIiwgXCJob3VyXCIsIFwiZGF5XCIsIFwid2Vla1wiLCBcIm1vbnRoXCIsIFwieWVhclwiXSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczoge1wiVFwiOiB0cnVlfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIG9ubHlPcmRpbmFsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZW51bTogW1wiT1wiXVxuICAgIH0sXG4gICAgYmluOiB7XG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgc3VwcG9ydGVkVHlwZXM6IHtcIk9cIjogdHJ1ZX1cbiAgICB9LFxuICAgIGFnZ3I6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBlbnVtOiBbXCJjb3VudFwiXSxcbiAgICAgIHN1cHBvcnRlZFR5cGVzOiB7XCJPXCI6IHRydWV9XG4gICAgfVxuICB9XG59KTtcblxudmFyIGF4aXNNaXhpbiA9IHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcHJvcGVydGllczoge1xuICAgIGF4aXM6IHtcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGdyaWQ6IHsgdHlwZTogXCJib29sZWFuXCIsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHRpdGxlOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBkZWZhdWx0OiB0cnVlIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGxlZ2VuZE1peGluID0ge1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbGVnZW5kOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBkZWZhdWx0OiB0cnVlIH1cbiAgfVxufVxuXG52YXIgdGV4dE1peGluID0ge1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdGV4dDoge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgd2VpZ2h0OiB7XG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBlbnVtOiBbXCJub3JtYWxcIiwgXCJib2xkXCJdLFxuICAgICAgICAgIGRlZmF1bHQ6IFwibm9ybWFsXCIsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHtcIlRcIjogdHJ1ZX1cbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICAgIG1pbmltdW06IDAsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHtcIlRcIjogdHJ1ZX1cbiAgICAgICAgfSxcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgZGVmYXVsdDogXCJIYWx2ZXRpY2EgTmV1ZVwiLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7XCJUXCI6IHRydWV9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHggPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCBheGlzTWl4aW4pO1xudmFyIHkgPSBjbG9uZSh4KTtcblxudmFyIHJvdyA9IGNsb25lKG9ubHlPcmRpbmFsRmllbGQpO1xudmFyIGNvbCA9IGNsb25lKHJvdyk7XG5cbnZhciBzaXplID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwgbGVnZW5kTWl4aW4pO1xudmFyIGNvbG9yID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwgbGVnZW5kTWl4aW4pO1xudmFyIGFscGhhID0gY2xvbmUodHlwaWNhbEZpZWxkKTtcbnZhciBzaGFwZSA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBsZWdlbmRNaXhpbik7XG5cbnZhciB0ZXh0ID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwgdGV4dE1peGluKTtcblxudmFyIGNmZyA9IHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgcHJvcGVydGllczoge1xuICAgIC8vIHRlbXBsYXRlXG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2aWV3cG9ydDoge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogW1wiaW50ZWdlclwiXVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgX21pbldpZHRoOiB7XG4gICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgIGRlZmF1bHQ6IDIwXG4gICAgfSxcbiAgICBfbWluSGVpZ2h0OiB7XG4gICAgICB0eXBlOiBcImludGVnZXJcIixcbiAgICAgIGRlZmF1bHQ6IDIwXG4gICAgfSxcblxuICAgIC8vIGRhdGEgc291cmNlXG4gICAgZGF0YUZvcm1hdFR5cGU6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBlbnVtOiBbXCJqc29uXCIsIFwiY3N2XCJdLFxuICAgICAgZGVmYXVsdDogXCJqc29uXCJcbiAgICB9LFxuICAgIHVzZVZlZ2FTZXJ2ZXI6IHtcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRhdGFVcmw6IHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZlZ2FTZXJ2ZXJUYWJsZToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmVnYVNlcnZlclVybDoge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGRlZmF1bHQ6IFwiaHR0cDovL2xvY2FsaG9zdDozMDAxXCJcbiAgICB9XG4gIH1cbn1cblxuLyoqIEB0eXBlIE9iamVjdCBTY2hlbWEgb2YgYSB2ZWdhbGl0ZSBzcGVjaWZpY2F0aW9uICovXG5zY2hlbWEuc2NoZW1hID0ge1xuICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICByZXF1aXJlZDogW1wibWFya3R5cGVcIiwgXCJlbmNcIiwgXCJjZmdcIl0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXJrdHlwZTogc2NoZW1hLm1hcmt0eXBlLFxuICAgIGVuYzoge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbDogY29sLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICB9XG4gICAgfSxcbiAgICBjZmc6IGNmZ1xuICB9XG59O1xuXG4vKiogSW5zdGFudGlhdGUgYSB2ZXJib3NlIHZsIHNwZWMgZnJvbSB0aGUgc2NoZW1hICovXG5zY2hlbWEuaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYSk7XG59XG4iLCJ2YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMFxufVxuXG4vLyBpbnN0YW50aWF0ZSBhIHNjaGVtYVxudXRpbC5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKHNjaGVtYSwgcmVxdWlyZWQpIHtcbiAgaWYgKHNjaGVtYS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHNjaGVtYS5yZXF1aXJlZCA9IHNjaGVtYS5yZXF1aXJlZCA/IHNjaGVtYS5yZXF1aXJlZCA6IFtdO1xuICAgIHZhciBpbnN0YW5jZSA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBjaGlsZCA9IHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgaW5zdGFuY2VbbmFtZV0gPSB1dGlsLmluc3RhbnRpYXRlKGNoaWxkLCBzY2hlbWEucmVxdWlyZWQuaW5kZXhPZihuYW1lKSAhPSAtMSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEuZGVmYXVsdDtcbiAgfSBlbHNlIGlmIChzY2hlbWEuZW51bSAmJiByZXF1aXJlZCkge1xuICAgIHJldHVybiBzY2hlbWEuZW51bVswXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gcmVtb3ZlIGFsbCBkZWZhdWx0cyBmcm9tIGFuIGluc3RhbmNlXG51dGlsLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihkZWZhdWx0cywgaW5zdGFuY2UpIHtcbiAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBpbnN0YW5jZSkge1xuICAgIGlmICghZGVmYXVsdHMgfHwgZGVmYXVsdHNbcHJvcF0gIT09IGluc3RhbmNlW3Byb3BdKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlW3Byb3BdID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIGMgPSB1dGlsLmRpZmZlcmVuY2UoZGVmYXVsdHNbcHJvcF0sIGluc3RhbmNlW3Byb3BdKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGMpKVxuICAgICAgICAgIGNoYW5nZXNbcHJvcF0gPSBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IGluc3RhbmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbi8vIHJlY3Vyc2l2ZWx5IG1lcmdlcyBpbnN0YW5jZSBpbnRvIGRlZmF1bHRzXG51dGlsLm1lcmdlID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBpbnN0YW5jZSkge1xuICBpZiAodHlwZW9mIGluc3RhbmNlIT09J29iamVjdCcgfHwgaW5zdGFuY2U9PT1udWxsKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9XG5cbiAgZm9yICh2YXIgcCBpbiBpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UuaGFzT3duUHJvcGVydHkocCkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoaW5zdGFuY2VbcF09PT11bmRlZmluZWQgKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZVtwXSAhPT0gJ29iamVjdCcgfHwgaW5zdGFuY2VbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRzW3BdID0gaW5zdGFuY2VbcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdHNbcF0gIT09ICdvYmplY3QnIHx8IGRlZmF1bHRzW3BdID09PSBudWxsKSB7XG4gICAgICBkZWZhdWx0c1twXSA9IHV0aWwubWVyZ2UoaW5zdGFuY2VbcF0uY29uc3RydWN0b3IgPT09IEFycmF5ID8gW10gOiB7fSwgaW5zdGFuY2VbcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLm1lcmdlKGRlZmF1bHRzW3BdLCBpbnN0YW5jZVtwXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cbiIsInZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudXRpbC5rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgayA9IFtdLCB4O1xuICBmb3IgKHggaW4gb2JqKSBrLnB1c2goeCk7XG4gIHJldHVybiBrO1xufVxuXG51dGlsLnZhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciB2ID0gW10sIHg7XG4gIGZvciAoeCBpbiBvYmopIHYucHVzaChvYmpbeF0pO1xuICByZXR1cm4gdjtcbn1cblxudXRpbC5yYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBzdGVwID0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKFwiaW5maW5pdGUgcmFuZ2VcIik7XG4gIHZhciByYW5nZSA9IFtdLCBpID0gLTEsIGo7XG4gIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIHJldHVybiByYW5nZTtcbn1cblxudXRpbC5maW5kID0gZnVuY3Rpb24gKGxpc3QsIHBhdHRlcm4pIHtcbiAgdmFyIGwgPSBsaXN0LmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHhbcGF0dGVybi5uYW1lXSA9PT0gcGF0dGVybi52YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBsLmxlbmd0aCAmJiBsWzBdIHx8IG51bGw7XG59XG5cbnV0aWwudW5pcSA9IGZ1bmN0aW9uIChkYXRhLCBmaWVsZCkge1xuICB2YXIgbWFwID0ge30sIGNvdW50ID0gMCwgaSwgaztcbiAgZm9yIChpPTA7IGk8ZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGsgPSBkYXRhW2ldW2ZpZWxkXTtcbiAgICBpZiAoIW1hcFtrXSkge1xuICAgICAgbWFwW2tdID0gMTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxudXRpbC5taW5tYXggPSBmdW5jdGlvbiAoZGF0YSwgZmllbGQpIHtcbiAgdmFyIHN0YXRzID0ge21pbjogK0luZmluaXR5LCBtYXg6IC1JbmZpbml0eX07XG4gIGZvciAoaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdiA9IGRhdGFbaV1bZmllbGRdO1xuICAgIGlmICh2ID4gc3RhdHMubWF4KSBzdGF0cy5tYXggPSB2O1xuICAgIGlmICh2IDwgc3RhdHMubWluKSBzdGF0cy5taW4gPSB2O1xuICB9XG4gIHJldHVybiBzdGF0cztcbn1cblxudXRpbC5kdXBsaWNhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudXRpbC5hbnkgPSBmdW5jdGlvbihhcnIsIGYpe1xuICB2YXIgaT0wLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYoZihhcnJba10sIGssIGkrKykpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudXRpbC5hbGwgPSBmdW5jdGlvbihhcnIsIGYpe1xuICB2YXIgaT0wLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYoIWYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnV0aWwubWVyZ2UgPSBmdW5jdGlvbihkZXN0LCBzcmMpe1xuICByZXR1cm4gdXRpbC5rZXlzKHNyYykucmVkdWNlKGZ1bmN0aW9uKGMsIGspe1xuICAgIGNba10gPSBzcmNba107XG4gICAgcmV0dXJuIGM7XG4gIH0sIGRlc3QpO1xufTtcblxudXRpbC5nZXRiaW5zID0gZnVuY3Rpb24gKHN0YXRzKSB7XG4gIHJldHVybiB2Zy5iaW5zKHtcbiAgICBtaW46IHN0YXRzLm1pbixcbiAgICBtYXg6IHN0YXRzLm1heCxcbiAgICBtYXhiaW5zOiBNQVhfQklOU1xuICB9KTtcbn1cblxuXG51dGlsLmVycm9yID0gZnVuY3Rpb24obXNnKXtcbiAgY29uc29sZS5lcnJvcihcIltWTCBFcnJvcl1cIiwgbXNnKTtcbn1cblxuIl19\n","\"use strict\";\n\nvar global = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  schema = require('./schema');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config) {\n    // TODO: caching\n    var encDefaults = schema.util.instantiate(schema.schema.properties.enc);\n    var cfgDefaults = schema.util.instantiate(schema.schema.properties.cfg);\n\n    // Hack\n    for (var k in consts.DEFAULTS) {\n      cfgDefaults[k] = consts.DEFAULTS[k];\n    }\n\n    // remove field defs that we don't use in encoding\n    for (var k in encDefaults) {\n      if (!enc[k]) {\n        delete encDefaults[k];\n      }\n    }\n\n    this._marktype = marktype;\n    this._enc = schema.util.merge(encDefaults, enc);\n    this._cfg = schema.util.merge(cfgDefaults, config);\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(x) {\n    return this._enc[x] !== undefined;\n  };\n\n  proto.enc = function(x){\n    return this._enc[x];\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(x, nodata, nofn) {\n    if (!this.has(x)) return null;\n\n    var f = (nodata ? \"\" : \"data.\");\n\n    if (this._enc[x].aggr === \"count\") {\n      return f + \"count\";\n    } else if (!nofn && this._enc[x].bin) {\n      return f + \"bin_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].aggr) {\n      return f + this._enc[x].aggr + \"_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].fn){\n      return f + this._enc[x].fn + \"_\" + this._enc[x].name;\n    } else {\n      return f + this._enc[x].name;\n    }\n  };\n\n  proto.fieldName = function(x){\n    return this._enc[x].name;\n  }\n\n  proto.fieldTitle = function(x){\n    if (this._enc[x].aggr) {\n      return this._enc[x].aggr + \"(\" + this._enc[x].name + \")\";\n    } else {\n      return this._enc[x].name;\n    }\n  }\n\n  proto.scale = function(x){\n    return this._enc[x].scale || {};\n  }\n\n  proto.axis = function(x){\n    return this._enc[x].axis || {};\n  }\n\n  proto.aggr = function(x){\n    return this._enc[x].aggr;\n  }\n\n  proto.bin = function(x){\n    return this._enc[x].bin;\n  }\n\n  proto.legend = function(x){\n    return this._enc[x].legend;\n  }\n\n  proto.fn = function(x){\n    return this._enc[x].fn;\n  }\n\n  proto.any = function(f){\n    return util.any(this._enc, f);\n  }\n\n  proto.all = function(f){\n    return util.all(this._enc, f);\n  }\n\n  proto.length = function(){\n    return util.keys(this._enc).length;\n  }\n\n  proto.reduce = function(f, init){\n    var r = init, i=0;\n    for (k in this._enc){\n      r = f(r, this._enc[k], k, this._enc);\n    }\n    return r;\n  }\n\n  proto.forEach = function(f) {\n    var i=0, k;\n    for (k in this._enc) {\n      f(k, this._enc[k], i++);\n    }\n  };\n\n  proto.type = function(x) {\n    return this.has(x) ? this._enc[x].type : null;\n  };\n\n  proto.isType = function(x, t) {\n    var xt = this.type(x);\n    if (xt == null) return false;\n    return (xt & t) > 0;\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig){\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for(var e in enc){\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc\n    }\n\n    if(!excludeConfig){\n      spec.cfg = util.duplicate(this._cfg)\n    }\n\n    return spec;\n  };\n\n  proto.toShorthand = function(){\n    var enc = this._enc;\n    return this._marktype + \".\" + util.keys(enc).map(function(e){\n      var v = enc[e];\n        return e + \"-\" +\n          (v.aggr ? v.aggr+\"_\" : \"\") +\n          (v.fn ? v.fn+\"_\" : \"\") +\n          (v.bin ? \"bin_\" : \"\") +\n          (v.name || \"\") + \"-\" +\n          consts.dataTypeNames[v.type];\n      }\n    ).join(\".\");\n  }\n\n  Encoding.parseShorthand = function(shorthand, cfg){\n    var enc = shorthand.split(\".\"),\n      marktype = enc.shift();\n\n    enc = enc.reduce(function(m, e){\n      var split = e.split(\"-\"),\n        enctype = split[0],\n        o = {name: split[1], type: consts.dataTypes[split[2]]};\n\n      // check aggregate type\n      for(var i in schema.aggr.enum){\n        var a = schema.aggr.enum[i];\n        if(o.name.indexOf(a+\"_\") == 0){\n          o.name = o.name.substr(a.length+1);\n          if (a==\"count\" && o.name.length === 0) o.name = \"*\";\n          o.aggr = a;\n          break;\n        }\n      }\n      // check time fn\n      for(var i in schema.timefns){\n        var f = schema.timefns[i];\n        if(o.name && o.name.indexOf(f+\"_\") == 0){\n          o.name = o.name.substr(o.length+1);\n          o.fn = f;\n          break;\n        }\n      }\n\n      // check bin\n      if(o.name && o.name.indexOf(\"bin_\") == 0){\n        o.name = o.name.substr(4);\n        o.bin = true;\n      }\n\n      m[enctype] = o;\n      return m;\n    }, {});\n\n    return new Encoding(marktype, enc, cfg);\n  }\n\n  Encoding.fromSpec = function(spec, extraCfg) {\n    var enc = util.duplicate(spec.enc);\n\n    //convert type from string to bitcode (e.g, O=1)\n    for(var e in enc){\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, util.merge(spec.cfg, extraCfg || {}));\n  }\n\n  return Encoding;\n\n})();\n","var globals = require('./globals'),\n  util = require('./util');\n\nvar axis = module.exports = {};\n\naxis.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s===X || s===Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\naxis.defs = function(names, encoding, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis_def(name, encoding, opt));\n    return a;\n  }, []);\n}\n\nfunction axis_def(name, encoding, opt){\n  var type = name, axis;\n  var isCol = name==COL, isRow = name==ROW;\n  if(isCol) type = \"x\";\n  if(isRow) type = \"y\";\n\n  var axis = {\n    type: type,\n    scale: name,\n    ticks: 3 //TODO(kanitw): better determine # of ticks\n  };\n\n  if (encoding.axis(name).grid) {\n    axis.grid = true;\n    axis.layer = \"back\";\n  }\n\n  if (encoding.axis(name).title) {\n    //show title by default\n\n    axis = axis_title(axis, name, encoding, opt);\n  }\n\n  if(isRow || isCol){\n    axis.properties = {\n      ticks: { opacity: {value: 0} },\n      majorTicks: { opacity: {value: 0} },\n      axis: { opacity: {value: 0} }\n    };\n  }\n  if(isCol){\n    axis.offset = [opt.xAxisMargin || 0, encoding.config(\"yAxisMargin\")];\n    axis.orient = \"top\";\n  }\n\n  if (name==\"x\" && (encoding.isType(name, O) || encoding.bin(name))) {\n    axis.properties = {\n      labels: {\n        angle: {value: 270},\n        align: {value: \"right\"},\n        baseline: {value: \"middle\"}\n      }\n    }\n  }\n\n  return axis;\n}\n\nfunction axis_title(axis, name, encoding, opt){\n  axis.title = encoding.fieldTitle(name);\n  if(name==Y){\n    axis.titleOffset = 60;\n    // TODO: set appropriate titleOffset\n    // maybe based on some string length from stats\n  }\n  return axis;\n}\n","var globals = require('./globals'),\n  util = require('./util'),\n  axis = require('./axis'),\n  legends = require('./legends'),\n  marks = require('./marks'),\n  scale = require('./scale');\n\nvar compile = module.exports = function(encoding, stats) {\n  var size = setSize(encoding, stats),\n    cellWidth = size.cellWidth,\n    cellHeight = size.cellHeight;\n\n  var hasAgg = encoding.any(function(v, k){\n    return v.aggr !== undefined;\n  });\n\n  var spec = template(encoding, size, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdef = markdef(mark, encoding, {\n      hasAggregate: hasAgg\n    });\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  group.marks.push(mdef);\n  // TODO: return value not used\n  binning(spec.data[0], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if(!preaggregatedData){\n    encoding.forEach(function(encType, field){\n      if(field.type === T && field.fn){\n        timeTransform(spec.data[0], encoding, encType, field);\n      }\n    });\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec.data[0], encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isType(X, Q | T) && encoding.isType(Y, O)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    mdef.from.transform = [{type: \"sort\", by: encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding);\n    group.legends = legends.defs(encoding);\n  }\n  return spec;\n};\n\nfunction getCardinality(encoding, encType, stats){\n  var field = encoding.fieldName(encType);\n  if (encoding.bin(encType)) {\n    var bins = util.getbins(stats[field]);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  return stats[field].cardinality;\n}\n\nfunction setSize(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y);\n\n  // HACK to set chart size\n  // NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  // One solution is to update Vega to support auto-sizing\n  // In the meantime, auto-padding (mostly) does the trick\n  //\n  var colCardinality = hasCol ? getCardinality(encoding, COL, stats) : 1,\n    rowCardinality = hasRow ? getCardinality(encoding, ROW, stats) : 1;\n\n  var cellWidth = hasX ?\n      +encoding.config(\"cellWidth\") || encoding.config(\"width\") * 1.0 / colCardinality :\n      encoding.marktype() === \"text\" ?\n        +encoding.config(\"textCellWidth\") :\n        +encoding.config(\"bandSize\"),\n    cellHeight = hasY ?\n      +encoding.config(\"cellHeight\") || encoding.config(\"height\") * 1.0 / rowCardinality :\n      +encoding.config(\"bandSize\"),\n    cellPadding = encoding.config(\"cellPadding\"),\n    bandPadding = encoding.config(\"bandPadding\"),\n    width = encoding.config(\"_minWidth\"),\n    height = encoding.config(\"_minHeight\");\n\n  if (hasX && (encoding.isType(X, O) || encoding.bin(X))) { //ordinal field will override parent\n    // bands within cell use rangePoints()\n    var xCardinality = getCardinality(encoding, X, stats);\n    cellWidth = (xCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  width = cellWidth * ((1 + cellPadding) * (colCardinality-1) + 1);\n\n  if (hasY && (encoding.isType(Y, O) || encoding.bin(Y))) {\n    // bands within cell use rangePoint()\n    var yCardinality = getCardinality(encoding, Y, stats);\n    cellHeight = (yCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  height = cellHeight * ((1 + cellPadding) * (rowCardinality-1) + 1);\n\n  return {\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    width: width,\n    height:height\n  };\n}\n\nfunction facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats) {\n    var enter = group.properties.enter;\n    var facetKeys = [], cellAxes = [];\n\n    var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n    var xAxisMargin = encoding.has(Y) ? encoding.config(\"xAxisMargin\") : undefined;\n\n    enter.fill = {value: encoding.config(\"cellBackgroundColor\")};\n\n    //move \"from\" to cell level and add facet transform\n    group.from = {data: group.marks[0].from.data};\n\n    if (group.marks[0].from.transform) {\n      delete group.marks[0].from.data; //need to keep transform for subfacetting case\n    } else {\n      delete group.marks[0].from;\n    }\n    if (hasRow) {\n      if (!encoding.isType(ROW, O)) {\n        util.error(\"Row encoding should be ordinal.\");\n      }\n      enter.y = {scale: ROW, field: \"keys.\" + facetKeys.length};\n      enter.height = {\"value\": cellHeight}; // HACK\n\n      facetKeys.push(encoding.field(ROW));\n\n      var from;\n      if (hasCol) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(COL)]});\n      }\n\n      var axesGrp = groupdef(\"x-axes\", {\n          axes: encoding.has(X) ?  axis.defs([\"x\"], encoding) : undefined,\n          x: hasCol ? {scale: COL, field: \"keys.0\", offset: xAxisMargin} : {value: xAxisMargin},\n          width: hasCol && {\"value\": cellWidth}, //HACK?\n          from: from\n        });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || []);\n      spec.axes.push.apply(spec.axes, axis.defs([\"row\"], encoding));\n    } else { // doesn't have row\n      if(encoding.has(X)){\n        //keep x axis in the cell\n        cellAxes.push.apply(cellAxes, axis.defs([\"x\"], encoding));\n      }\n    }\n\n    if (hasCol) {\n      if (!encoding.isType(COL, O)) {\n        util.error(\"Col encoding should be ordinal.\");\n      }\n      enter.x = {scale: COL, field: \"keys.\" + facetKeys.length};\n      enter.width = {\"value\": cellWidth}; // HACK\n\n      facetKeys.push(encoding.field(COL));\n\n      var from;\n      if (hasRow) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(ROW)]});\n      }\n\n      var axesGrp = groupdef(\"y-axes\", {\n        axes: encoding.has(Y) ? axis.defs([\"y\"], encoding) : undefined,\n        y: hasRow && {scale: ROW, field: \"keys.0\"},\n        x: hasRow && {value: xAxisMargin},\n        height: hasRow && {\"value\": cellHeight}, //HACK?\n        from: from\n      });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || [])\n      spec.axes.push.apply(spec.axes, axis.defs([\"col\"], encoding, {\n        xAxisMargin: xAxisMargin\n      }));\n    } else { // doesn't have col\n      if(encoding.has(Y)){\n        cellAxes.push.apply(cellAxes, axis.defs([\"y\"], encoding));\n      }\n    }\n\n    if(hasRow){\n      if(enter.x) enter.x.offset= xAxisMargin;\n      else enter.x = {value: xAxisMargin};\n    }\n    if(hasCol){\n      //TODO fill here..\n    }\n\n    // assuming equal cellWidth here\n    // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n    spec.scales = (spec.scales ||[]).concat(scale.defs(\n      scale.names(enter).concat(scale.names(mdef.properties.update)),\n      encoding,\n      {cellWidth: cellWidth, cellHeight: cellHeight, stack: stack, facet:true, stats: stats}\n    )); // row/col scales + cell scales\n\n    if (cellAxes.length > 0) {\n      group.axes = cellAxes;\n    }\n\n    // add facet transform\n    var trans = (group.from.transform || (group.from.transform = []));\n    trans.unshift({type: \"facet\", keys: facetKeys});\n\n  return spec;\n  }\n\nfunction subfacet(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef(\"subfacet\", {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: \"facet\", keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: \"sort\", by: encoding.field(COLOR)});\n  }\n}\n\nfunction getTimeFn(fn){\n  switch(fn){\n    case \"second\": return \"getUTCSeconds\";\n    case \"minute\": return \"getUTCMinutes\";\n    case \"hour\": return \"getUTCHours\";\n    case \"day\": return \"getUTCDay\";\n    case \"date\": return \"getUTCDate\";\n    case \"month\": return \"getUTCMonth\";\n    case \"year\": return \"getUTCFullYear\";\n  }\n  console.error(\"no function specified for date\");\n}\n\nfunction timeTransform(spec, encoding, encType, field){\n  var func = getTimeFn(field.fn);\n\n  spec.transform = spec.transform || [];\n  spec.transform.push({\n    type: \"formula\",\n    field: encoding.field(encType),\n    expr: \"new Date(d.data.\"+field.name+\").\"+func+\"()\"\n  });\n  return spec;\n}\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n  encoding.forEach(function(vv, d) {\n    if (d.bin) bins[d.name] = d.name;\n  });\n  bins = util.keys(bins);\n\n  if (bins.length === 0 || opt.preaggregatedData) return false;\n\n  if (!spec.transform) spec.transform = [];\n  bins.forEach(function(d) {\n    spec.transform.push({\n      type: \"bin\",\n      field: \"data.\" + d,\n      output: \"data.bin_\" + d,\n      maxbins: MAX_BINS\n    });\n  });\n  return bins;\n}\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n  var dims = {}, meas = {}, detail = {}, facets={};\n  encoding.forEach(function(encType, field) {\n    if (field.aggr) {\n      if(field.aggr===\"count\"){\n        meas[\"count\"] = {op:\"count\", field:\"*\"};\n      }else{\n        meas[field.aggr+\"|\"+field.name] = {\n          op:field.aggr,\n          field:\"data.\"+field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType==ROW || encType == COL){\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!spec.transform) spec.transform = [];\n    spec.transform.push({\n      type: \"aggregate\",\n      groupby: dims,\n      fields: meas\n    });\n\n    if (encoding.marktype() === TEXT) {\n      meas.forEach( function (m) {\n        var fieldName = m.field.substr(5), //remove \"data.\"\n          field = \"data.\" + (m.op ? m.op + \"_\" : \"\") + fieldName;\n        spec.transform.push({\n          type: \"formula\",\n          field: field,\n          expr: \"d3.format('.2f')(d.\"+field+\")\"\n        });\n      });\n    }\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  }\n}\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n  if (!encoding.has(COLOR)) return false;\n\n  var dim = X, val = Y, idx = 1;\n  if (encoding.isType(X,Q|T) && !encoding.isType(Y,Q|T) && encoding.has(Y)) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: \"aggregate\",\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: \"sum\", field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if(facets && facets.length > 0){\n    stacked.transform.push({ //calculate max for each facet\n      type: \"aggregate\",\n      groupby: facets,\n      fields: [{op: \"max\", field: \"data.sum_\" + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: \"stack\",\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val+\"2\"}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val+\"2\"] = mdef.properties.enter[val+\"2\"] = {scale: val, field: val+\"2\"};\n\n  return val; //return stack encoding\n}\n\n\nfunction markdef(mark, encoding, opt) {\n  var p = mark.prop(encoding, opt)\n  return {\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  };\n}\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: \"group\",\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: \"width\"},\n        height: opt.height || {group: \"height\"}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction template(encoding, size, stats) { //hack use stats\n\n  var data = {name:TABLE, format: {type: encoding.config(\"dataFormatType\")}},\n    dataUrl = vl.data.getUrl(encoding, stats);\n  if(dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  encoding.forEach(function(encType, field){\n    if(field.type == T){\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = \"date\";\n    }else if(field.type == Q){\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === \"count\") {\n        var name = \"count\";\n      } else if(preaggregatedData && field.bin){\n        var name = \"bin_\" + field.name;\n      } else if(preaggregatedData && field.aggr){\n        var name = field.aggr + \"_\" + field.name;\n      } else{\n        var name = field.name;\n      }\n      data.format.parse[name] = \"number\";\n    }\n  });\n\n  return {\n    width: size.width,\n    height: size.height,\n    padding: \"auto\",\n    data: [data],\n    marks: [groupdef(\"cell\", {\n      width: size.cellWidth ? {value: size.cellWidth}: undefined,\n      height: size.cellHeight ? {value: size.cellHeight} : undefined\n    })]\n  };\n}\n","var globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT];\n\nconsts.dataTypes = {\"O\": O, \"Q\": Q, \"T\": T};\n\nconsts.dataTypeNames = [\"O\",\"Q\",\"T\"].reduce(function(r,x) {\n  r[consts.dataTypes[x]] = x; return r;\n},{});\n\nconsts.DEFAULTS = {\n  //small multiples\n  cellHeight: 200, // will be overwritten by bandWidth\n  cellWidth: 200, // will be overwritten by bandWidth\n  cellPadding: 0.1,\n  cellBackgroundColor: \"#fdfdfd\",\n  xAxisMargin: 80,\n  yAxisMargin: 0,\n  textCellWidth: 90,\n\n  // marks\n  bandSize: 21,\n  bandPadding: 1,\n  pointSize: 50,\n  pointShape: \"circle\",\n  strokeWidth: 2,\n  color: \"steelblue\",\n  textColor: \"black\",\n  textAlign: \"left\",\n  textBaseline: \"middle\",\n  textMargin: 4,\n  font: \"Helvetica Neue\",\n  fontSize: \"12\",\n  fontWeight: \"normal\",\n  fontStyle: \"normal\",\n  opacity: 1,\n  _thickOpacity: 0.5,\n  _thinOpacity: 0.2,\n\n  // scales\n  // TODO remove _xZero, ...\n  _xZero: true,\n  _xReverse: false,\n  _yZero: true,\n  _yReverse: false,\n  timeScaleNice: \"day\"\n};","// TODO rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar data = module.exports = {};\n\ndata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config(\"useVegaServer\")) {\n    // don't use vega server\n    return encoding.config(\"dataUrl\");\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = []\n  encoding.forEach(function(encType, field){\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    }\n    if (field.aggr) {\n      obj.aggr = field.aggr\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name]).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config(\"vegaServerTable\"),\n    fields: fields\n  }\n\n  return encoding.config(\"vegaServerUrl\") + \"/query/?q=\" + JSON.stringify(query)\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\ndata.getSchema = function(data){\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k){\n    // find non-null data\n    var i=0, datum = data[i][k];\n    while(datum === \"\" || datum === null || datum === undefined){\n      datum = data[++i][k];\n    }\n\n    //TODO(kanitw): better type inference here\n    var type = (typeof datum === \"number\") ? \"Q\":\n      isNaN(Date.parse(datum)) ? \"O\" : \"T\";\n\n    schema.push({name: k, type: type});\n  });\n\n  return schema;\n};\n\ndata.getStats = function(data){ // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = util.minmax(data, k);\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n    stats[k] = stat;\n  });\n  return stats;\n};\n","// declare global constant\nvar g = global || window;\n\ng.TABLE = \"table\";\ng.STACKED = \"stacked\";\ng.INDEX = \"index\";\n\ng.X = \"x\";\ng.Y = \"y\";\ng.ROW = \"row\";\ng.COL = \"col\";\ng.SIZE = \"size\";\ng.SHAPE = \"shape\";\ng.COLOR = \"color\";\ng.ALPHA = \"alpha\";\ng.TEXT = \"text\";\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n//TODO refactor this to be config?\ng.MAX_BINS = 20;","var global = require('./globals');\n\nvar legends = module.exports = {};\n\nlegends.defs = function(encoding) {\n  var legends = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    legends.push({\n      fill: COLOR,\n      title: encoding.fieldTitle(COLOR),\n      orient: \"right\"\n    });\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    legends.push({\n      size: SIZE,\n      title: encoding.fieldTitle(SIZE),\n      orient: legends.length === 1 ? \"left\" : \"right\"\n    });\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (legends.length === 2) {\n      // TODO: fix this\n      console.error(\"Vegalite currently only supports two legends\");\n      return legends;\n    }\n    legends.push({\n      shape: SHAPE,\n      title: encoding.fieldTitle(SHAPE),\n      orient: legends.length === 1 ? \"left\" : \"right\"\n    });\n  }\n\n  return legends;\n}","var globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar marks = module.exports = {};\n\nmarks.bar = {\n  type: \"rect\",\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.line = {\n  type: \"line\",\n  line: true,\n  prop: line_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, color:1, alpha:1}\n};\n\nmarks.area = {\n  type: \"area\",\n  stack: true,\n  line: true,\n  requiredEncoding: [\"x\", \"y\"],\n  prop: area_props,\n  supportedEncoding: marks.line.supportedEncoding\n};\n\nmarks.circle = {\n  type: \"symbol\",\n  prop: filled_point_props(\"circle\"),\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.square = {\n  type: \"symbol\",\n  prop: filled_point_props(\"square\"),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: \"symbol\",\n  prop: point_props,\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1, shape:1}\n};\n\nmarks.text = {\n  type: \"text\",\n  prop: text_props,\n  requiredEncoding: [\"text\"],\n  supportedEncoding: {row:1, col:1, size:1, color:1, alpha:1, text:1}\n};\n\nfunction bar_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T) && !e.bin(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.has(Y) && (!e.isType(Y,Q|T) || e.bin(Y))) {\n      p.x2 = {scale: X, value: 0};\n    }\n  } else if (e.has(X)) {\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T) && !e.bin(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    p.yc = {group: \"height\"};\n  }\n\n  // width\n  if (!e.isType(X,Q|T)) {\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.width = {scale: X, band: true, offset: -1};\n      p.width = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(Y,O) && !e.bin(Y)) {\n    p.width = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // height\n  if (!e.isType(Y,Q|T)) {\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.height = {scale: Y, band: true, offset: -1};\n      p.height = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(X,O) && !e.bin(X)) {\n    p.height = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, opt) {\n  var p = {};\n  opt = opt || {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.config(\"pointSize\")};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.config(\"pointShape\")};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }else{\n    p.opacity = {\n      value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n    };\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction line_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction area_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.isType(Y,Q|T) && e.has(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: \"horizontal\"};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, opt) {\n    var p = {};\n    opt = opt || {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.config(\"bandSize\")/2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.config(\"bandSize\")/2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.config(\"pointSize\")};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.config(\"color\")};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    }else {\n      p.opacity = {\n        value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n      };\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(X)) {\n    p.fontSize = {value: e.config(\"fontSize\")};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"textColor\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    p.text = {field: e.field(TEXT)};\n  } else {\n    p.text = {value: \"Abc\"};\n  }\n\n  p.font = {value: e.config(\"font\")};\n  p.fontWeight = {value: e.config(\"fontWeight\")};\n  p.fontStyle = {value: e.config(\"fontStyle\")};\n  p.baseline = {value: e.config(\"textBaseline\")};\n\n  // align\n  if (e.has(X)) {\n    if (e.isType(X,O)) {\n      p.align = {value: \"left\"};\n      p.dx = {value: e.config(\"textMargin\")};\n    } else {\n      p.align = {value: \"center\"}\n    }\n  } else if (e.has(Y)) {\n    p.align = {value: \"left\"};\n    p.dx = {value: e.config(\"textMargin\")};\n  } else {\n    p.align = {value: e.config(\"textAlign\")};\n  }\n\n  return p;\n}","var globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar scale = module.exports = {};\n\nscale.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\nscale.defs = function (names, encoding, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale_type(name, encoding),\n      domain: scale_domain(name, encoding, opt)\n    };\n    if (s.type === \"ordinal\" && !encoding.bin(name)) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, opt);\n\n    return (a.push(s), a);\n  }, []);\n}\n\nfunction scale_type(name, encoding) {\n  switch (encoding.type(name)) {\n    case O: return \"ordinal\";\n    case T:\n      if (encoding.fn(name)) {\n        return \"linear\";\n      }\n      return \"time\";\n    case Q:\n      if (encoding.bin(name)) {\n        return \"ordinal\";\n      }\n      return encoding.scale(name).type || \"linear\";\n  }\n}\n\nfunction scale_domain(name, encoding, opt) {\n  if (encoding.type(name) === T){\n    switch(encoding.fn(name)){\n      case \"second\":\n      case \"minute\": return [0, 59];\n      case \"hour\": return [0, 23];\n      case \"day\": return [0, 6];\n      case \"date\": return [1, 31];\n      case \"month\": return [0, 11];\n    }\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)]);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name===Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: \"data.\" + (opt.facet ? \"max_\" :\"\") + \"sum_\" + encoding.field(name, true)\n    }:\n    {data: TABLE, field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellWidth ? [0, opt.cellWidth] : \"width\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_xZero\");\n        s.reverse = spec.reverse || encoding.config(\"_xReverse\");\n      }\n      s.round = true;\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellHeight ? [opt.cellHeight, 0] : \"height\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_yZero\");\n        s.reverse = spec.reverse || encoding.config(\"_yReverse\");\n      }\n\n      s.round = true;\n\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name);\n      }else{\n        s.nice = true;\n      }\n      break;\n    case ROW:\n      s.bandWidth = opt.cellHeight || encoding.config(\"cellHeight\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL:\n      s.bandWidth = opt.cellWidth || encoding.config(\"cellWidth\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is(\"bar\")) {\n        s.range = [3, +encoding.config(\"bandSize\")];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else {\n        s.range = [10, 1000];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = \"shapes\";\n      break;\n    case COLOR:\n      if (encoding.isType(s.name, O)) {\n        s.range = \"category10\";\n      } else {\n        s.range = [\"#ddf\", \"steelblue\"];\n        s.zero = false;\n      }\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error(\"Unknown encoding name: \"+s.name);\n  }\n\n  switch(s.name){\n    case ROW:\n    case COL:\n      s.padding = encoding.config(\"cellPadding\");\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name) ) { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.config(\"bandPadding\");\n      }\n  }\n}","// Package of defining Vegalite Specification's json schema\n//\nvar schema = module.exports = {},\n  util = require('./util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: \"string\",\n  enum: [\"point\", \"bar\", \"line\", \"area\", \"circle\", \"square\", \"text\"]\n};\n\nschema.aggr = {\n  type: \"string\",\n  enum: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n  supportedEnums: {\n    Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n    O: [\"count\"],\n    T: [\"avg\", \"min\", \"max\", \"count\"],\n    \"\": [\"count\"],\n  },\n  supportedTypes: {\"Q\": true, \"O\": true, \"T\": true, \"\": true}\n};\n\nschema.timefns = [\"month\", \"year\", \"day\", \"date\", \"hour\", \"minute\", \"second\"];\n\nschema.fn = {\n  type: \"string\",\n  enum: schema.timefns,\n  supportedTypes: {\"T\": true}\n}\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: \"string\",\n  enum: [\"linear\", \"log\",\"pow\", \"sqrt\", \"quantile\"],\n  default: \"linear\",\n  supportedTypes: {\"Q\": true}\n};\n\nschema.field = {\n  type: \"object\",\n  required: [\"name\", \"type\"],\n  properties: {\n    name: {\n      type: \"string\"\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nvar typicalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\", \"Q\", \"T\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"Q\": true, \"O\": true}\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    scale: {\n      type: \"object\",\n      properties: {\n        type: schema.scale_type,\n        reverse: { type: \"boolean\", default: false },\n        zero: {\n          type: \"boolean\",\n          description: \"Include zero\",\n          default: false,\n          supportedTypes: {\"Q\": true}\n        },\n        nice: {\n          type: \"string\",\n          enum: [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"year\"],\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: \"object\",\n  properties: {\n    type: {\n      type: \"string\",\n      enum: [\"O\"]\n    },\n    bin: {\n      type: \"boolean\",\n      default: false,\n      supportedTypes: {\"O\": true}\n    },\n    aggr: {\n      type: \"string\",\n      enum: [\"count\"],\n      supportedTypes: {\"O\": true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: \"object\",\n  properties: {\n    axis: {\n      type: \"object\",\n      properties: {\n        grid: { type: \"boolean\", default: false },\n        title: { type: \"boolean\", default: true }\n      }\n    }\n  }\n}\n\nvar legendMixin = {\n  type: \"object\",\n  properties: {\n    legend: { type: \"boolean\", default: true }\n  }\n}\n\nvar textMixin = {\n  type: \"object\",\n  properties: {\n    text: {\n      type: \"object\",\n      properties: {\n        weight: {\n          type: \"string\",\n          enum: [\"normal\", \"bold\"],\n          default: \"normal\",\n          supportedTypes: {\"T\": true}\n        },\n        size: {\n          type: \"integer\",\n          default: 10,\n          minimum: 0,\n          supportedTypes: {\"T\": true}\n        },\n        font: {\n          type: \"string\",\n          default: \"Halvetica Neue\",\n          supportedTypes: {\"T\": true}\n        }\n      }\n    }\n  }\n}\n\nvar x = merge(clone(typicalField), axisMixin);\nvar y = clone(x);\n\nvar row = clone(onlyOrdinalField);\nvar col = clone(row);\n\nvar size = merge(clone(typicalField), legendMixin);\nvar color = merge(clone(typicalField), legendMixin);\nvar alpha = clone(typicalField);\nvar shape = merge(clone(onlyOrdinalField), legendMixin);\n\nvar text = merge(clone(typicalField), textMixin);\n\nvar cfg = {\n  type: \"object\",\n  properties: {\n    // template\n    width: {\n      type: \"integer\",\n      default: undefined\n    },\n    height: {\n      type: \"integer\",\n      default: undefined\n    },\n    viewport: {\n      type: \"array\",\n      items: {\n        type: [\"integer\"]\n      },\n      default: undefined\n    },\n    _minWidth: {\n      type: \"integer\",\n      default: 20\n    },\n    _minHeight: {\n      type: \"integer\",\n      default: 20\n    },\n\n    // data source\n    dataFormatType: {\n      type: \"string\",\n      enum: [\"json\", \"csv\"],\n      default: \"json\"\n    },\n    useVegaServer: {\n      type: \"boolean\",\n      default: false\n    },\n    dataUrl: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerTable: {\n      type: \"string\",\n      default: undefined\n    },\n    vegaServerUrl: {\n      type: \"string\",\n      default: \"http://localhost:3001\"\n    }\n  }\n}\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: \"http://json-schema.org/draft-04/schema#\",\n  type: \"object\",\n  required: [\"marktype\", \"enc\", \"cfg\"],\n  properties: {\n    marktype: schema.marktype,\n    enc: {\n      type: \"object\",\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text\n      }\n    },\n    cfg: cfg\n  }\n};\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function(){\n  return schema.util.instantiate(schema.schema);\n}\n","var util = module.exports = {};\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0\n}\n\n// instantiate a schema\nutil.instantiate = function(schema, required) {\n  if (schema.type === 'object') {\n    schema.required = schema.required ? schema.required : [];\n    var instance = {};\n    for (var name in schema.properties) {\n      var child = schema.properties[name];\n      instance[name] = util.instantiate(child, schema.required.indexOf(name) != -1);\n    };\n    return instance;\n  } else if ('default' in schema) {\n    return schema.default;\n  } else if (schema.enum && required) {\n    return schema.enum[0];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nutil.difference = function(defaults, instance) {\n  var changes = {};\n  for (var prop in instance) {\n    if (!defaults || defaults[prop] !== instance[prop]) {\n      if (typeof instance[prop] == \"object\") {\n        var c = util.difference(defaults[prop], instance[prop]);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else {\n        changes[prop] = instance[prop];\n      }\n    }\n  }\n  return changes;\n};\n\n// recursively merges instance into defaults\nutil.merge = function (defaults, instance) {\n  if (typeof instance!=='object' || instance===null) {\n    return defaults;\n  }\n\n  for (var p in instance) {\n    if (!instance.hasOwnProperty(p))\n      continue;\n    if (instance[p]===undefined )\n      continue;\n    if (typeof instance[p] !== 'object' || instance[p] === null) {\n      defaults[p] = instance[p];\n    } else if (typeof defaults[p] !== 'object' || defaults[p] === null) {\n      defaults[p] = util.merge(instance[p].constructor === Array ? [] : {}, instance[p]);\n    } else {\n      util.merge(defaults[p], instance[p]);\n    }\n  }\n  return defaults;\n}\n","var util = module.exports = {};\n\nutil.keys = function (obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n}\n\nutil.vals = function (obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n}\n\nutil.range = function (start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n}\n\nutil.find = function (list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n}\n\nutil.uniq = function (data, field) {\n  var map = {}, count = 0, i, k;\n  for (i=0; i<data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n}\n\nutil.minmax = function (data, field) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (i=0; i<data.length; ++i) {\n    var v = data[i][field];\n    if (v > stats.max) stats.max = v;\n    if (v < stats.min) stats.min = v;\n  }\n  return stats;\n}\n\nutil.duplicate = function (obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.any = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(f(arr[k], k, i++)) return true;\n  }\n  return false;\n}\n\nutil.all = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(!f(arr[k], k, i++)) return false;\n  }\n  return true;\n}\n\nutil.merge = function(dest, src){\n  return util.keys(src).reduce(function(c, k){\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.getbins = function (stats) {\n  return vg.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: MAX_BINS\n  });\n}\n\n\nutil.error = function(msg){\n  console.error(\"[VL Error]\", msg);\n}\n\n"],"sourceRoot":"/source/"}