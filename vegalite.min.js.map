{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vegalite.js","src/Encoding.js","src/compile/aggregates.js","src/compile/axis.js","src/compile/binning.js","src/compile/compile.js","src/compile/faceting.js","src/compile/filter.js","src/compile/group.js","src/compile/layout.js","src/compile/legend.js","src/compile/marks.js","src/compile/scale.js","src/compile/sort.js","src/compile/stacking.js","src/compile/style.js","src/compile/subfaceting.js","src/compile/template.js","src/compile/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","merge","Encoding","compile","data","field","enc","schema","./Encoding","./compile/compile","./consts","./data","./enc","./field","./globals","./schema/schema","./util",2,"vlfield","vlenc","marktype","config","filter","theme","defaults","instantiate","spec","cfg","type","dataTypes","specExtended","this","_marktype","_enc","_cfg","_filter","proto","prototype","is","m","has","encType","undefined","name","et","filterNull","fields","forEach","fieldList","fieldName","Q","containsType","T","O","push","operands","operator","concat","nodata","nofn","aggr","bin","fn","fieldTitle","isCount","count","displayName","toUpperCase","scale","axis","band","bandSize","useSmallBand","Y","ROW","X","COL","size","maxbins","MAXBINS_DEFAULT","legend","value","sort","stats","isType","byCode","toggleSort","support","qField","x","y","reverse","any","all","keys","map","reduce","init","role","text","prop","TEXT","font","fieldDef","isOrdinalScale","encoding","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","color","cardinality","isRaw","toSpec","excludeConfig","duplicate","dataTypeNames","subtract","toShorthand","c","shorthand","assign","delim","fromShorthand","split","shift","trim","specFromShorthand","fromSpec","transpose","oldenc","row","col","direction","useTypeCode","mode","get","toggleFilterNullO","numNulls","./compile/time",3,"aggregates","opt","dims","meas","detail","facets","op","vals","preaggregatedData","transform","groupby","details","aggregated","../globals","../util",4,"axis_title","def","layout","maxlength","cellWidth","cellHeight","title","truncate","setter","angle","align","baseline","dy","height","titleOffset","axisTitleOffset","axis_labels","time","hasScale","textTemplatePath","format","maxLabelLength","getter","names","props","defs","isCol","isRow","rowOffset","cellPadding","grid","layer","offset","stroke","x2","group","mult","opacity","orient","ticks","./time",5,"binning","output",6,"style","vlstyle","template","marks","mark","mdefs","mdef","addFilters","sorting","vlsort","hasRow","hasCol","lineType","line","aggResult","hasDetails","stack","stacking","subfaceting","from","by","faceting","legends","scales","properties","update","axes","filterLessThanZero","./aggregates","./axis","./binning","./faceting","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stacking","./style","./subfaceting","./template",7,"axesGrp","enter","facetKeys","cellAxes","fill","error","unshift","groupdef","width","apply","facet","trans",8,"BINARY",">",">=","=","!=","<","<=","filters","condition","op1","op2","j","console","warn","test",9,"_name",10,"vllayout","box","hasX","hasY","xCardinality","yCardinality","padding","colCardinality","rowCardinality","maxLength","Math","min","../field","../schema/schema",11,"COLOR","SIZE","SHAPE","shape","labels",12,"bar_props","p","xc","y2","yc","ALPHA","point_props","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","fontWeight","fontStyle","bg","TABLE","bar","requiredEncoding","supportedEncoding","alpha","area","tick","circle","square","point",13,"scale_domain","range","domain","bins","getbins","start","stop","step","STACKED","getDataset","scale_range","bandWidth","zero","round","nice","max","colorRange","outerPadding","points",14,"addSortTransforms","datasetMapping","counter","sortBy","d","byClause","dataName","transforms","source","RAW",15,"dim","val","idx","isXMeasure","isYMeasure","stacked","y1","y0",16,"estimateOpacity","numPoints","numMultiples","../Encoding",17,"g",18,"table","dataUrl","vldata","getUrl","url","parse","../data",19,"timeFields","timeFn","tf","fieldFn","func","stat","yearstat","formula","expr","labelLength","substr","isOrdinalFn","isColor",20,"encodingTypes","DETAIL",21,"obj","binSize","query","JSON","stringify","getSchema","order","k","datum","Date","stablesort","typeThenName","getStats","column","minmax","numbers","dates","uniq","len","toString","skew","stdev","mean","median","sample","Object","floor","random",22,"encTypes","countRetinal","arr","indexOf","join","convertType","isArray","enctype",23,"getIsType","byName","shorthands","timefns","typeOrder","G","toLowerCase","original","typeThenCardinality",24,"INDEX",25,"enum","supportedEnums","supportedTypes","minimum","default","getSupportedRole","supportedRole","defaultTimeFn","scale_type","clone","typicalField","description","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","margin","weight","family","sizeMixin","colorMixin","alphaMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","viewport","gridColor","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellBackgroundColor","textCellWidth","timeScaleLabelLength","characterWidth","dataFormatType","useVegaServer","vegaServerTable","vegaServerUrl","$schema","./schemautil",26,"dest","src","hasOwnProperty","constructor","Array","schemautil","isEmpty","extend","instance","isObject","changes","ins","arguments",27,"util_bisectLeft","lo","hi","mid","cmp","vg_truncateOnWord","rev","cnt","tok","vg_truncate_word_re","w","slice","v","Infinity","find","list","pattern","isin","item","array","isNumber","isNaN","parseFloat","isFinite","values","nums","date","b","half","variance","avg","diffs","pow","keyFn","indices","sa","sb","sqrt","med","std","thisArg","NaN","precision","eps","maxb","base","div","mins","minstep","logb","log","level","ceil","span","nbins","steps","unit","noaugment","pos","word","ellipsis","l1","l2","msg"],"mappings":"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","file":"vegalite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar globals = require('./globals'),\n    util = require('./util'),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\n\n\nmodule.exports = vl;\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals'),\n    util = require('./util'),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\n\n\nmodule.exports = vl;\n\n},{\"./Encoding\":2,\"./compile/compile\":6,\"./consts\":20,\"./data\":21,\"./enc\":22,\"./field\":23,\"./globals\":24,\"./schema/schema\":25,\"./util\":27}],2:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema'),\n  time = require('./compile/time');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      marktype: marktype,\n      enc: enc,\n      cfg: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._cfg = specExtended.cfg;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (this._enc[et].aggr === 'count') {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.any = function(f) {\n    return util.any(this._enc, f);\n  };\n\n  proto.all = function(f) {\n    return util.all(this._enc, f);\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec, stats) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.cfg = util.duplicate(this._cfg);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, cfg) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, cfg);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, cfg, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, cfg).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.cfg, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.cfg = spec.cfg || {};\n    spec.cfg.toggleSort = spec.cfg.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.cfg.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.cfg = spec.cfg || {};\n    spec.cfg.filterNull = spec.cfg.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.cfg.filterNull.O = !spec.cfg.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].numNulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./compile/time\":19,\"./consts\":20,\"./enc\":22,\"./field\":23,\"./globals\":24,\"./schema/schema\":25,\"./util\":27}],3:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":24,\"../util\":27}],4:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else {\n      setter(def, ['properties', 'grid', 'stroke'], {\n        value: encoding.config('gridColor')\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n\n},{\"../globals\":24,\"../util\":27,\"./time\":19}],5:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n\n  if (opt.preaggregatedData) {\n    return;\n  }\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n\n},{\"../globals\":24,\"../util\":27}],6:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = compile;\n\nvar template = compile.template = require('./template'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale'),\n  vlsort = compile.sort = require('./sort'),\n  vlstyle = compile.style = require('./style'),\n  time = compile.time = require('./time'),\n  aggregates = compile.aggregates = require('./aggregates'),\n  binning = compile.binning = require('./binning'),\n  faceting = compile.faceting = require('./faceting'),\n  stacking = compile.stacking = require('./stacking'),\n  subfaceting = compile.subfaceting = require('./subfaceting');\n\ncompile.layout = require('./layout');\ncompile.group = require('./group');\n\nfunction compile(encoding, stats) {\n  var layout = compile.layout(encoding, stats),\n    style = vlstyle(encoding, stats),\n    spec = template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = vlsort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config('useVegaServer');\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  binning(spec.data[1], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if (!preaggregatedData) {\n    spec = time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec, encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfaceting(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n}\n\n\n},{\"../globals\":24,\"../util\":27,\"./aggregates\":3,\"./axis\":4,\"./binning\":5,\"./faceting\":7,\"./filter\":8,\"./group\":9,\"./layout\":10,\"./legend\":11,\"./marks\":12,\"./scale\":13,\"./sort\":14,\"./stacking\":15,\"./style\":16,\"./subfaceting\":17,\"./template\":18,\"./time\":19}],7:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":24,\"../util\":27,\"./axis\":4,\"./group\":9,\"./scale\":13}],8:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n\n},{\"../globals\":24}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  schema = require('../schema/schema'),\n  time = require('./time'),\n  vlfield = require('../field');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength = stats[encoding.fieldName(x)].maxlength;\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(stats[encoding.fieldName(x)].maxlength, 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n\n},{\"../field\":23,\"../globals\":24,\"../schema/schema\":25,\"../util\":27,\"./time\":19}],11:[function(require,module,exports){\n'use strict';\n\nvar global = require('../globals'),\n  time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vegalite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n\n},{\"../globals\":24,\"./time\":19}],12:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlscale = require('./scale');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n\n},{\"../globals\":24,\"../util\":27,\"./scale\":13}],13:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n\n},{\"../globals\":24,\"../util\":27,\"./time\":19}],14:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n},{\"../globals\":24}],15:[function(require,module,exports){\n\"use strict\";\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":24,\"../util\":27,\"./marks\":12}],16:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlfield = require('../field'),\n  Encoding = require('../Encoding');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../Encoding\":2,\"../field\":23,\"../globals\":24,\"../util\":27}],17:[function(require,module,exports){\n'use strict';\n\nvar global = require('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n\n},{\"../globals\":24,\"./group\":9}],18:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nvar groupdef = require('./group').def,\n  vldata = require('../data');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) { //hack use stats\n\n  var data = {name: RAW, format: {type: encoding.config('dataFormatType')}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = vldata.getUrl(encoding, stats);\n  if (dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config('useVegaServer');\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === 'count') {\n        name = 'count';\n      } else if (preaggregatedData && field.bin) {\n        name = 'bin_' + field.name;\n      } else if (preaggregatedData && field.aggr) {\n        name = field.aggr + '_' + field.name;\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../data\":21,\"../globals\":24,\"./group\":9}],19:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.cardinality -\n        (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n\n},{\"../globals\":24,\"../util\":27}],20:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":24}],21:[function(require,module,exports){\n'use strict';\n\n// TODO: rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar vldata = module.exports = {},\n  vlfield = require('./field');\n\nvldata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config('useVegaServer')) {\n    // don't use vega server\n    return encoding.config('dataUrl');\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = [];\n  encoding.forEach(function(field, encType) {\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    };\n    if (field.aggr) {\n      obj.aggr = field.aggr;\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name], encoding.bin(encType).maxbins).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config('vegaServerTable'),\n    fields: fields\n  };\n\n  return encoding.config('vegaServerUrl') + '/query/?q=' + JSON.stringify(query);\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\nvldata.getSchema = function(data, order) {\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    // find non-null data\n    var i = 0, datum = data[i][k];\n    while (datum === '' || datum === null || datum === undefined) {\n      datum = data[++i][k];\n    }\n\n    datum = util.parse(datum);\n    var type = (typeof datum === 'number') ? 'Q':\n      (datum instanceof Date) ? 'T' : 'O';\n\n    schema.push({name: k, type: type});\n  });\n\n  schema = util.stablesort(schema, order || vlfield.order.typeThenName, vlfield.order.name);\n\n  return schema;\n};\n\nvldata.getStats = function(data) { // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var column = data.map(function(d) {return d[k];});\n\n    // Hack\n    var val = util.parse(data[0][k]);\n    var type = (typeof val === 'number') ? 'Q':\n      (val instanceof Date) ? 'T' : 'O';\n\n    var stat = {};\n    if (typeof val === 'number') {\n      stat = util.minmax(util.numbers(column));\n    } else if (val instanceof Date) {\n      stat = util.minmax(util.dates(column));\n    } else {\n      stat = util.minmax(column);\n    }\n\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n\n    stat.maxlength = data.reduce(function(max,row) {\n      if (row[k] === null) {\n        return max;\n      }\n      var len = row[k].toString().length;\n      return len > max ? len : max;\n    }, 0);\n\n    stat.numNulls = data.reduce(function(count, row) {\n      return row[k] === null ? count + 1 : count;\n    }, 0);\n\n    var numbers = util.numbers(column);\n\n    if (numbers.length > 0) {\n      stat.skew = util.skew(numbers);\n      stat.stdev = util.stdev(numbers);\n      stat.mean = util.mean(numbers);\n      stat.median = util.median(numbers);\n    }\n\n    var sample = {};\n    while(Object.keys(sample).length < Math.min(stat.cardinality, 10)) {\n      var value = data[Math.floor(Math.random() * data.length)][k];\n      sample[value] = true;\n    }\n    stat.sample = Object.keys(sample);\n\n    stats[k] = stat;\n  });\n  stats.count = data.length;\n  return stats;\n};\n\n},{\"./field\":23,\"./util\":27}],22:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init, i = 0, k;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field, encType) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};\n},{\"./compile/time\":19,\"./consts\":20,\"./field\":23,\"./schema/schema\":25,\"./util\":27}],23:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].cardinality;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stats[field.name], field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  var stat = stats[field.name];\n  return stat.cardinality -\n    (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compile/time\":19,\"./consts\":20,\"./schema/schema\":25,\"./util\":27}],24:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],25:[function(require,module,exports){\n// Package of defining Vegalite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar cfg = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#eeeeee'\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#aaaaaa'\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n\n    // data source\n    dataFormatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    useVegaServer: {\n      type: 'boolean',\n      default: false\n    },\n    dataUrl: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServerTable: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServerUrl: {\n      type: 'string',\n      default: 'http://localhost:3001'\n    }\n  }\n};\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for vegalite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'cfg'],\n  properties: {\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    cfg: cfg\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../util\":27,\"./schemautil\":26}],26:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":27}],27:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = {};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.vals = function(obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n};\n\nutil.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\nutil.find = function(list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n};\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.uniq = function(data, field) {\n  var map = {}, count = 0, i, k;\n  for (i = 0; i < data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n};\n\nvar isNumber = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n// try parsing to number\nutil.numbers = function(values) {\n  var nums = [];\n  for (var i = 0; i < values.length; i++) {\n    if (isNumber(values[i])) {\n      nums.push(+values[i]);\n    }\n  }\n  return nums;\n};\n\n// try to parse as date\nutil.dates = function(values) {\n  var dates = [];\n  for (var i = 0; i < values.length; i++) {\n    var date = Date.parse(values[i]);\n    if (!isNaN(date)) {\n      dates.push(new Date(date));\n    }\n  }\n  return dates;\n};\n\nutil.median = function(values) {\n  values.sort(function(a, b) {return a - b;});\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\nutil.mean = function(values) {\n  return values.reduce(function(v, r) {return v + r;}, 0) / values.length;\n};\n\nutil.variance = function(values) {\n  var avg = util.mean(values);\n  var diffs = [];\n  for (var i = 0; i < values.length; i++) {\n    diffs.push(Math.pow((values[i] - avg), 2));\n  }\n  return util.mean(diffs);\n};\n\nutil.stablesort = function(array, sortBy, keyFn) {\n  var indices = {};\n\n  array.forEach(function(v, i) {\n    indices[keyFn(v)] = i;\n  });\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n      sb = sortBy(b);\n\n    return sa<sb ? -1 : sa>sb ? 1 : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n  return array;\n};\n\nutil.stdev = function(values) {\n  return Math.sqrt(util.variance(values));\n};\n\nutil.skew = function(values) {\n  var avg = util.mean(values),\n    med = util.median(values),\n    std = util.stdev(values);\n  return 1.0 * (avg - med) / std;\n};\n\n// parses a string to date or number\nutil.parse = function(value) {\n  if (isNumber(value)) {\n    return +value;\n  }\n\n  var date = Date.parse(value);\n  if (!isNaN(date)) {\n    return (new Date(date));\n  }\n  return value;\n};\n\nutil.minmax = function(data) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (var i = 0; i < data.length; ++i) {\n    var v = data[i];\n    if (v !== null) {\n      if (v > stats.max || stats.max === -Infinity) stats.max = v;\n      if (v < stats.min || stats.min === +Infinity) stats.min = v;\n    }\n  }\n  return stats;\n};\n\nutil.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nutil.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nutil.array = function(x) {\n  return x ? (util.isArray(x) ? x : [x]) : [];\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\n\nutil.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nvar merge = function(dest, src) {\n  return util.keys(src).reduce(function(c, k) {\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n\nutil.bins = function(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 1024,\n      base = opt.base || 10,\n      div = opt.div || [5, 2],\n      mins = opt.minstep || 0,\n      logb = Math.log(base),\n      level = Math.ceil(Math.log(maxb) / logb),\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step = Math.max(mins, Math.pow(base, Math.round(Math.log(span) / logb) - level)),\n      nbins = Math.ceil(span / step),\n      precision, v, i, eps;\n\n  if (opt.step) {\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n        opt.steps.length - 1,\n        util_bisectLeft(opt.steps, span / maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // increase step size if too many bins\n    do {\n      step *= base;\n      nbins = Math.ceil(span / step);\n    } while (nbins > maxb);\n\n    // decrease step size if allowed\n    for (i = 0; i < div.length; ++i) {\n      v = step / div[i];\n      if (v >= mins && span / v <= maxb) {\n        step = v;\n        nbins = Math.ceil(span / step);\n      }\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = (min<0 ? -1 : 1) * Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop: max,\n    step: step,\n    unit: precision\n  };\n};\n\nfunction util_bisectLeft(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis || \"...\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? vg_truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? vg_truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis +\n        (word ? vg_truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? vg_truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction vg_truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(vg_truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar vg_truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJzcmMvRW5jb2RpbmcuanMiLCJzcmMvY29tcGlsZS9hZ2dyZWdhdGVzLmpzIiwic3JjL2NvbXBpbGUvYXhpcy5qcyIsInNyYy9jb21waWxlL2Jpbm5pbmcuanMiLCJzcmMvY29tcGlsZS9jb21waWxlLmpzIiwic3JjL2NvbXBpbGUvZmFjZXRpbmcuanMiLCJzcmMvY29tcGlsZS9maWx0ZXIuanMiLCJzcmMvY29tcGlsZS9ncm91cC5qcyIsInNyYy9jb21waWxlL2xheW91dC5qcyIsInNyYy9jb21waWxlL2xlZ2VuZC5qcyIsInNyYy9jb21waWxlL21hcmtzLmpzIiwic3JjL2NvbXBpbGUvc2NhbGUuanMiLCJzcmMvY29tcGlsZS9zb3J0LmpzIiwic3JjL2NvbXBpbGUvc3RhY2tpbmcuanMiLCJzcmMvY29tcGlsZS9zdHlsZS5qcyIsInNyYy9jb21waWxlL3N1YmZhY2V0aW5nLmpzIiwic3JjL2NvbXBpbGUvdGVtcGxhdGUuanMiLCJzcmMvY29tcGlsZS90aW1lLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9kYXRhLmpzIiwic3JjL2VuYy5qcyIsInNyYy9maWVsZC5qcyIsInNyYy9nbG9iYWxzLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdmwgPSB1dGlsLm1lcmdlKGNvbnN0cywgdXRpbCk7XG5cbnZsLkVuY29kaW5nID0gcmVxdWlyZSgnLi9FbmNvZGluZycpO1xudmwuY29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZS9jb21waWxlJyk7XG52bC5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG52bC5maWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKTtcbnZsLmVuYyA9IHJlcXVpcmUoJy4vZW5jJyk7XG52bC5zY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHZsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHZsZW5jID0gcmVxdWlyZSgnLi9lbmMnKSxcbiAgc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpO1xuXG52YXIgRW5jb2RpbmcgPSBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcblxuICBmdW5jdGlvbiBFbmNvZGluZyhtYXJrdHlwZSwgZW5jLCBjb25maWcsIGZpbHRlciwgdGhlbWUpIHtcbiAgICB2YXIgZGVmYXVsdHMgPSBzY2hlbWEuaW5zdGFudGlhdGUoKTtcblxuICAgIHZhciBzcGVjID0ge1xuICAgICAgbWFya3R5cGU6IG1hcmt0eXBlLFxuICAgICAgZW5jOiBlbmMsXG4gICAgICBjZmc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogZmlsdGVyIHx8IFtdXG4gICAgfTtcblxuICAgIC8vIHR5cGUgdG8gYml0Y29kZVxuICAgIGZvciAodmFyIGUgaW4gZGVmYXVsdHMuZW5jKSB7XG4gICAgICBkZWZhdWx0cy5lbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZXNbZGVmYXVsdHMuZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHZhciBzcGVjRXh0ZW5kZWQgPSBzY2hlbWEudXRpbC5tZXJnZShkZWZhdWx0cywgdGhlbWUgfHwge30sIHNwZWMpIDtcblxuICAgIHRoaXMuX21hcmt0eXBlID0gc3BlY0V4dGVuZGVkLm1hcmt0eXBlO1xuICAgIHRoaXMuX2VuYyA9IHNwZWNFeHRlbmRlZC5lbmM7XG4gICAgdGhpcy5fY2ZnID0gc3BlY0V4dGVuZGVkLmNmZztcbiAgICB0aGlzLl9maWx0ZXIgPSBzcGVjRXh0ZW5kZWQuZmlsdGVyO1xuICB9XG5cbiAgdmFyIHByb3RvID0gRW5jb2RpbmcucHJvdG90eXBlO1xuXG4gIHByb3RvLm1hcmt0eXBlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt0eXBlO1xuICB9O1xuXG4gIHByb3RvLmlzID0gZnVuY3Rpb24obSkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZSA9PT0gbTtcbiAgfTtcblxuICBwcm90by5oYXMgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgLy8gZXF1aXZhbGVudCB0byBjYWxsaW5nIHZsZW5jLmhhcyh0aGlzLl9lbmMsIGVuY1R5cGUpXG4gICAgcmV0dXJuIHRoaXMuX2VuY1tlbmNUeXBlXS5uYW1lICE9PSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcHJvdG8uZW5jID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XTtcbiAgfTtcblxuICBwcm90by5maWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmlsdGVyTnVsbCA9IFtdLFxuICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMoKSxcbiAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgdXRpbC5mb3JFYWNoKGZpZWxkcywgZnVuY3Rpb24oZmllbGRMaXN0LCBmaWVsZE5hbWUpIHtcbiAgICAgIGlmIChmaWVsZE5hbWUgPT09ICcqJykgcmV0dXJuOyAvL2NvdW50XG5cbiAgICAgIGlmICgoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5RICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbUV0pIHx8XG4gICAgICAgICAgKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuVCAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1RdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLk8gJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtPXSkpIHtcbiAgICAgICAgZmlsdGVyTnVsbC5wdXNoKHtcbiAgICAgICAgICBvcGVyYW5kczogW2ZpZWxkTmFtZV0sXG4gICAgICAgICAgb3BlcmF0b3I6ICdub3ROdWxsJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmaWx0ZXJOdWxsLmNvbmNhdCh0aGlzLl9maWx0ZXIpO1xuICB9O1xuXG4gIC8vIGdldCBcImZpZWxkXCIgcHJvcGVydHkgZm9yIHZlZ2FcbiAgcHJvdG8uZmllbGQgPSBmdW5jdGlvbihldCwgbm9kYXRhLCBub2ZuKSB7XG4gICAgaWYgKCF0aGlzLmhhcyhldCkpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGYgPSAobm9kYXRhID8gJycgOiAnZGF0YS4nKTtcblxuICAgIGlmICh0aGlzLl9lbmNbZXRdLmFnZ3IgPT09ICdjb3VudCcpIHtcbiAgICAgIHJldHVybiBmICsgJ2NvdW50JztcbiAgICB9IGVsc2UgaWYgKCFub2ZuICYmIHRoaXMuX2VuY1tldF0uYmluKSB7XG4gICAgICByZXR1cm4gZiArICdiaW5fJyArIHRoaXMuX2VuY1tldF0ubmFtZTtcbiAgICB9IGVsc2UgaWYgKCFub2ZuICYmIHRoaXMuX2VuY1tldF0uYWdncikge1xuICAgICAgcmV0dXJuIGYgKyB0aGlzLl9lbmNbZXRdLmFnZ3IgKyAnXycgKyB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmZuKSB7XG4gICAgICByZXR1cm4gZiArIHRoaXMuX2VuY1tldF0uZm4gKyAnXycgKyB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5maWVsZE5hbWUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gIH07XG5cbiAgLypcbiAgICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAgICovXG4gIHByb3RvLmZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5maWVsZHModGhpcy5fZW5jKTtcbiAgfTtcblxuICBwcm90by5maWVsZFRpdGxlID0gZnVuY3Rpb24oZXQpIHtcbiAgICBpZiAodmxmaWVsZC5pc0NvdW50KHRoaXMuX2VuY1tldF0pKSB7XG4gICAgICByZXR1cm4gdmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZTtcbiAgICB9XG4gICAgdmFyIGZuID0gdGhpcy5fZW5jW2V0XS5hZ2dyIHx8IHRoaXMuX2VuY1tldF0uZm4gfHwgKHRoaXMuX2VuY1tldF0uYmluICYmIFwiYmluXCIpO1xuICAgIGlmIChmbikge1xuICAgICAgcmV0dXJuIGZuLnRvVXBwZXJDYXNlKCkgKyAnKCcgKyB0aGlzLl9lbmNbZXRdLm5hbWUgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfVxuICB9O1xuXG4gIHByb3RvLnNjYWxlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5zY2FsZSB8fCB7fTtcbiAgfTtcblxuICBwcm90by5heGlzID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5heGlzIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmQgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmJhbmQgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYmFuZFNpemUgPSBmdW5jdGlvbihlbmNUeXBlLCB1c2VTbWFsbEJhbmQpIHtcbiAgICB1c2VTbWFsbEJhbmQgPSB1c2VTbWFsbEJhbmQgfHxcbiAgICAgIC8vaXNCYW5kSW5TbWFsbE11bHRpcGxlc1xuICAgICAgKGVuY1R5cGUgPT09IFkgJiYgdGhpcy5oYXMoUk9XKSAmJiB0aGlzLmhhcyhZKSkgfHxcbiAgICAgIChlbmNUeXBlID09PSBYICYmIHRoaXMuaGFzKENPTCkgJiYgdGhpcy5oYXMoWCkpO1xuXG4gICAgLy8gaWYgYmFuZC5zaXplIGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBmb2xsb3cgdGhlIHNwZWNpZmljYXRpb24sIG90aGVyd2lzZSBkcmF3IHZhbHVlIGZyb20gY29uZmlnLlxuICAgIHJldHVybiB0aGlzLmJhbmQoZW5jVHlwZSkuc2l6ZSB8fFxuICAgICAgdGhpcy5jb25maWcodXNlU21hbGxCYW5kID8gJ3NtYWxsQmFuZFNpemUnIDogJ2xhcmdlQmFuZFNpemUnKTtcbiAgfTtcblxuICBwcm90by5hZ2dyID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5hZ2dyO1xuICB9O1xuXG4gIC8vIHJldHVybnMgZmFsc2UgaWYgYmlubmluZyBpcyBkaXNhYmxlZCwgb3RoZXJ3aXNlIGFuIG9iamVjdCB3aXRoIGJpbm5pbmcgcHJvcGVydGllc1xuICBwcm90by5iaW4gPSBmdW5jdGlvbihldCkge1xuICAgIHZhciBiaW4gPSB0aGlzLl9lbmNbZXRdLmJpbjtcbiAgICBpZiAoYmluID09PSB7fSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYmluID09PSB0cnVlKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF4Ymluczogc2NoZW1hLk1BWEJJTlNfREVGQVVMVFxuICAgICAgfTtcbiAgICByZXR1cm4gYmluO1xuICB9O1xuXG4gIHByb3RvLmxlZ2VuZCA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0ubGVnZW5kO1xuICB9O1xuXG4gIHByb3RvLnZhbHVlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS52YWx1ZTtcbiAgfTtcblxuICBwcm90by5mbiA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uZm47XG4gIH07XG5cbiAgcHJvdG8uc29ydCA9IGZ1bmN0aW9uKGV0LCBzdGF0cykge1xuICAgIHZhciBzb3J0ID0gdGhpcy5fZW5jW2V0XS5zb3J0LFxuICAgICAgZW5jID0gdGhpcy5fZW5jLFxuICAgICAgaXNUeXBlID0gdmxmaWVsZC5pc1R5cGUuYnlDb2RlO1xuXG4gICAgLy8gY29uc29sZS5sb2coJ3NvcnQ6Jywgc29ydCwgJ3N1cHBvcnQ6JywgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHtlbmM6dGhpcy5fZW5jfSwgc3RhdHMpICwgJ3RvZ2dsZTonLCB0aGlzLmNvbmZpZygndG9nZ2xlU29ydCcpKVxuXG4gICAgaWYgKCghc29ydCB8fCBzb3J0Lmxlbmd0aD09PTApICYmXG4gICAgICAgIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jOnRoaXMuX2VuY30sIHN0YXRzLCB0cnVlKSAmJiAvL0hBQ0tcbiAgICAgICAgdGhpcy5jb25maWcoJ3RvZ2dsZVNvcnQnKSA9PT0gJ1EnXG4gICAgICApIHtcbiAgICAgIHZhciBxRmllbGQgPSBpc1R5cGUoZW5jLngsIE8pID8gZW5jLnkgOiBlbmMueDtcblxuICAgICAgaWYgKGlzVHlwZShlbmNbZXRdLCBPKSkge1xuICAgICAgICBzb3J0ID0gW3tcbiAgICAgICAgICBuYW1lOiBxRmllbGQubmFtZSxcbiAgICAgICAgICBhZ2dyOiBxRmllbGQuYWdncixcbiAgICAgICAgICB0eXBlOiBxRmllbGQudHlwZSxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3J0O1xuICB9O1xuXG4gIHByb3RvLmFueSA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdXRpbC5hbnkodGhpcy5fZW5jLCBmKTtcbiAgfTtcblxuICBwcm90by5hbGwgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHV0aWwuYWxsKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWwua2V5cyh0aGlzLl9lbmMpLmxlbmd0aDtcbiAgfTtcblxuICBwcm90by5tYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsZW5jLm1hcCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnJlZHVjZSA9IGZ1bmN0aW9uKGYsIGluaXQpIHtcbiAgICByZXR1cm4gdmxlbmMucmVkdWNlKHRoaXMuX2VuYywgZiwgaW5pdCk7XG4gIH07XG5cbiAgcHJvdG8uZm9yRWFjaCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMuZm9yRWFjaCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLnR5cGUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhldCkgPyB0aGlzLl9lbmNbZXRdLnR5cGUgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLnJvbGUgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLmhhcyhldCkgPyB2bGZpZWxkLnJvbGUodGhpcy5fZW5jW2V0XSkgOiBudWxsO1xuICB9O1xuXG4gIHByb3RvLnRleHQgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdmFyIHRleHQgPSB0aGlzLl9lbmNbVEVYVF0udGV4dDtcbiAgICByZXR1cm4gcHJvcCA/IHRleHRbcHJvcF0gOiB0ZXh0O1xuICB9O1xuXG4gIHByb3RvLmZvbnQgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdmFyIGZvbnQgPSB0aGlzLl9lbmNbVEVYVF0uZm9udDtcbiAgICByZXR1cm4gcHJvcCA/IGZvbnRbcHJvcF0gOiBmb250O1xuICB9O1xuXG4gIHByb3RvLmlzVHlwZSA9IGZ1bmN0aW9uKGV0LCB0eXBlKSB7XG4gICAgdmFyIGZpZWxkID0gdGhpcy5lbmMoZXQpO1xuICAgIHJldHVybiBmaWVsZCAmJiBFbmNvZGluZy5pc1R5cGUoZmllbGQsIHR5cGUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzVHlwZSA9IGZ1bmN0aW9uIChmaWVsZERlZiwgdHlwZSkge1xuICAgIC8vIEZJWE1FIHZsZmllbGQuaXNUeXBlXG4gICAgcmV0dXJuIChmaWVsZERlZi50eXBlICYgdHlwZSkgPiAwO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc09yZGluYWxTY2FsZShlbmNvZGluZy5lbmMoZW5jVHlwZSksIHRydWUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc0RpbWVuc2lvbihlbmNvZGluZy5lbmMoZW5jVHlwZSksIHRydWUpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNNZWFzdXJlKGVuY29kaW5nLmVuYyhlbmNUeXBlKSwgdHJ1ZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzRGltZW5zaW9uID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc0RpbWVuc2lvbih0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzTWVhc3VyZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZSh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZShzcGVjLmVuYyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24gPSBmdW5jdGlvbihzcGVjLCBzdGF0cykge1xuICAgIC8vIEZJWE1FIHJhdyBPeFEgd2l0aCAjIG9mIHJvd3MgPSAjIG9mIE9cbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUoc3BlYy5lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLmlzU3RhY2sgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgLy8gRklYTUUgdXBkYXRlIHRoaXMgb25jZSB3ZSBoYXZlIGNvbnRyb2wgZm9yIHN0YWNrIC4uLlxuICAgIHJldHVybiAoc3BlYy5tYXJrdHlwZSA9PT0gJ2JhcicgfHwgc3BlYy5tYXJrdHlwZSA9PT0gJ2FyZWEnKSAmJlxuICAgICAgc3BlYy5lbmMuY29sb3I7XG4gIH07XG5cbiAgcHJvdG8uaXNTdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHRoaXMuaXMoJ2JhcicpIHx8IHRoaXMuaXMoJ2FyZWEnKSkgJiYgdGhpcy5oYXMoJ2NvbG9yJyk7XG4gIH07XG5cbiAgcHJvdG8uY2FyZGluYWxpdHkgPSBmdW5jdGlvbihlbmNUeXBlLCBzdGF0cykge1xuICAgIHJldHVybiB2bGZpZWxkLmNhcmRpbmFsaXR5KHRoaXMuZW5jKGVuY1R5cGUpLCBzdGF0cywgdGhpcy5jb25maWcoJ2ZpbHRlck51bGwnKSwgdHJ1ZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNSYXcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNBZ2dyZWdhdGUoKTtcbiAgfTtcblxuICBwcm90by5jb25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NmZ1tuYW1lXTtcbiAgfTtcblxuICBwcm90by50b1NwZWMgPSBmdW5jdGlvbihleGNsdWRlQ29uZmlnKSB7XG4gICAgdmFyIGVuYyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2VuYyksXG4gICAgICBzcGVjO1xuXG4gICAgLy8gY29udmVydCB0eXBlJ3MgYml0Y29kZSB0byB0eXBlIG5hbWVcbiAgICBmb3IgKHZhciBlIGluIGVuYykge1xuICAgICAgZW5jW2VdLnR5cGUgPSBjb25zdHMuZGF0YVR5cGVOYW1lc1tlbmNbZV0udHlwZV07XG4gICAgfVxuXG4gICAgc3BlYyA9IHtcbiAgICAgIG1hcmt0eXBlOiB0aGlzLl9tYXJrdHlwZSxcbiAgICAgIGVuYzogZW5jLFxuICAgICAgZmlsdGVyOiB0aGlzLl9maWx0ZXJcbiAgICB9O1xuXG4gICAgaWYgKCFleGNsdWRlQ29uZmlnKSB7XG4gICAgICBzcGVjLmNmZyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2NmZyk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGRlZmF1bHRzXG4gICAgdmFyIGRlZmF1bHRzID0gc2NoZW1hLmluc3RhbnRpYXRlKCk7XG4gICAgcmV0dXJuIHNjaGVtYS51dGlsLnN1YnRyYWN0KHNwZWMsIGRlZmF1bHRzKTtcbiAgfTtcblxuICBwcm90by50b1Nob3J0aGFuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyB0aGlzLl9tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gICAgcmV0dXJuICdtYXJrJyArIGMuYXNzaWduICsgc3BlYy5tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHNwZWMuZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5mcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kLCBjZmcpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gICAgICAgIHNwbGl0ID0gc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pLFxuICAgICAgICBtYXJrdHlwZSA9IHNwbGl0LnNoaWZ0KCkuc3BsaXQoYy5hc3NpZ24pWzFdLnRyaW0oKSxcbiAgICAgICAgZW5jID0gdmxlbmMuZnJvbVNob3J0aGFuZChzcGxpdCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKG1hcmt0eXBlLCBlbmMsIGNmZyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGNmZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgY2ZnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuYyB8fCB7fSk7XG5cbiAgICAvL2NvbnZlcnQgdHlwZSBmcm9tIHN0cmluZyB0byBiaXRjb2RlIChlLmcsIE89MSlcbiAgICBmb3IgKHZhciBlIGluIGVuYykge1xuICAgICAgZW5jW2VdLnR5cGUgPSBjb25zdHMuZGF0YVR5cGVzW2VuY1tlXS50eXBlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHNwZWMubWFya3R5cGUsIGVuYywgc3BlYy5jZmcsIHNwZWMuZmlsdGVyLCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcudHJhbnNwb3NlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHZhciBvbGRlbmMgPSBzcGVjLmVuYyxcbiAgICAgIGVuYyA9IHV0aWwuZHVwbGljYXRlKHNwZWMuZW5jKTtcbiAgICBlbmMueCA9IG9sZGVuYy55O1xuICAgIGVuYy55ID0gb2xkZW5jLng7XG4gICAgZW5jLnJvdyA9IG9sZGVuYy5jb2w7XG4gICAgZW5jLmNvbCA9IG9sZGVuYy5yb3c7XG4gICAgc3BlYy5lbmMgPSBlbmM7XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydCA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNmZyA9IHNwZWMuY2ZnIHx8IHt9O1xuICAgIHNwZWMuY2ZnLnRvZ2dsZVNvcnQgPSBzcGVjLmNmZy50b2dnbGVTb3J0ID09PSAnUScgPyAnTycgOidRJztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQuZGlyZWN0aW9uID0gZnVuY3Rpb24oc3BlYywgdXNlVHlwZUNvZGUpIHtcbiAgICBpZiAoIUVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydChzcGVjLCB1c2VUeXBlQ29kZSkpIHsgcmV0dXJuOyB9XG4gICAgdmFyIGVuYyA9IHNwZWMuZW5jO1xuICAgIHJldHVybiBlbmMueC50eXBlID09PSAnTycgPyAneCcgOiAgJ3knO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQubW9kZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gc3BlYy5jZmcudG9nZ2xlU29ydDtcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQgPSBmdW5jdGlvbihzcGVjLCBzdGF0cywgdXNlVHlwZUNvZGUpIHtcbiAgICB2YXIgZW5jID0gc3BlYy5lbmMsXG4gICAgICBpc1R5cGUgPSB2bGZpZWxkLmlzVHlwZS5nZXQodXNlVHlwZUNvZGUpO1xuXG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIFJPVykgfHwgdmxlbmMuaGFzKGVuYywgQ09MKSB8fFxuICAgICAgIXZsZW5jLmhhcyhlbmMsIFgpIHx8ICF2bGVuYy5oYXMoZW5jLCBZKSB8fFxuICAgICAgIUVuY29kaW5nLmFsd2F5c05vT2NjbHVzaW9uKHNwZWMsIHN0YXRzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAoIGlzVHlwZShlbmMueCwgTykgJiYgdmxmaWVsZC5pc01lYXN1cmUoZW5jLnksIHVzZVR5cGVDb2RlKSkgPyAneCcgOlxuICAgICAgKCBpc1R5cGUoZW5jLnksIE8pICYmIHZsZmllbGQuaXNNZWFzdXJlKGVuYy54LCB1c2VUeXBlQ29kZSkpID8gJ3knIDogZmFsc2U7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlRmlsdGVyTnVsbE8gPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgc3BlYy5jZmcgPSBzcGVjLmNmZyB8fCB7fTtcbiAgICBzcGVjLmNmZy5maWx0ZXJOdWxsID0gc3BlYy5jZmcuZmlsdGVyTnVsbCB8fCB7IC8vRklYTUVcbiAgICAgIFQ6IHRydWUsXG4gICAgICBROiB0cnVlXG4gICAgfTtcbiAgICBzcGVjLmNmZy5maWx0ZXJOdWxsLk8gPSAhc3BlYy5jZmcuZmlsdGVyTnVsbC5PO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZUZpbHRlck51bGxPLnN1cHBvcnQgPSBmdW5jdGlvbihzcGVjLCBzdGF0cykge1xuICAgIHZhciBmaWVsZHMgPSB2bGVuYy5maWVsZHMoc3BlYy5lbmMpO1xuICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHMpIHtcbiAgICAgIHZhciBmaWVsZExpc3QgPSBmaWVsZHNbZmllbGROYW1lXTtcbiAgICAgIGlmIChmaWVsZExpc3QuY29udGFpbnNUeXBlLk8gJiYgZmllbGROYW1lIGluIHN0YXRzICYmIHN0YXRzW2ZpZWxkTmFtZV0ubnVtTnVsbHMgPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIEVuY29kaW5nO1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWdncmVnYXRlcztcblxuZnVuY3Rpb24gYWdncmVnYXRlcyhzcGVjLCBlbmNvZGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICB2YXIgZGltcyA9IHt9LCBtZWFzID0ge30sIGRldGFpbCA9IHt9LCBmYWNldHMgPSB7fSxcbiAgICBkYXRhID0gc3BlYy5kYXRhWzFdOyAvLyBjdXJyZW50bHkgZGF0YVswXSBpcyByYXcgYW5kIGRhdGFbMV0gaXMgdGFibGVcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGZpZWxkLmFnZ3IpIHtcbiAgICAgIGlmIChmaWVsZC5hZ2dyID09PSAnY291bnQnKSB7XG4gICAgICAgIG1lYXMuY291bnQgPSB7b3A6ICdjb3VudCcsIGZpZWxkOiAnKid9O1xuICAgICAgfWVsc2Uge1xuICAgICAgICBtZWFzW2ZpZWxkLmFnZ3IgKyAnfCcrIGZpZWxkLm5hbWVdID0ge1xuICAgICAgICAgIG9wOiBmaWVsZC5hZ2dyLFxuICAgICAgICAgIGZpZWxkOiAnZGF0YS4nKyBmaWVsZC5uYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbXNbZmllbGQubmFtZV0gPSBlbmNvZGluZy5maWVsZChlbmNUeXBlKTtcbiAgICAgIGlmIChlbmNUeXBlID09IFJPVyB8fCBlbmNUeXBlID09IENPTCkge1xuICAgICAgICBmYWNldHNbZmllbGQubmFtZV0gPSBkaW1zW2ZpZWxkLm5hbWVdO1xuICAgICAgfWVsc2UgaWYgKGVuY1R5cGUgIT09IFggJiYgZW5jVHlwZSAhPT0gWSkge1xuICAgICAgICBkZXRhaWxbZmllbGQubmFtZV0gPSBkaW1zW2ZpZWxkLm5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRpbXMgPSB1dGlsLnZhbHMoZGltcyk7XG4gIG1lYXMgPSB1dGlsLnZhbHMobWVhcyk7XG5cbiAgaWYgKG1lYXMubGVuZ3RoID4gMCAmJiAhb3B0LnByZWFnZ3JlZ2F0ZWREYXRhKSB7XG4gICAgaWYgKCFkYXRhLnRyYW5zZm9ybSkgZGF0YS50cmFuc2Zvcm0gPSBbXTtcbiAgICBkYXRhLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogZGltcyxcbiAgICAgIGZpZWxkczogbWVhc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGV0YWlsczogdXRpbC52YWxzKGRldGFpbCksXG4gICAgZGltczogZGltcyxcbiAgICBmYWNldHM6IHV0aWwudmFscyhmYWNldHMpLFxuICAgIGFnZ3JlZ2F0ZWQ6IG1lYXMubGVuZ3RoID4gMFxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIGdldHRlciA9IHV0aWwuZ2V0dGVyLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbnZhciBheGlzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuYXhpcy5uYW1lcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIHZhciBzID0gcHJvcHNbeF0uc2NhbGU7XG4gICAgaWYgKHMgPT09IFggfHwgcyA9PT0gWSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuYXhpcy5kZWZzID0gZnVuY3Rpb24obmFtZXMsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpIHtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihhLCBuYW1lKSB7XG4gICAgYS5wdXNoKGF4aXMuZGVmKG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpKTtcbiAgICByZXR1cm4gYTtcbiAgfSwgW10pO1xufTtcblxuYXhpcy5kZWYgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIHZhciB0eXBlID0gbmFtZTtcbiAgdmFyIGlzQ29sID0gbmFtZSA9PSBDT0wsIGlzUm93ID0gbmFtZSA9PSBST1c7XG4gIHZhciByb3dPZmZzZXQgPSBheGlzVGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgWSkgKyAyMCxcbiAgICBjZWxsUGFkZGluZyA9IGxheW91dC5jZWxsUGFkZGluZztcblxuXG4gIGlmIChpc0NvbCkgdHlwZSA9ICd4JztcbiAgaWYgKGlzUm93KSB0eXBlID0gJ3knO1xuXG4gIHZhciBkZWYgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzY2FsZTogbmFtZVxuICB9O1xuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmdyaWQpIHtcbiAgICBkZWYuZ3JpZCA9IHRydWU7XG4gICAgZGVmLmxheWVyID0gKGlzUm93IHx8IGlzQ29sKSA/ICdmcm9udCcgOiAgJ2JhY2snO1xuXG4gICAgaWYgKGlzQ29sKSB7XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSByaWdodCB0aGUgY2VsbFxuICAgICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2dyaWQnXSwge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgb2Zmc2V0OiBsYXlvdXQuY2VsbFdpZHRoICogKDErIGNlbGxQYWRkaW5nLzIuMCksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgc2NhbGU6ICdjb2wnXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICB2YWx1ZTogLWxheW91dC5jZWxsSGVpZ2h0ICogKGNlbGxQYWRkaW5nLzIpLFxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRDb2xvcicpIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNSb3cpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHRvcFxuICAgICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2dyaWQnXSwge1xuICAgICAgICB5OiB7XG4gICAgICAgICAgb2Zmc2V0OiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgc2NhbGU6ICdyb3cnXG4gICAgICAgIH0sXG4gICAgICAgIHg6IHtcbiAgICAgICAgICB2YWx1ZTogcm93T2Zmc2V0XG4gICAgICAgIH0sXG4gICAgICAgIHgyOiB7XG4gICAgICAgICAgb2Zmc2V0OiByb3dPZmZzZXQgKyAobGF5b3V0LmNlbGxXaWR0aCAqIDAuMDUpLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIGdyb3VwOiBcIm1hcmsuZ3JvdXAud2lkdGhcIixcbiAgICAgICAgICBtdWx0OiAxXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdncmlkJywgJ3N0cm9rZSddLCB7XG4gICAgICAgIHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2dyaWRDb2xvcicpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS50aXRsZSkge1xuICAgIGRlZiA9IGF4aXNfdGl0bGUoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpO1xuICB9XG5cbiAgaWYgKGlzUm93IHx8IGlzQ29sKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ3RpY2tzJ10sIHtcbiAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnbWFqb3JUaWNrcyddLCB7XG4gICAgICBvcGFjaXR5OiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2F4aXMnXSwge1xuICAgICAgb3BhY2l0eToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGlzQ29sKSB7XG4gICAgZGVmLm9yaWVudCA9ICd0b3AnO1xuICB9XG5cbiAgaWYgKGlzUm93KSB7XG4gICAgZGVmLm9mZnNldCA9IHJvd09mZnNldDtcbiAgfVxuXG4gIGlmIChuYW1lID09IFgpIHtcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFkpICYmIGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFkpICYmIGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA+IDMwKSB7XG4gICAgICBkZWYub3JpZW50ID0gJ3RvcCc7XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nLmlzRGltZW5zaW9uKFgpIHx8IGVuY29kaW5nLmlzVHlwZShYLCBUKSkge1xuICAgICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJ10sIHtcbiAgICAgICAgYW5nbGU6IHt2YWx1ZTogMjcwfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogJ3JpZ2h0J30sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHsgLy8gUVxuICAgICAgZGVmLnRpY2tzID0gNTtcbiAgICB9XG4gIH1cblxuICBkZWYgPSBheGlzX2xhYmVscyhkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCk7XG5cbiAgcmV0dXJuIGRlZjtcbn07XG5cbmZ1bmN0aW9uIGF4aXNfdGl0bGUoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpIHtcbiAgdmFyIG1heGxlbmd0aCA9IG51bGwsXG4gICAgZmllbGRUaXRsZSA9IGVuY29kaW5nLmZpZWxkVGl0bGUobmFtZSk7XG4gIGlmIChuYW1lPT09WCkge1xuICAgIG1heGxlbmd0aCA9IGxheW91dC5jZWxsV2lkdGggLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gIH0gZWxzZSBpZiAobmFtZSA9PT0gWSkge1xuICAgIG1heGxlbmd0aCA9IGxheW91dC5jZWxsSGVpZ2h0IC8gZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpO1xuICB9XG5cbiAgZGVmLnRpdGxlID0gbWF4bGVuZ3RoID8gdXRpbC50cnVuY2F0ZShmaWVsZFRpdGxlLCBtYXhsZW5ndGgpIDogZmllbGRUaXRsZTtcblxuICBpZiAobmFtZSA9PT0gUk9XKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywndGl0bGUnXSwge1xuICAgICAgYW5nbGU6IHt2YWx1ZTogMH0sXG4gICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgIGJhc2VsaW5lOiB7dmFsdWU6ICdtaWRkbGUnfSxcbiAgICAgIGR5OiB7dmFsdWU6ICgtbGF5b3V0LmhlaWdodC8yKSAtMjB9XG4gICAgfSk7XG4gIH1cblxuICBkZWYudGl0bGVPZmZzZXQgPSBheGlzVGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSk7XG4gIHJldHVybiBkZWY7XG59XG5cbmZ1bmN0aW9uIGF4aXNfbGFiZWxzKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KSB7XG4gIHZhciBmbjtcbiAgLy8gYWRkIGN1c3RvbSBsYWJlbCBmb3IgdGltZSB0eXBlXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgKGZuID0gZW5jb2RpbmcuZm4obmFtZSkpICYmICh0aW1lLmhhc1NjYWxlKGZuKSkpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0Jywnc2NhbGUnXSwgJ3RpbWUtJysgZm4pO1xuICB9XG5cbiAgdmFyIHRleHRUZW1wbGF0ZVBhdGggPSBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnLCd0ZXh0JywndGVtcGxhdGUnXTtcbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkuZm9ybWF0KSB7XG4gICAgZGVmLmZvcm1hdCA9IGVuY29kaW5nLmF4aXMobmFtZSkuZm9ybWF0O1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBRKSkge1xuICAgIHNldHRlcihkZWYsIHRleHRUZW1wbGF0ZVBhdGgsIFwie3tkYXRhIHwgbnVtYmVyOicuM3MnfX1cIik7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmICFlbmNvZGluZy5mbihuYW1lKSkge1xuICAgIHNldHRlcihkZWYsIHRleHRUZW1wbGF0ZVBhdGgsIFwie3tkYXRhIHwgdGltZTonJVktJW0tJWQnfX1cIik7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIGVuY29kaW5nLmZuKG5hbWUpID09PSAneWVhcicpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCBcInt7ZGF0YSB8IG51bWJlcjonZCd9fVwiKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgTykgJiYgZW5jb2RpbmcuYXhpcyhuYW1lKS5tYXhMYWJlbExlbmd0aCkge1xuICAgIHNldHRlcihkZWYsIHRleHRUZW1wbGF0ZVBhdGgsICd7e2RhdGEgfCB0cnVuY2F0ZTonICsgZW5jb2RpbmcuYXhpcyhuYW1lKS5tYXhMYWJlbExlbmd0aCArICd9fScpO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn1cblxuZnVuY3Rpb24gYXhpc1RpdGxlT2Zmc2V0KGVuY29kaW5nLCBsYXlvdXQsIG5hbWUpIHtcbiAgdmFyIHZhbHVlID0gZW5jb2RpbmcuYXhpcyhuYW1lKS50aXRsZU9mZnNldDtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgUk9XOiByZXR1cm4gMDtcbiAgICBjYXNlIENPTDogcmV0dXJuIDM1O1xuICB9XG4gIHJldHVybiBnZXR0ZXIobGF5b3V0LCBbbmFtZSwgJ2F4aXNUaXRsZU9mZnNldCddKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmlubmluZztcblxuZnVuY3Rpb24gYmlubmluZyhzcGVjLCBlbmNvZGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGJpbnMgPSB7fTtcblxuICBpZiAob3B0LnByZWFnZ3JlZ2F0ZWREYXRhKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFzcGVjLnRyYW5zZm9ybSkgc3BlYy50cmFuc2Zvcm0gPSBbXTtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgaWYgKGVuY29kaW5nLmJpbihlbmNUeXBlKSkge1xuICAgICAgc3BlYy50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdiaW4nLFxuICAgICAgICBmaWVsZDogJ2RhdGEuJyArIGZpZWxkLm5hbWUsXG4gICAgICAgIG91dHB1dDogJ2RhdGEuYmluXycgKyBmaWVsZC5uYW1lLFxuICAgICAgICBtYXhiaW5zOiBlbmNvZGluZy5iaW4oZW5jVHlwZSkubWF4Ymluc1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcblxudmFyIHRlbXBsYXRlID0gY29tcGlsZS50ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKSxcbiAgYXhpcyA9IGNvbXBpbGUuYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBmaWx0ZXIgPSBjb21waWxlLmZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyksXG4gIGxlZ2VuZCA9IGNvbXBpbGUubGVnZW5kID0gcmVxdWlyZSgnLi9sZWdlbmQnKSxcbiAgbWFya3MgPSBjb21waWxlLm1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpLFxuICBzY2FsZSA9IGNvbXBpbGUuc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyksXG4gIHZsc29ydCA9IGNvbXBpbGUuc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpLFxuICB2bHN0eWxlID0gY29tcGlsZS5zdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKSxcbiAgdGltZSA9IGNvbXBpbGUudGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICBhZ2dyZWdhdGVzID0gY29tcGlsZS5hZ2dyZWdhdGVzID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGVzJyksXG4gIGJpbm5pbmcgPSBjb21waWxlLmJpbm5pbmcgPSByZXF1aXJlKCcuL2Jpbm5pbmcnKSxcbiAgZmFjZXRpbmcgPSBjb21waWxlLmZhY2V0aW5nID0gcmVxdWlyZSgnLi9mYWNldGluZycpLFxuICBzdGFja2luZyA9IGNvbXBpbGUuc3RhY2tpbmcgPSByZXF1aXJlKCcuL3N0YWNraW5nJyksXG4gIHN1YmZhY2V0aW5nID0gY29tcGlsZS5zdWJmYWNldGluZyA9IHJlcXVpcmUoJy4vc3ViZmFjZXRpbmcnKTtcblxuY29tcGlsZS5sYXlvdXQgPSByZXF1aXJlKCcuL2xheW91dCcpO1xuY29tcGlsZS5ncm91cCA9IHJlcXVpcmUoJy4vZ3JvdXAnKTtcblxuZnVuY3Rpb24gY29tcGlsZShlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGxheW91dCA9IGNvbXBpbGUubGF5b3V0KGVuY29kaW5nLCBzdGF0cyksXG4gICAgc3R5bGUgPSB2bHN0eWxlKGVuY29kaW5nLCBzdGF0cyksXG4gICAgc3BlYyA9IHRlbXBsYXRlKGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSxcbiAgICBncm91cCA9IHNwZWMubWFya3NbMF0sXG4gICAgbWFyayA9IG1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLFxuICAgIG1kZWZzID0gbWFya3MuZGVmKG1hcmssIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlKSxcbiAgICBtZGVmID0gbWRlZnNbMF07ICAvLyBUT0RPOiByZW1vdmUgdGhpcyBkaXJ0eSBoYWNrIGJ5IHJlZmFjdG9yaW5nIHRoZSB3aG9sZSBmbG93XG5cbiAgZmlsdGVyLmFkZEZpbHRlcnMoc3BlYywgZW5jb2RpbmcpO1xuICB2YXIgc29ydGluZyA9IHZsc29ydChzcGVjLCBlbmNvZGluZywgc3RhdHMpO1xuXG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSwgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCk7XG5cbiAgdmFyIHByZWFnZ3JlZ2F0ZWREYXRhID0gZW5jb2RpbmcuY29uZmlnKCd1c2VWZWdhU2VydmVyJyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZGVmcy5sZW5ndGg7IGkrKykge1xuICAgIGdyb3VwLm1hcmtzLnB1c2gobWRlZnNbaV0pO1xuICB9XG5cbiAgYmlubmluZyhzcGVjLmRhdGFbMV0sIGVuY29kaW5nLCB7cHJlYWdncmVnYXRlZERhdGE6IHByZWFnZ3JlZ2F0ZWREYXRhfSk7XG5cbiAgdmFyIGxpbmVUeXBlID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0ubGluZTtcblxuICBpZiAoIXByZWFnZ3JlZ2F0ZWREYXRhKSB7XG4gICAgc3BlYyA9IHRpbWUoc3BlYywgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmZhY2V0c1xuICB2YXIgYWdnUmVzdWx0ID0gYWdncmVnYXRlcyhzcGVjLCBlbmNvZGluZywge3ByZWFnZ3JlZ2F0ZWREYXRhOiBwcmVhZ2dyZWdhdGVkRGF0YX0pLFxuICAgIGRldGFpbHMgPSBhZ2dSZXN1bHQuZGV0YWlscyxcbiAgICBoYXNEZXRhaWxzID0gZGV0YWlscyAmJiBkZXRhaWxzLmxlbmd0aCA+IDAsXG4gICAgc3RhY2sgPSBoYXNEZXRhaWxzICYmIHN0YWNraW5nKHNwZWMsIGVuY29kaW5nLCBtZGVmLCBhZ2dSZXN1bHQuZmFjZXRzKTtcblxuICBpZiAoaGFzRGV0YWlscyAmJiAoc3RhY2sgfHwgbGluZVR5cGUpKSB7XG4gICAgLy9zdWJmYWNldCB0byBncm91cCBzdGFjayAvIGxpbmUgdG9nZXRoZXIgaW4gb25lIGdyb3VwXG4gICAgc3ViZmFjZXRpbmcoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhdXRvLXNvcnQgbGluZS9hcmVhIHZhbHVlc1xuICAvL1RPRE8oa2FuaXR3KTogaGF2ZSBzb21lIGNvbmZpZyB0byB0dXJuIG9mZiBhdXRvLXNvcnQgZm9yIGxpbmUgKGZvciBsaW5lIGNoYXJ0IHRoYXQgZW5jb2RlcyB0ZW1wb3JhbCBpbmZvcm1hdGlvbilcbiAgaWYgKGxpbmVUeXBlKSB7XG4gICAgdmFyIGYgPSAoZW5jb2RpbmcuaXNNZWFzdXJlKFgpICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFkpKSA/IFkgOiBYO1xuICAgIGlmICghbWRlZi5mcm9tKSBtZGVmLmZyb20gPSB7fTtcbiAgICAvLyBUT0RPOiB3aHkgLSA/XG4gICAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7dHlwZTogJ3NvcnQnLCBieTogJy0nICsgZW5jb2RpbmcuZmllbGQoZil9XTtcbiAgfVxuXG4gIC8vIFNtYWxsIE11bHRpcGxlc1xuICBpZiAoaGFzUm93IHx8IGhhc0NvbCkge1xuICAgIHNwZWMgPSBmYWNldGluZyhncm91cCwgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHNvcnRpbmcsIHNwZWMsIG1kZWYsIHN0YWNrLCBzdGF0cyk7XG4gICAgc3BlYy5sZWdlbmRzID0gbGVnZW5kLmRlZnMoZW5jb2RpbmcpO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwLnNjYWxlcyA9IHNjYWxlLmRlZnMoc2NhbGUubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSksIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLFxuICAgICAge3N0YWNrOiBzdGFjaywgc3RhdHM6IHN0YXRzfSk7XG4gICAgZ3JvdXAuYXhlcyA9IGF4aXMuZGVmcyhheGlzLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cyk7XG4gICAgZ3JvdXAubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nKTtcbiAgfVxuXG4gIGZpbHRlci5maWx0ZXJMZXNzVGhhblplcm8oc3BlYywgZW5jb2RpbmcpO1xuXG4gIHJldHVybiBzcGVjO1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWYsXG4gIHNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY2V0aW5nO1xuXG5mdW5jdGlvbiBmYWNldGluZyhncm91cCwgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHNvcnRpbmcsIHNwZWMsIG1kZWYsIHN0YWNrLCBzdGF0cykge1xuICB2YXIgZW50ZXIgPSBncm91cC5wcm9wZXJ0aWVzLmVudGVyO1xuICB2YXIgZmFjZXRLZXlzID0gW10sIGNlbGxBeGVzID0gW10sIGZyb20sIGF4ZXNHcnA7XG5cbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLCBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKTtcblxuICBlbnRlci5maWxsID0ge3ZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxCYWNrZ3JvdW5kQ29sb3InKX07XG5cbiAgLy9tb3ZlIFwiZnJvbVwiIHRvIGNlbGwgbGV2ZWwgYW5kIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgZ3JvdXAuZnJvbSA9IHtkYXRhOiBncm91cC5tYXJrc1swXS5mcm9tLmRhdGF9O1xuXG4gIC8vIEhhY2ssIHRoaXMgbmVlZHMgdG8gYmUgcmVmYWN0b3JlZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcmsgPSBncm91cC5tYXJrc1tpXTtcbiAgICBpZiAobWFyay5mcm9tLnRyYW5zZm9ybSkge1xuICAgICAgZGVsZXRlIG1hcmsuZnJvbS5kYXRhOyAvL25lZWQgdG8ga2VlcCB0cmFuc2Zvcm0gZm9yIHN1YmZhY2V0dGluZyBjYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb207XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1Jvdykge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oUk9XKSkge1xuICAgICAgdXRpbC5lcnJvcignUm93IGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci55ID0ge3NjYWxlOiBST1csIGZpZWxkOiAna2V5cy4nICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgZW50ZXIuaGVpZ2h0ID0geyd2YWx1ZSc6IGxheW91dC5jZWxsSGVpZ2h0fTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGQoUk9XKSk7XG5cbiAgICBpZiAoaGFzQ29sKSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogW2VuY29kaW5nLmZpZWxkKENPTCldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd4LWF4ZXMnLCB7XG4gICAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhYKSA/IGF4aXMuZGVmcyhbJ3gnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIDogdW5kZWZpbmVkLFxuICAgICAgICB4OiBoYXNDb2wgPyB7c2NhbGU6IENPTCwgZmllbGQ6ICdrZXlzLjAnfSA6IHt2YWx1ZTogMH0sXG4gICAgICAgIHdpZHRoOiBoYXNDb2wgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9LCAvL0hBQ0s/XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaC5hcHBseShzcGVjLmF4ZXMsIGF4aXMuZGVmcyhbJ3JvdyddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgcm93XG4gICAgaWYgKGVuY29kaW5nLmhhcyhYKSkge1xuICAgICAgLy9rZWVwIHggYXhpcyBpbiB0aGUgY2VsbFxuICAgICAgY2VsbEF4ZXMucHVzaC5hcHBseShjZWxsQXhlcywgYXhpcy5kZWZzKFsneCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNDb2wpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKENPTCkpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ0NvbCBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueCA9IHtzY2FsZTogQ09MLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLndpZHRoID0geyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9OyAvLyBIQUNLXG5cbiAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZChDT0wpKTtcblxuICAgIGlmIChoYXNSb3cpIHtcbiAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgIGZyb20udHJhbnNmb3JtID0gZnJvbS50cmFuc2Zvcm0gfHwgW107XG4gICAgICBmcm9tLnRyYW5zZm9ybS51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBbZW5jb2RpbmcuZmllbGQoUk9XKV19KTtcbiAgICB9XG5cbiAgICBheGVzR3JwID0gZ3JvdXBkZWYoJ3ktYXhlcycsIHtcbiAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhZKSA/IGF4aXMuZGVmcyhbJ3knXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIDogdW5kZWZpbmVkLFxuICAgICAgeTogaGFzUm93ICYmIHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuMCd9LFxuICAgICAgeDogaGFzUm93ICYmIHt2YWx1ZTogMH0sXG4gICAgICBoZWlnaHQ6IGhhc1JvdyAmJiB7J3ZhbHVlJzogbGF5b3V0LmNlbGxIZWlnaHR9LCAvL0hBQ0s/XG4gICAgICBmcm9tOiBmcm9tXG4gICAgfSk7XG5cbiAgICBzcGVjLm1hcmtzLnVuc2hpZnQoYXhlc0dycCk7IC8vIG5lZWQgdG8gcHJlcGVuZCBzbyBpdCBhcHBlYXJzIHVuZGVyIHRoZSBwbG90c1xuICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgIHNwZWMuYXhlcy5wdXNoLmFwcGx5KHNwZWMuYXhlcywgYXhpcy5kZWZzKFsnY29sJ10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSBjb2xcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFkpKSB7XG4gICAgICBjZWxsQXhlcy5wdXNoLmFwcGx5KGNlbGxBeGVzLCBheGlzLmRlZnMoWyd5J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzdW1pbmcgZXF1YWwgY2VsbFdpZHRoIGhlcmVcbiAgLy8gVE9ETzogc3VwcG9ydCBoZXRlcm9nZW5vdXMgY2VsbFdpZHRoIChtYXliZSBieSB1c2luZyBtdWx0aXBsZSBzY2FsZXM/KVxuICBzcGVjLnNjYWxlcyA9IChzcGVjLnNjYWxlcyB8fCBbXSkuY29uY2F0KHNjYWxlLmRlZnMoXG4gICAgc2NhbGUubmFtZXMoZW50ZXIpLmNvbmNhdChzY2FsZS5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSksXG4gICAgZW5jb2RpbmcsXG4gICAgbGF5b3V0LFxuICAgIHN0eWxlLFxuICAgIHNvcnRpbmcsXG4gICAge3N0YWNrOiBzdGFjaywgZmFjZXQ6IHRydWUsIHN0YXRzOiBzdGF0c31cbiAgKSk7IC8vIHJvdy9jb2wgc2NhbGVzICsgY2VsbCBzY2FsZXNcblxuICBpZiAoY2VsbEF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGdyb3VwLmF4ZXMgPSBjZWxsQXhlcztcbiAgfVxuXG4gIC8vIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgdmFyIHRyYW5zID0gKGdyb3VwLmZyb20udHJhbnNmb3JtIHx8IChncm91cC5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGZhY2V0S2V5c30pO1xuXG4gIHJldHVybiBzcGVjO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGZpbHRlciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBCSU5BUlkgPSB7XG4gICc+JzogIHRydWUsXG4gICc+PSc6IHRydWUsXG4gICc9JzogIHRydWUsXG4gICchPSc6IHRydWUsXG4gICc8JzogIHRydWUsXG4gICc8PSc6IHRydWVcbn07XG5cbmZpbHRlci5hZGRGaWx0ZXJzID0gZnVuY3Rpb24oc3BlYywgZW5jb2RpbmcpIHtcbiAgdmFyIGZpbHRlcnMgPSBlbmNvZGluZy5maWx0ZXIoKSxcbiAgICBkYXRhID0gc3BlYy5kYXRhWzBdOyAgLy8gYXBwbHkgZmlsdGVycyB0byByYXcgZGF0YSBiZWZvcmUgYWdncmVnYXRpb25cblxuICBpZiAoIWRhdGEudHJhbnNmb3JtKVxuICAgIGRhdGEudHJhbnNmb3JtID0gW107XG5cbiAgLy8gYWRkIGN1c3RvbSBmaWx0ZXJzXG4gIGZvciAodmFyIGkgaW4gZmlsdGVycykge1xuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuXG4gICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuICAgIHZhciBvcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcbiAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIub3BlcmFuZHM7XG5cbiAgICBpZiAoQklOQVJZW29wZXJhdG9yXSkge1xuICAgICAgLy8gZXhwZWN0cyBhIGZpZWxkIGFuZCBhIHZhbHVlXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgICBvcGVyYXRvciA9ICc9PSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcDEgPSBvcGVyYW5kc1swXTtcbiAgICAgIHZhciBvcDIgPSBvcGVyYW5kc1sxXTtcbiAgICAgIGNvbmRpdGlvbiA9ICdkLmRhdGEuJyArIG9wMSArIG9wZXJhdG9yICsgb3AyO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3ROdWxsJykge1xuICAgICAgLy8gZXhwZWN0cyBhIG51bWJlciBvZiBmaWVsZHNcbiAgICAgIGZvciAodmFyIGogaW4gb3BlcmFuZHMpIHtcbiAgICAgICAgY29uZGl0aW9uICs9ICdkLmRhdGEuJyArIG9wZXJhbmRzW2pdICsgJyE9PW51bGwnO1xuICAgICAgICBpZiAoaiA8IG9wZXJhbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25kaXRpb24gKz0gJyAmJiAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcsIG9wZXJhdG9yKTtcbiAgICB9XG5cbiAgICBkYXRhLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgdGVzdDogY29uZGl0aW9uXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHJlbW92ZSBsZXNzIHRoYW4gMCB2YWx1ZXMgaWYgd2UgdXNlIGxvZyBmdW5jdGlvblxuZmlsdGVyLmZpbHRlckxlc3NUaGFuWmVybyA9IGZ1bmN0aW9uKHNwZWMsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2Rpbmcuc2NhbGUoZW5jVHlwZSkudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgIHNwZWMuZGF0YVsxXS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgICB0ZXN0OiAnZC4nICsgZW5jb2RpbmcuZmllbGQoZW5jVHlwZSkgKyAnPjAnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmOiBncm91cGRlZlxufTtcblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBfbmFtZTogbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgdHlwZTogJ2dyb3VwJyxcbiAgICBmcm9tOiBvcHQuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiBvcHQueCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHk6IG9wdC55IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IG9wdC53aWR0aCB8fCB7Z3JvdXA6ICd3aWR0aCd9LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2dyb3VwOiAnaGVpZ2h0J31cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjYWxlczogb3B0LnNjYWxlcyB8fCB1bmRlZmluZWQsXG4gICAgYXhlczogb3B0LmF4ZXMgfHwgdW5kZWZpbmVkLFxuICAgIG1hcmtzOiBvcHQubWFya3MgfHwgW11cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEvc2NoZW1hJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdmxsYXlvdXQ7XG5cbmZ1bmN0aW9uIHZsbGF5b3V0KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgbGF5b3V0ID0gYm94KGVuY29kaW5nLCBzdGF0cyk7XG4gIGxheW91dCA9IG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qXG4gIEhBQ0sgdG8gc2V0IGNoYXJ0IHNpemVcbiAgTk9URTogdGhpcyBmYWlscyBmb3IgcGxvdHMgZHJpdmVuIGJ5IGRlcml2ZWQgdmFsdWVzIChlLmcuLCBhZ2dyZWdhdGVzKVxuICBPbmUgc29sdXRpb24gaXMgdG8gdXBkYXRlIFZlZ2EgdG8gc3VwcG9ydCBhdXRvLXNpemluZ1xuICBJbiB0aGUgbWVhbnRpbWUsIGF1dG8tcGFkZGluZyAobW9zdGx5KSBkb2VzIHRoZSB0cmlja1xuICovXG5mdW5jdGlvbiBib3goZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSxcbiAgICAgIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpLFxuICAgICAgaGFzWCA9IGVuY29kaW5nLmhhcyhYKSxcbiAgICAgIGhhc1kgPSBlbmNvZGluZy5oYXMoWSksXG4gICAgICBtYXJrdHlwZSA9IGVuY29kaW5nLm1hcmt0eXBlKCk7XG5cbiAgLy8gRklYTUUvSEFDSyB3ZSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuICB2YXIgeENhcmRpbmFsaXR5ID0gaGFzWCAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihYKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFgsIHN0YXRzKSA6IDEsXG4gICAgeUNhcmRpbmFsaXR5ID0gaGFzWSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA6IDE7XG5cbiAgdmFyIHVzZVNtYWxsQmFuZCA9IHhDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKSB8fFxuICAgIHlDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKTtcblxuICB2YXIgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBjZWxsUGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcblxuICAvLyBzZXQgY2VsbFdpZHRoXG4gIGlmIChoYXNYKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFgpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbFdpZHRoID0gKHhDYXJkaW5hbGl0eSArIGVuY29kaW5nLmJhbmQoWCkucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShYLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZW5jKENPTCkud2lkdGggOiAgZW5jb2RpbmcuY29uZmlnKFwic2luZ2xlV2lkdGhcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuY29uZmlnKCd0ZXh0Q2VsbFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBjZWxsSGVpZ2h0XG4gIGlmIChoYXNZKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFkpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbEhlaWdodCA9ICh5Q2FyZGluYWxpdHkgKyBlbmNvZGluZy5iYW5kKFkpLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWSwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbEhlaWdodCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5lbmMoUk9XKS5oZWlnaHQgOiAgZW5jb2RpbmcuY29uZmlnKFwic2luZ2xlSGVpZ2h0XCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjZWxsSGVpZ2h0ID0gZW5jb2RpbmcuYmFuZFNpemUoWSk7XG4gIH1cblxuICAvLyBDZWxsIGJhbmRzIHVzZSByYW5nZUJhbmRzKCkuIFRoZXJlIGFyZSBuLTEgcGFkZGluZy4gIE91dGVycGFkZGluZyA9IDAgZm9yIGNlbGxzXG5cbiAgdmFyIHdpZHRoID0gY2VsbFdpZHRoLCBoZWlnaHQgPSBjZWxsSGVpZ2h0O1xuICBpZiAoaGFzQ29sKSB7XG4gICAgdmFyIGNvbENhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MLCBzdGF0cyk7XG4gICAgd2lkdGggPSBjZWxsV2lkdGggKiAoKDEgKyBjZWxsUGFkZGluZykgKiAoY29sQ2FyZGluYWxpdHkgLSAxKSArIDEpO1xuICB9XG4gIGlmIChoYXNSb3cpIHtcbiAgICB2YXIgcm93Q2FyZGluYWxpdHkgPSAgZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgaGVpZ2h0ID0gY2VsbEhlaWdodCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChyb3dDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdob2xlIGNlbGxcbiAgICBjZWxsV2lkdGg6IGNlbGxXaWR0aCxcbiAgICBjZWxsSGVpZ2h0OiBjZWxsSGVpZ2h0LFxuICAgIGNlbGxQYWRkaW5nOiBjZWxsUGFkZGluZyxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjaGFydFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCB4IGFuZCB5LCBzdWNoIGFzIGJhbmQgc2l6ZVxuICAgIHg6IHt1c2VTbWFsbEJhbmQ6IHVzZVNtYWxsQmFuZH0sXG4gICAgeToge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoZW5jb2RpbmcsIHN0YXRzLCBsYXlvdXQpIHtcbiAgW1gsIFldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICB2YXIgbWF4TGVuZ3RoO1xuICAgIGlmIChlbmNvZGluZy5pc0RpbWVuc2lvbih4KSB8fCBlbmNvZGluZy5pc1R5cGUoeCwgVCkpIHtcbiAgICAgIG1heExlbmd0aCA9IHN0YXRzW2VuY29kaW5nLmZpZWxkTmFtZSh4KV0ubWF4bGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcuYWdncih4KSA9PT0gJ2NvdW50Jykge1xuICAgICAgLy9hc3NpZ24gZGVmYXVsdCB2YWx1ZSBmb3IgY291bnQgYXMgaXQgd29uJ3QgaGF2ZSBzdGF0c1xuICAgICAgbWF4TGVuZ3RoID0gIDM7XG4gICAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUoeCwgUSkpIHtcbiAgICAgIGlmICh4PT09WCkge1xuICAgICAgICBtYXhMZW5ndGggPSAzO1xuICAgICAgfSBlbHNlIHsgLy8gWVxuICAgICAgICAvL2Fzc3VtZSB0aGF0IGRlZmF1bHQgZm9ybWF0aW5nIGlzIGFsd2F5cyBzaG9ydGVyIHRoYW4gN1xuICAgICAgICBtYXhMZW5ndGggPSBNYXRoLm1pbihzdGF0c1tlbmNvZGluZy5maWVsZE5hbWUoeCldLm1heGxlbmd0aCwgNyk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldHRlcihsYXlvdXQsW3gsICdheGlzVGl0bGVPZmZzZXQnXSwgZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpICogIG1heExlbmd0aCArIDIwKTtcbiAgfSk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGxlZ2VuZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmxlZ2VuZC5kZWZzID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIGRlZnMgPSBbXTtcblxuICAvLyBUT0RPOiBzdXBwb3J0IGFscGhhXG5cbiAgaWYgKGVuY29kaW5nLmhhcyhDT0xPUikgJiYgZW5jb2RpbmcubGVnZW5kKENPTE9SKSkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKENPTE9SLCBlbmNvZGluZywge1xuICAgICAgZmlsbDogQ09MT1IsXG4gICAgICBvcmllbnQ6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNJWkUpICYmIGVuY29kaW5nLmxlZ2VuZChTSVpFKSkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNJWkUsIGVuY29kaW5nLCB7XG4gICAgICBzaXplOiBTSVpFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNIQVBFKSAmJiBlbmNvZGluZy5sZWdlbmQoU0hBUEUpKSB7XG4gICAgaWYgKGRlZnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBUT0RPOiBmaXggdGhpc1xuICAgICAgY29uc29sZS5lcnJvcignVmVnYWxpdGUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdHdvIGxlZ2VuZHMnKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihTSEFQRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNoYXBlOiBTSEFQRSxcbiAgICAgIG9yaWVudDogZGVmcy5sZW5ndGggPT09IDEgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5sZWdlbmQuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHByb3BzKSB7XG4gIHZhciBkZWYgPSBwcm9wcywgZm47XG5cbiAgZGVmLnRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIChmbiA9IGVuY29kaW5nLmZuKG5hbWUpKSAmJlxuICAgIHRpbWUuaGFzU2NhbGUoZm4pKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBkZWYucHJvcGVydGllcyA9IGRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgbGFiZWxzID0gcHJvcGVydGllcy5sYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyB8fCB7fSxcbiAgICAgIHRleHQgPSBsYWJlbHMudGV4dCA9IGxhYmVscy50ZXh0IHx8IHt9O1xuXG4gICAgdGV4dC5zY2FsZSA9ICd0aW1lLScrIGZuO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB2bHNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXJrcy5kZWYgPSBmdW5jdGlvbihtYXJrLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgZGVmcyA9IFtdO1xuXG4gIC8vIHRvIGFkZCBhIGJhY2tncm91bmQgdG8gdGV4dCwgd2UgbmVlZCB0byBhZGQgaXQgYmVmb3JlIHRoZSB0ZXh0XG4gIGlmIChlbmNvZGluZy5tYXJrdHlwZSgpID09PSBURVhUICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB2YXIgYmcgPSB7XG4gICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgeToge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGh9LFxuICAgICAgeTI6IHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9LFxuICAgICAgZmlsbDoge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGVuY29kaW5nLmZpZWxkKENPTE9SKX1cbiAgICB9O1xuICAgIGRlZnMucHVzaCh7XG4gICAgICB0eXBlOiAncmVjdCcsXG4gICAgICBmcm9tOiB7ZGF0YTogVEFCTEV9LFxuICAgICAgcHJvcGVydGllczoge2VudGVyOiBiZywgdXBkYXRlOiBiZ31cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGFkZCB0aGUgbWFyayBkZWYgZm9yIHRoZSBtYWluIHRoaW5nXG4gIHZhciBwID0gbWFyay5wcm9wKGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlKTtcbiAgZGVmcy5wdXNoKHtcbiAgICB0eXBlOiBtYXJrLnR5cGUsXG4gICAgZnJvbToge2RhdGE6IFRBQkxFfSxcbiAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IHAsIHVwZGF0ZTogcH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5tYXJrcy5iYXIgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc3RhY2s6IHRydWUsXG4gIHByb3A6IGJhcl9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxfVxufTtcblxubWFya3MubGluZSA9IHtcbiAgdHlwZTogJ2xpbmUnLFxuICBsaW5lOiB0cnVlLFxuICBwcm9wOiBsaW5lX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIGRldGFpbDoxfVxufTtcblxubWFya3MuYXJlYSA9IHtcbiAgdHlwZTogJ2FyZWEnLFxuICBzdGFjazogdHJ1ZSxcbiAgbGluZTogdHJ1ZSxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgcHJvcDogYXJlYV9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGFscGhhOiAxfVxufTtcblxubWFya3MudGljayA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBwcm9wOiB0aWNrX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLmNpcmNsZSA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcygnY2lyY2xlJyksXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3Muc3F1YXJlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdzcXVhcmUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IG1hcmtzLmNpcmNsZS5zdXBwb3J0ZWRFbmNvZGluZ1xufTtcblxubWFya3MucG9pbnQgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBwb2ludF9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCBzaGFwZTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3MudGV4dCA9IHtcbiAgdHlwZTogJ3RleHQnLFxuICBwcm9wOiB0ZXh0X3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3RleHQnXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCB0ZXh0OiAxfVxufTtcblxuZnVuY3Rpb24gYmFyX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogZS5zY2FsZShYKS50eXBlID09PSAnbG9nJyA/IDEgOiAwfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHsgLy8gaXMgb3JkaW5hbFxuICAgIHAueGMgPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPIGFkZCBzaW5nbGUgYmFyIG9mZnNldFxuICAgIHAueGMgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogZS5zY2FsZShZKS50eXBlID09PSAnbG9nJyA/IDEgOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gYWRkIHNpbmdsZSBiYXIgb2Zmc2V0XG4gICAgcC55YyA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzT3JkaW5hbFNjYWxlKFgpKSB7IC8vIG5vIFggb3IgWCBpcyBvcmRpbmFsXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAud2lkdGggPSB7XG4gICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCksXG4gICAgICAgIG9mZnNldDogLTFcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgeyAvLyBYIGlzIFF1YW50IG9yIFRpbWUgU2NhbGVcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAyfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWSkpIHsgLy8gbm8gWSBvciBZIGlzIG9yZGluYWxcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuaGVpZ2h0ID0ge1xuICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpLFxuICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gWSBpcyBRdWFudCBvciBUaW1lIFNjYWxlXG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IDJ9O1xuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwb2ludF9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICB9XG5cbiAgLy8gc2hhcGVcbiAgaWYgKGUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7c2NhbGU6IFNIQVBFLCBmaWVsZDogZS5maWVsZChTSEFQRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBlLnZhbHVlKFNIQVBFKX07XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBzdHlsZS5vcGFjaXR5fTtcbiAgfVxuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gbGluZV9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9XG5cbiAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBhcmVhX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgICBwLm9yaWVudCA9IHt2YWx1ZTogJ2hvcml6b250YWwnfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogMH07XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdGlja19wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihYKSkge1xuICAgICAgcC54Lm9mZnNldCA9IC1lLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC55Lm9mZnNldCA9IC1lLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGZpbGxlZF9wb2ludF9wcm9wcyhzaGFwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZSwgbGF5b3V0LCBzdHlsZSkge1xuICAgIHZhciBwID0ge307XG5cbiAgICAvLyB4XG4gICAgaWYgKGUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG5cbiAgICAvLyB5XG4gICAgaWYgKGUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG5cbiAgICAvLyBzaXplXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC5zaXplID0ge3ZhbHVlOiBlLnZhbHVlKFNJWkUpfTtcbiAgICB9XG5cbiAgICAvLyBzaGFwZVxuICAgIHAuc2hhcGUgPSB7dmFsdWU6IHNoYXBlfTtcblxuICAgIC8vIGZpbGxcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgfVxuXG4gICAgLy8gYWxwaGFcbiAgICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICAgIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIGlmIChlLmhhcyhURVhUKSAmJiBlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgcC54ID0ge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRoLTV9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgfVxuXG4gIC8vIHNpemVcbiAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuZm9udFNpemUgPSB7dmFsdWU6IGUuZm9udCgnc2l6ZScpfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgLy8gY29sb3Igc2hvdWxkIGJlIHNldCB0byBiYWNrZ3JvdW5kXG4gIHAuZmlsbCA9IHt2YWx1ZTogJ2JsYWNrJ307XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2Uge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gIH1cblxuICAvLyB0ZXh0XG4gIGlmIChlLmhhcyhURVhUKSkge1xuICAgIGlmIChlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgcC50ZXh0ID0ge3RlbXBsYXRlOiBcInt7XCIgKyBlLmZpZWxkKFRFWFQpICsgXCIgfCBudW1iZXI6Jy4zcyd9fVwifTtcbiAgICAgIHAuYWxpZ24gPSB7dmFsdWU6ICdyaWdodCd9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnRleHQgPSB7ZmllbGQ6IGUuZmllbGQoVEVYVCl9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLnRleHQgPSB7dmFsdWU6ICdBYmMnfTtcbiAgfVxuXG4gIHAuZm9udCA9IHt2YWx1ZTogZS5mb250KCdmYW1pbHknKX07XG4gIHAuZm9udFdlaWdodCA9IHt2YWx1ZTogZS5mb250KCd3ZWlnaHQnKX07XG4gIHAuZm9udFN0eWxlID0ge3ZhbHVlOiBlLmZvbnQoJ3N0eWxlJyl9O1xuICBwLmJhc2VsaW5lID0ge3ZhbHVlOiBlLnRleHQoJ2Jhc2VsaW5lJyl9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgc2NhbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5zY2FsZS5uYW1lcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIGlmIChwcm9wc1t4XSAmJiBwcm9wc1t4XS5zY2FsZSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuc2NhbGUuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGEsIG5hbWUpIHtcbiAgICB2YXIgcyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0eXBlOiBzY2FsZS50eXBlKG5hbWUsIGVuY29kaW5nKSxcbiAgICAgIGRvbWFpbjogc2NhbGVfZG9tYWluKG5hbWUsIGVuY29kaW5nLCBzb3J0aW5nLCBvcHQpXG4gICAgfTtcbiAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcgJiYgIWVuY29kaW5nLmJpbihuYW1lKSAmJiBlbmNvZGluZy5zb3J0KG5hbWUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcy5zb3J0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY2FsZV9yYW5nZShzLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgb3B0KTtcblxuICAgIHJldHVybiAoYS5wdXNoKHMpLCBhKTtcbiAgfSwgW10pO1xufTtcblxuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nKSB7XG5cbiAgc3dpdGNoIChlbmNvZGluZy50eXBlKG5hbWUpKSB7XG4gICAgY2FzZSBPOiByZXR1cm4gJ29yZGluYWwnO1xuICAgIGNhc2UgVDpcbiAgICAgIHZhciBmbiA9IGVuY29kaW5nLmZuKG5hbWUpO1xuICAgICAgcmV0dXJuIChmbiAmJiB0aW1lLnNjYWxlLnR5cGUoZm4sIG5hbWUpKSB8fCAndGltZSc7XG4gICAgY2FzZSBROlxuICAgICAgaWYgKGVuY29kaW5nLmJpbihuYW1lKSkge1xuICAgICAgICByZXR1cm4gbmFtZSA9PT0gQ09MT1IgPyAnbGluZWFyJyA6ICdvcmRpbmFsJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGluZy5zY2FsZShuYW1lKS50eXBlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2FsZV9kb21haW4obmFtZSwgZW5jb2RpbmcsIHNvcnRpbmcsIG9wdCkge1xuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIHJhbmdlID0gdGltZS5zY2FsZS5kb21haW4oZW5jb2RpbmcuZm4obmFtZSksIG5hbWUpO1xuICAgIGlmKHJhbmdlKSByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuYmluKG5hbWUpKSB7XG4gICAgLy8gVE9ETzogYWRkIGluY2x1ZGVFbXB0eUNvbmZpZyBoZXJlXG4gICAgaWYgKG9wdC5zdGF0cykge1xuICAgICAgdmFyIGJpbnMgPSB1dGlsLmdldGJpbnMob3B0LnN0YXRzW2VuY29kaW5nLmZpZWxkTmFtZShuYW1lKV0sIGVuY29kaW5nLmJpbihuYW1lKS5tYXhiaW5zKTtcbiAgICAgIHZhciBkb21haW4gPSB1dGlsLnJhbmdlKGJpbnMuc3RhcnQsIGJpbnMuc3RvcCwgYmlucy5zdGVwKTtcbiAgICAgIHJldHVybiBuYW1lID09PSBZID8gZG9tYWluLnJldmVyc2UoKSA6IGRvbWFpbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSA9PSBvcHQuc3RhY2sgP1xuICAgIHtcbiAgICAgIGRhdGE6IFNUQUNLRUQsXG4gICAgICBmaWVsZDogJ2RhdGEuJyArIChvcHQuZmFjZXQgPyAnbWF4XycgOiAnJykgKyAnc3VtXycgKyBlbmNvZGluZy5maWVsZChuYW1lLCB0cnVlKVxuICAgIH0gOlxuICAgIHtkYXRhOiBzb3J0aW5nLmdldERhdGFzZXQobmFtZSksIGZpZWxkOiBlbmNvZGluZy5maWVsZChuYW1lKX07XG59XG5cbmZ1bmN0aW9uIHNjYWxlX3JhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBvcHQpIHtcbiAgdmFyIHNwZWMgPSBlbmNvZGluZy5zY2FsZShzLm5hbWUpO1xuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxXaWR0aCA/IFswLCBsYXlvdXQuY2VsbFdpZHRoXSA6ICd3aWR0aCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcuZm4ocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gZW5jb2RpbmcuZm4ocy5uYW1lKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxIZWlnaHQgPyBbbGF5b3V0LmNlbGxIZWlnaHQsIDBdIDogJ2hlaWdodCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcuZm4ocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuXG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IGVuY29kaW5nLmZuKHMubmFtZSkgfHwgZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVOaWNlJyk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJPVzogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxIZWlnaHQ7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTDogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxXaWR0aDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0laRTpcbiAgICAgIGlmIChlbmNvZGluZy5pcygnYmFyJykpIHtcbiAgICAgICAgLy8gRklYTUUgdGhpcyBpcyBkZWZpbml0ZWx5IGluY29ycmVjdFxuICAgICAgICAvLyBidXQgbGV0J3MgZml4IGl0IGxhdGVyIHNpbmNlIGJhciBzaXplIGlzIGEgYmFkIGVuY29kaW5nIGFueXdheVxuICAgICAgICBzLnJhbmdlID0gWzMsIE1hdGgubWF4KGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSldO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5pcyhURVhUKSkge1xuICAgICAgICBzLnJhbmdlID0gWzgsIDQwXTtcbiAgICAgIH0gZWxzZSB7IC8vcG9pbnRcbiAgICAgICAgdmFyIGJhbmRTaXplID0gTWF0aC5taW4oZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKSAtIDE7XG4gICAgICAgIHMucmFuZ2UgPSBbMTAsIDAuOCAqIGJhbmRTaXplKmJhbmRTaXplXTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcy5yYW5nZSA9ICdzaGFwZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIHZhciByYW5nZSA9IGVuY29kaW5nLnNjYWxlKENPTE9SKS5yYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgcmFuZ2UgPSBzdHlsZS5jb2xvclJhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlID0gWycjQTlEQjlGJywgJyMwRDVDMjEnXTtcbiAgICAgICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBTFBIQTpcbiAgICAgIHMucmFuZ2UgPSBbMC4yLCAxLjBdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBuYW1lOiAnKyBzLm5hbWUpO1xuICB9XG5cbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFJPVzpcbiAgICBjYXNlIENPTDpcbiAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcbiAgICAgIHMub3V0ZXJQYWRkaW5nID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHsgLy8mJiAhcy5iYW5kV2lkdGhcbiAgICAgICAgcy5wb2ludHMgPSB0cnVlO1xuICAgICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5iYW5kKHMubmFtZSkucGFkZGluZztcbiAgICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTb3J0VHJhbnNmb3JtcztcblxuLy8gYWRkcyBuZXcgdHJhbnNmb3JtcyB0aGF0IHByb2R1Y2Ugc29ydGVkIGZpZWxkc1xuZnVuY3Rpb24gYWRkU29ydFRyYW5zZm9ybXMoc3BlYywgZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIGRhdGFzZXRNYXBwaW5nID0ge307XG4gIHZhciBjb3VudGVyID0gMDtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIHNvcnRCeSA9IGVuY29kaW5nLnNvcnQoZW5jVHlwZSwgc3RhdHMpO1xuICAgIGlmIChzb3J0QnkubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGZpZWxkcyA9IHNvcnRCeS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wOiBkLmFnZ3IsXG4gICAgICAgICAgZmllbGQ6ICdkYXRhLicgKyBkLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYnlDbGF1c2UgPSBzb3J0QnkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIHJldmVyc2UgPSAoZC5yZXZlcnNlID8gJy0nIDogJycpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSArICdkYXRhLicgKyAoZC5hZ2dyPT09J2NvdW50JyA/ICdjb3VudCcgOiAoZC5hZ2dyICsgJ18nICsgZC5uYW1lKSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGRhdGFOYW1lID0gJ3NvcnRlZCcgKyBjb3VudGVyKys7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICAgICAgZ3JvdXBieTogWydkYXRhLicgKyBmaWVsZC5uYW1lXSxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3NvcnQnLFxuICAgICAgICAgIGJ5OiBieUNsYXVzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBzcGVjLmRhdGEucHVzaCh7XG4gICAgICAgIG5hbWU6IGRhdGFOYW1lLFxuICAgICAgICBzb3VyY2U6IFJBVyxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zXG4gICAgICB9KTtcblxuICAgICAgZGF0YXNldE1hcHBpbmdbZW5jVHlwZV0gPSBkYXRhTmFtZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgc3BlYzogc3BlYyxcbiAgICBnZXREYXRhc2V0OiBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFzZXRNYXBwaW5nW2VuY1R5cGVdO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBUQUJMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tpbmc7XG5cbmZ1bmN0aW9uIHN0YWNraW5nKHNwZWMsIGVuY29kaW5nLCBtZGVmLCBmYWNldHMpIHtcbiAgaWYgKCFtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5zdGFjaykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCB8fCBlbmNvZGluZy5oYXMoTE9EKSBoZXJlIG9uY2UgTE9EIGlzIGltcGxlbWVudGVkXG4gIGlmICghZW5jb2RpbmcuaGFzKENPTE9SKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkaW09bnVsbCwgdmFsPW51bGwsIGlkeCA9bnVsbCxcbiAgICBpc1hNZWFzdXJlID0gZW5jb2RpbmcuaXNNZWFzdXJlKFgpLFxuICAgIGlzWU1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWSk7XG5cbiAgaWYgKGlzWE1lYXN1cmUgJiYgIWlzWU1lYXN1cmUpIHtcbiAgICBkaW0gPSBZO1xuICAgIHZhbCA9IFg7XG4gICAgaWR4ID0gMDtcbiAgfSBlbHNlIGlmIChpc1lNZWFzdXJlICYmICFpc1hNZWFzdXJlKSB7XG4gICAgZGltID0gWDtcbiAgICB2YWwgPSBZO1xuICAgIGlkeCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIHN0YWNrIGVuY29kaW5nXG4gIH1cblxuICAvLyBhZGQgdHJhbnNmb3JtIHRvIGNvbXB1dGUgc3VtcyBmb3Igc2NhbGVcbiAgdmFyIHN0YWNrZWQgPSB7XG4gICAgbmFtZTogU1RBQ0tFRCxcbiAgICBzb3VyY2U6IFRBQkxFLFxuICAgIHRyYW5zZm9ybTogW3tcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkKGRpbSldLmNvbmNhdChmYWNldHMpLCAvLyBkaW0gYW5kIG90aGVyIGZhY2V0c1xuICAgICAgZmllbGRzOiBbe29wOiAnc3VtJywgZmllbGQ6IGVuY29kaW5nLmZpZWxkKHZhbCl9XSAvLyBUT0RPIGNoZWNrIGlmIGZpZWxkIHdpdGggYWdnciBpcyBjb3JyZWN0P1xuICAgIH1dXG4gIH07XG5cbiAgaWYgKGZhY2V0cyAmJiBmYWNldHMubGVuZ3RoID4gMCkge1xuICAgIHN0YWNrZWQudHJhbnNmb3JtLnB1c2goeyAvL2NhbGN1bGF0ZSBtYXggZm9yIGVhY2ggZmFjZXRcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogZmFjZXRzLFxuICAgICAgZmllbGRzOiBbe29wOiAnbWF4JywgZmllbGQ6ICdkYXRhLnN1bV8nICsgZW5jb2RpbmcuZmllbGQodmFsLCB0cnVlKX1dXG4gICAgfSk7XG4gIH1cblxuICBzcGVjLmRhdGEucHVzaChzdGFja2VkKTtcblxuICAvLyBhZGQgc3RhY2sgdHJhbnNmb3JtIHRvIG1hcmtcbiAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7XG4gICAgdHlwZTogJ3N0YWNrJyxcbiAgICBwb2ludDogZW5jb2RpbmcuZmllbGQoZGltKSxcbiAgICBoZWlnaHQ6IGVuY29kaW5nLmZpZWxkKHZhbCksXG4gICAgb3V0cHV0OiB7eTE6IHZhbCwgeTA6IHZhbCArICcyJ31cbiAgfV07XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdXBlciBoYWNrLWlzaCAtLSBjb25zb2xpZGF0ZSBpbnRvIG1vZHVsYXIgbWFyayBwcm9wZXJ0aWVzP1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbF0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWwgKyAnMiddID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbCArICcyJ10gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbCArICcyJ307XG5cbiAgcmV0dXJuIHZhbDsgLy9yZXR1cm4gc3RhY2sgZW5jb2Rpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuLi9maWVsZCcpLFxuICBFbmNvZGluZyA9IHJlcXVpcmUoJy4uL0VuY29kaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHJldHVybiB7XG4gICAgb3BhY2l0eTogZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLCBzdGF0cyksXG4gICAgY29sb3JSYW5nZTogY29sb3JSYW5nZShlbmNvZGluZywgc3RhdHMpXG4gIH07XG59O1xuXG5mdW5jdGlvbiBjb2xvclJhbmdlKGVuY29kaW5nLCBzdGF0cyl7XG4gIGlmIChlbmNvZGluZy5oYXMoQ09MT1IpICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKENPTE9SKSkge1xuICAgIHZhciBjYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTE9SLCBzdGF0cyk7XG4gICAgaWYgKGNhcmRpbmFsaXR5IDw9IDEwKSB7XG4gICAgICByZXR1cm4gXCJjYXRlZ29yeTEwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImNhdGVnb3J5MjBcIjtcbiAgICB9XG4gICAgLy8gVE9ETyBjYW4gdmVnYSBpbnRlcnBvbGF0ZSByYW5nZSBmb3Igb3JkaW5hbCBzY2FsZT9cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLHN0YXRzKSB7XG4gIGlmICghc3RhdHMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBudW1Qb2ludHMgPSAwO1xuXG4gIGlmIChlbmNvZGluZy5pc0FnZ3JlZ2F0ZSgpKSB7IC8vIGFnZ3JlZ2F0ZSBwbG90XG4gICAgbnVtUG9pbnRzID0gMTtcblxuICAgIC8vICBnZXQgbnVtYmVyIG9mIHBvaW50cyBpbiBlYWNoIFwiY2VsbFwiXG4gICAgLy8gIGJ5IGNhbGN1bGF0aW5nIHByb2R1Y3Qgb2YgY2FyZGluYWxpdHlcbiAgICAvLyAgZm9yIGVhY2ggbm9uIGZhY2V0aW5nIGFuZCBub24tb3JkaW5hbCBYIC8gWSBmaWVsZHNcbiAgICAvLyAgbm90ZSB0aGF0IG9yZGluYWwgeCx5IGFyZSBub3QgaW5jbHVkZSBzaW5jZSB3ZSBjYW5cbiAgICAvLyAgY29uc2lkZXIgdGhhdCBvcmRpbmFsIHggYXJlIHN1YmRpdmlkaW5nIHRoZSBjZWxsIGludG8gc3ViY2VsbHMgYW55d2F5XG4gICAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuXG4gICAgICBpZiAoZW5jVHlwZSAhPT0gUk9XICYmIGVuY1R5cGUgIT09IENPTCAmJlxuICAgICAgICAgICEoKGVuY1R5cGUgPT09IFggfHwgZW5jVHlwZSA9PT0gWSkgJiZcbiAgICAgICAgICB2bGZpZWxkLmlzT3JkaW5hbFNjYWxlKGZpZWxkLCB0cnVlKSlcbiAgICAgICAgKSB7XG4gICAgICAgIG51bVBvaW50cyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShlbmNUeXBlLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSBlbHNlIHsgLy8gcmF3IHBsb3RcbiAgICBudW1Qb2ludHMgPSBzdGF0cy5jb3VudDtcblxuICAgIC8vIHNtYWxsIG11bHRpcGxlcyBkaXZpZGUgbnVtYmVyIG9mIHBvaW50c1xuICAgIHZhciBudW1NdWx0aXBsZXMgPSAxO1xuICAgIGlmIChlbmNvZGluZy5oYXMoUk9XKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcuaGFzKENPTCkpIHtcbiAgICAgIG51bU11bHRpcGxlcyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB9XG4gICAgbnVtUG9pbnRzIC89IG51bU11bHRpcGxlcztcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gMDtcbiAgaWYgKG51bVBvaW50cyA8IDIwKSB7XG4gICAgb3BhY2l0eSA9IDE7XG4gIH0gZWxzZSBpZiAobnVtUG9pbnRzIDwgMjAwKSB7XG4gICAgb3BhY2l0eSA9IDAuNztcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAxMDAwIHx8IGVuY29kaW5nLmlzKCd0aWNrJykpIHtcbiAgICBvcGFjaXR5ID0gMC42O1xuICB9IGVsc2Uge1xuICAgIG9wYWNpdHkgPSAwLjM7XG4gIH1cblxuICByZXR1cm4gb3BhY2l0eTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgZ3JvdXBkZWYgPSByZXF1aXJlKCcuL2dyb3VwJykuZGVmO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YmZhY2V0aW5nO1xuXG5mdW5jdGlvbiBzdWJmYWNldGluZyhncm91cCwgbWRlZiwgZGV0YWlscywgc3RhY2ssIGVuY29kaW5nKSB7XG4gIHZhciBtID0gZ3JvdXAubWFya3MsXG4gICAgZyA9IGdyb3VwZGVmKCdzdWJmYWNldCcsIHttYXJrczogbX0pO1xuXG4gIGdyb3VwLm1hcmtzID0gW2ddO1xuICBnLmZyb20gPSBtZGVmLmZyb207XG4gIGRlbGV0ZSBtZGVmLmZyb207XG5cbiAgLy9UT0RPIHRlc3QgTE9EIC0tIHdlIHNob3VsZCBzdXBwb3J0IHN0YWNrIC8gbGluZSB3aXRob3V0IGNvbG9yIChMT0QpIGZpZWxkXG4gIHZhciB0cmFucyA9IChnLmZyb20udHJhbnNmb3JtIHx8IChnLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZGV0YWlsc30pO1xuXG4gIGlmIChzdGFjayAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ3NvcnQnLCBieTogZW5jb2RpbmcuZmllbGQoQ09MT1IpfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWYsXG4gIHZsZGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuZnVuY3Rpb24gdGVtcGxhdGUoZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIHsgLy9oYWNrIHVzZSBzdGF0c1xuXG4gIHZhciBkYXRhID0ge25hbWU6IFJBVywgZm9ybWF0OiB7dHlwZTogZW5jb2RpbmcuY29uZmlnKCdkYXRhRm9ybWF0VHlwZScpfX0sXG4gICAgdGFibGUgPSB7bmFtZTogVEFCTEUsIHNvdXJjZTogUkFXfSxcbiAgICBkYXRhVXJsID0gdmxkYXRhLmdldFVybChlbmNvZGluZywgc3RhdHMpO1xuICBpZiAoZGF0YVVybCkgZGF0YS51cmwgPSBkYXRhVXJsO1xuXG4gIHZhciBwcmVhZ2dyZWdhdGVkRGF0YSA9IGVuY29kaW5nLmNvbmZpZygndXNlVmVnYVNlcnZlcicpO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgbmFtZTtcbiAgICBpZiAoZmllbGQudHlwZSA9PSBUKSB7XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZSA9IGRhdGEuZm9ybWF0LnBhcnNlIHx8IHt9O1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2VbZmllbGQubmFtZV0gPSAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09IFEpIHtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlID0gZGF0YS5mb3JtYXQucGFyc2UgfHwge307XG4gICAgICBpZiAoZmllbGQuYWdnciA9PT0gJ2NvdW50Jykge1xuICAgICAgICBuYW1lID0gJ2NvdW50JztcbiAgICAgIH0gZWxzZSBpZiAocHJlYWdncmVnYXRlZERhdGEgJiYgZmllbGQuYmluKSB7XG4gICAgICAgIG5hbWUgPSAnYmluXycgKyBmaWVsZC5uYW1lO1xuICAgICAgfSBlbHNlIGlmIChwcmVhZ2dyZWdhdGVkRGF0YSAmJiBmaWVsZC5hZ2dyKSB7XG4gICAgICAgIG5hbWUgPSBmaWVsZC5hZ2dyICsgJ18nICsgZmllbGQubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgfVxuICAgICAgZGF0YS5mb3JtYXQucGFyc2VbbmFtZV0gPSAnbnVtYmVyJztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGxheW91dC53aWR0aCxcbiAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHQsXG4gICAgcGFkZGluZzogJ2F1dG8nLFxuICAgIGRhdGE6IFtkYXRhLCB0YWJsZV0sXG4gICAgbWFya3M6IFtncm91cGRlZignY2VsbCcsIHtcbiAgICAgIHdpZHRoOiBsYXlvdXQuY2VsbFdpZHRoID8ge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSA6IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogbGF5b3V0LmNlbGxIZWlnaHQgPyB7dmFsdWU6IGxheW91dC5jZWxsSGVpZ2h0fSA6IHVuZGVmaW5lZFxuICAgIH0pXVxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0aW1lO1xuXG5mdW5jdGlvbiB0aW1lKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgdmFyIHRpbWVGaWVsZHMgPSB7fSwgdGltZUZuID0ge307XG5cbiAgLy8gZmluZCB1bmlxdWUgZm9ybXVsYSB0cmFuc2Zvcm1hdGlvbiBhbmQgYmluIGZ1bmN0aW9uXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC5mbikge1xuICAgICAgdGltZUZpZWxkc1tlbmNvZGluZy5maWVsZChlbmNUeXBlKV0gPSB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgZW5jVHlwZTogZW5jVHlwZVxuICAgICAgfTtcbiAgICAgIHRpbWVGbltmaWVsZC5mbl0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWRkIGZvcm11bGEgdHJhbnNmb3JtXG4gIHZhciBkYXRhID0gc3BlYy5kYXRhWzFdLFxuICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gfHwgW107XG5cbiAgZm9yICh2YXIgZiBpbiB0aW1lRmllbGRzKSB7XG4gICAgdmFyIHRmID0gdGltZUZpZWxkc1tmXTtcbiAgICB0aW1lLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIGVuY29kaW5nLCB0Zi5lbmNUeXBlLCB0Zi5maWVsZCk7XG4gIH1cblxuICAvLyBhZGQgc2NhbGVzXG4gIHZhciBzY2FsZXMgPSBzcGVjLnNjYWxlcyA9IHNwZWMuc2NhbGVzIHx8IFtdO1xuICBmb3IgKHZhciBmbiBpbiB0aW1lRm4pIHtcbiAgICB0aW1lLnNjYWxlKHNjYWxlcywgZm4sIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxudGltZS5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSkge1xuICB2YXIgZm4gPSBmaWVsZC5mbjtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiAyNDtcbiAgICBjYXNlICdkYXknOiByZXR1cm4gNztcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIDMxO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIDEyO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXSxcbiAgICAgICAgeWVhcnN0YXQgPSBzdGF0c1sneWVhcl8nK2ZpZWxkLm5hbWVdO1xuXG4gICAgICBpZiAoIXllYXJzdGF0KSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB5ZWFyc3RhdC5jYXJkaW5hbGl0eSAtXG4gICAgICAgIChzdGF0Lm51bU51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBmaWVsZEZuKGZ1bmMsIGZpZWxkKSB7XG4gIHJldHVybiAndXRjJyArIGZ1bmMgKyAnKGQuZGF0YS4nKyBmaWVsZC5uYW1lICsnKSc7XG59XG5cbi8qKlxuICogQHJldHVybiB7U3RyaW5nfSBkYXRlIGJpbm5pbmcgZm9ybXVsYSBvZiB0aGUgZ2l2ZW4gZmllbGRcbiAqL1xudGltZS5mb3JtdWxhID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkRm4oZmllbGQuZm4sIGZpZWxkKTtcbn07XG5cbi8qKiBhZGQgZm9ybXVsYSB0cmFuc2Zvcm1zIHRvIGRhdGEgKi9cbnRpbWUudHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtLCBlbmNvZGluZywgZW5jVHlwZSwgZmllbGQpIHtcbiAgdHJhbnNmb3JtLnB1c2goe1xuICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICBmaWVsZDogZW5jb2RpbmcuZmllbGQoZW5jVHlwZSksXG4gICAgZXhwcjogdGltZS5mb3JtdWxhKGZpZWxkKVxuICB9KTtcbn07XG5cbi8qKiBhcHBlbmQgY3VzdG9tIHRpbWUgc2NhbGVzIGZvciBheGlzIGxhYmVsICovXG50aW1lLnNjYWxlID0gZnVuY3Rpb24oc2NhbGVzLCBmbiwgZW5jb2RpbmcpIHtcbiAgdmFyIGxhYmVsTGVuZ3RoID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVMYWJlbExlbmd0aCcpO1xuICAvLyBUT0RPIGFkZCBvcHRpb24gZm9yIHNob3J0ZXIgc2NhbGUgLyBjdXN0b20gcmFuZ2VcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ2RheSc6XG4gICAgICBzY2FsZXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICd0aW1lLScrZm4sXG4gICAgICAgIHR5cGU6ICdvcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiB1dGlsLnJhbmdlKDAsIDcpLFxuICAgICAgICByYW5nZTogWydNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5JywgJ1N1bmRheSddLm1hcChcbiAgICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHNjYWxlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3RpbWUtJytmbixcbiAgICAgICAgdHlwZTogJ29yZGluYWwnLFxuICAgICAgICBkb21haW46IHV0aWwucmFuZ2UoMCwgMTIpLFxuICAgICAgICByYW5nZTogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10ubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG50aW1lLmlzT3JkaW5hbEZuID0gZnVuY3Rpb24oZm4pIHtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnRpbWUuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKGZuLCBuYW1lKSB7XG4gIGlmIChuYW1lID09PSBDT0xPUikge1xuICAgIHJldHVybiAnbGluZWFyJzsgLy8gdGhpcyBoYXMgb3JkZXJcbiAgfVxuXG4gIHJldHVybiB0aW1lLmlzT3JkaW5hbEZuKGZuKSB8fCBuYW1lID09PSBDT0wgfHwgbmFtZSA9PT0gUk9XID8gJ29yZGluYWwnIDogJ2xpbmVhcic7XG59O1xuXG50aW1lLnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGZuLCBuYW1lKSB7XG4gIHZhciBpc0NvbG9yID0gbmFtZSA9PT0gQ09MT1I7XG4gIHN3aXRjaCAoZm4pIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCw1OV0gOiB1dGlsLnJhbmdlKDAsIDYwKTtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiBpc0NvbG9yID8gWzAsMjNdIDogdXRpbC5yYW5nZSgwLCAyNCk7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIGlzQ29sb3IgPyBbMCw2XSA6IHV0aWwucmFuZ2UoMCwgNyk7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiBpc0NvbG9yID8gWzEsMzFdIDogdXRpbC5yYW5nZSgxLCAzMik7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gaXNDb2xvciA/IFswLDExXSA6IHV0aWwucmFuZ2UoMCwgMTIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIHRpbWUgZnVuY3Rpb24gaGFzIGN1c3RvbSBzY2FsZSBmb3IgbGFiZWxzIGltcGxlbWVudGVkIGluIHRpbWUuc2NhbGUgKi9cbnRpbWUuaGFzU2NhbGUgPSBmdW5jdGlvbihmbikge1xuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmNvbnN0cy5lbmNvZGluZ1R5cGVzID0gW1gsIFksIFJPVywgQ09MLCBTSVpFLCBTSEFQRSwgQ09MT1IsIEFMUEhBLCBURVhULCBERVRBSUxdO1xuXG5jb25zdHMuZGF0YVR5cGVzID0geydPJzogTywgJ1EnOiBRLCAnVCc6IFR9O1xuXG5jb25zdHMuZGF0YVR5cGVOYW1lcyA9IFsnTycsICdRJywgJ1QnXS5yZWR1Y2UoZnVuY3Rpb24ociwgeCkge1xuICByW2NvbnN0cy5kYXRhVHlwZXNbeF1dID0geDtcbiAgcmV0dXJuIHI7XG59LHt9KTtcblxuY29uc3RzLnNob3J0aGFuZCA9IHtcbiAgZGVsaW06ICAnfCcsXG4gIGFzc2lnbjogJz0nLFxuICB0eXBlOiAgICcsJyxcbiAgZnVuYzogICAnXydcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86IHJlbmFtZSBnZXREYXRhVXJsIHRvIHZsLmRhdGEuZ2V0VXJsKCkgP1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgdmxkYXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7fSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKTtcblxudmxkYXRhLmdldFVybCA9IGZ1bmN0aW9uIGdldERhdGFVcmwoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIGlmICghZW5jb2RpbmcuY29uZmlnKCd1c2VWZWdhU2VydmVyJykpIHtcbiAgICAvLyBkb24ndCB1c2UgdmVnYSBzZXJ2ZXJcbiAgICByZXR1cm4gZW5jb2RpbmcuY29uZmlnKCdkYXRhVXJsJyk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcubGVuZ3RoKCkgPT09IDApIHtcbiAgICAvLyBubyBmaWVsZHNcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmllbGRzID0gW107XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgbmFtZTogZW5jb2RpbmcuZmllbGQoZW5jVHlwZSwgdHJ1ZSksXG4gICAgICBmaWVsZDogZmllbGQubmFtZVxuICAgIH07XG4gICAgaWYgKGZpZWxkLmFnZ3IpIHtcbiAgICAgIG9iai5hZ2dyID0gZmllbGQuYWdncjtcbiAgICB9XG4gICAgaWYgKGZpZWxkLmJpbikge1xuICAgICAgb2JqLmJpblNpemUgPSB1dGlsLmdldGJpbnMoc3RhdHNbZmllbGQubmFtZV0sIGVuY29kaW5nLmJpbihlbmNUeXBlKS5tYXhiaW5zKS5zdGVwO1xuICAgIH1cbiAgICBmaWVsZHMucHVzaChvYmopO1xuICB9KTtcblxuICB2YXIgcXVlcnkgPSB7XG4gICAgdGFibGU6IGVuY29kaW5nLmNvbmZpZygndmVnYVNlcnZlclRhYmxlJyksXG4gICAgZmllbGRzOiBmaWVsZHNcbiAgfTtcblxuICByZXR1cm4gZW5jb2RpbmcuY29uZmlnKCd2ZWdhU2VydmVyVXJsJykgKyAnL3F1ZXJ5Lz9xPScgKyBKU09OLnN0cmluZ2lmeShxdWVyeSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBkYXRhIGluIEpTT04vamF2YXNjcmlwdCBvYmplY3QgZm9ybWF0XG4gKiBAcmV0dXJuIEFycmF5IG9mIHtuYW1lOiBfX25hbWVfXywgdHlwZTogXCJudW1iZXJ8dGV4dHx0aW1lfGxvY2F0aW9uXCJ9XG4gKi9cbnZsZGF0YS5nZXRTY2hlbWEgPSBmdW5jdGlvbihkYXRhLCBvcmRlcikge1xuICB2YXIgc2NoZW1hID0gW10sXG4gICAgZmllbGRzID0gdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAvLyBmaW5kIG5vbi1udWxsIGRhdGFcbiAgICB2YXIgaSA9IDAsIGRhdHVtID0gZGF0YVtpXVtrXTtcbiAgICB3aGlsZSAoZGF0dW0gPT09ICcnIHx8IGRhdHVtID09PSBudWxsIHx8IGRhdHVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRhdHVtID0gZGF0YVsrK2ldW2tdO1xuICAgIH1cblxuICAgIGRhdHVtID0gdXRpbC5wYXJzZShkYXR1bSk7XG4gICAgdmFyIHR5cGUgPSAodHlwZW9mIGRhdHVtID09PSAnbnVtYmVyJykgPyAnUSc6XG4gICAgICAoZGF0dW0gaW5zdGFuY2VvZiBEYXRlKSA/ICdUJyA6ICdPJztcblxuICAgIHNjaGVtYS5wdXNoKHtuYW1lOiBrLCB0eXBlOiB0eXBlfSk7XG4gIH0pO1xuXG4gIHNjaGVtYSA9IHV0aWwuc3RhYmxlc29ydChzY2hlbWEsIG9yZGVyIHx8IHZsZmllbGQub3JkZXIudHlwZVRoZW5OYW1lLCB2bGZpZWxkLm9yZGVyLm5hbWUpO1xuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG52bGRhdGEuZ2V0U3RhdHMgPSBmdW5jdGlvbihkYXRhKSB7IC8vIGhhY2tcbiAgdmFyIHN0YXRzID0ge30sXG4gICAgZmllbGRzID0gdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgY29sdW1uID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBkW2tdO30pO1xuXG4gICAgLy8gSGFja1xuICAgIHZhciB2YWwgPSB1dGlsLnBhcnNlKGRhdGFbMF1ba10pO1xuICAgIHZhciB0eXBlID0gKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSA/ICdRJzpcbiAgICAgICh2YWwgaW5zdGFuY2VvZiBEYXRlKSA/ICdUJyA6ICdPJztcblxuICAgIHZhciBzdGF0ID0ge307XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGF0ID0gdXRpbC5taW5tYXgodXRpbC5udW1iZXJzKGNvbHVtbikpO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgc3RhdCA9IHV0aWwubWlubWF4KHV0aWwuZGF0ZXMoY29sdW1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXQgPSB1dGlsLm1pbm1heChjb2x1bW4pO1xuICAgIH1cblxuICAgIHN0YXQuY2FyZGluYWxpdHkgPSB1dGlsLnVuaXEoZGF0YSwgayk7XG4gICAgc3RhdC5jb3VudCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgc3RhdC5tYXhsZW5ndGggPSBkYXRhLnJlZHVjZShmdW5jdGlvbihtYXgscm93KSB7XG4gICAgICBpZiAocm93W2tdID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gcm93W2tdLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbiA+IG1heCA/IGxlbiA6IG1heDtcbiAgICB9LCAwKTtcblxuICAgIHN0YXQubnVtTnVsbHMgPSBkYXRhLnJlZHVjZShmdW5jdGlvbihjb3VudCwgcm93KSB7XG4gICAgICByZXR1cm4gcm93W2tdID09PSBudWxsID8gY291bnQgKyAxIDogY291bnQ7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgbnVtYmVycyA9IHV0aWwubnVtYmVycyhjb2x1bW4pO1xuXG4gICAgaWYgKG51bWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdC5za2V3ID0gdXRpbC5za2V3KG51bWJlcnMpO1xuICAgICAgc3RhdC5zdGRldiA9IHV0aWwuc3RkZXYobnVtYmVycyk7XG4gICAgICBzdGF0Lm1lYW4gPSB1dGlsLm1lYW4obnVtYmVycyk7XG4gICAgICBzdGF0Lm1lZGlhbiA9IHV0aWwubWVkaWFuKG51bWJlcnMpO1xuICAgIH1cblxuICAgIHZhciBzYW1wbGUgPSB7fTtcbiAgICB3aGlsZShPYmplY3Qua2V5cyhzYW1wbGUpLmxlbmd0aCA8IE1hdGgubWluKHN0YXQuY2FyZGluYWxpdHksIDEwKSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBkYXRhLmxlbmd0aCldW2tdO1xuICAgICAgc2FtcGxlW3ZhbHVlXSA9IHRydWU7XG4gICAgfVxuICAgIHN0YXQuc2FtcGxlID0gT2JqZWN0LmtleXMoc2FtcGxlKTtcblxuICAgIHN0YXRzW2tdID0gc3RhdDtcbiAgfSk7XG4gIHN0YXRzLmNvdW50ID0gZGF0YS5sZW5ndGg7XG4gIHJldHVybiBzdGF0cztcbn07XG4iLCIvLyB1dGlsaXR5IGZvciBlbmNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpLFxuICBlbmNUeXBlcyA9IHNjaGVtYS5lbmNUeXBlcztcblxudmFyIHZsZW5jID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmxlbmMuY291bnRSZXRpbmFsID0gZnVuY3Rpb24oZW5jKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmIChlbmMuY29sb3IpIGNvdW50Kys7XG4gIGlmIChlbmMuYWxwaGEpIGNvdW50Kys7XG4gIGlmIChlbmMuc2l6ZSkgY291bnQrKztcbiAgaWYgKGVuYy5zaGFwZSkgY291bnQrKztcbiAgcmV0dXJuIGNvdW50O1xufTtcblxudmxlbmMuaGFzID0gZnVuY3Rpb24oZW5jLCBlbmNUeXBlKSB7XG4gIHZhciBmaWVsZERlZiA9IGVuYyAmJiBlbmNbZW5jVHlwZV07XG4gIHJldHVybiBmaWVsZERlZiAmJiBmaWVsZERlZi5uYW1lO1xufTtcblxudmxlbmMuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmMpIHtcbiAgZm9yICh2YXIgayBpbiBlbmMpIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykgJiYgZW5jW2tdLmFnZ3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52bGVuYy5mb3JFYWNoID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBpID0gMDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBmKGVuY1trXSwgaywgaSsrKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmxlbmMubWFwID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBhcnIucHVzaChmKGVuY1trXSwgaywgZW5jKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbnZsZW5jLnJlZHVjZSA9IGZ1bmN0aW9uKGVuYywgZiwgaW5pdCkge1xuICB2YXIgciA9IGluaXQsIGkgPSAwLCBrO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIHIgPSBmKHIsIGVuY1trXSwgaywgIGVuYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vKlxuICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAqL1xudmxlbmMuZmllbGRzID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5yZWR1Y2UoZW5jLCBmdW5jdGlvbiAobSwgZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgZmllbGRMaXN0ID0gbVtmaWVsZC5uYW1lXSA9IG1bZmllbGQubmFtZV0gfHwgW10sXG4gICAgICBjb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSB8fCB7fTtcblxuICAgIGlmIChmaWVsZExpc3QuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICBmaWVsZExpc3QucHVzaChmaWVsZCk7XG4gICAgICAvLyBhdWdtZW50IHRoZSBhcnJheSB3aXRoIGNvbnRhaW5zVHlwZS5RIC8gTyAvIFRcbiAgICAgIGNvbnRhaW5zVHlwZVtmaWVsZC50eXBlXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LCB7fSk7XG59O1xuXG52bGVuYy5zaG9ydGhhbmQgPSBmdW5jdGlvbihlbmMpIHtcbiAgcmV0dXJuIHZsZW5jLm1hcChlbmMsIGZ1bmN0aW9uKGZpZWxkLCBldCkge1xuICAgIHJldHVybiBldCArIGMuYXNzaWduICsgdmxmaWVsZC5zaG9ydGhhbmQoZmllbGQpO1xuICB9KS5qb2luKGMuZGVsaW0pO1xufTtcblxudmxlbmMuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgY29udmVydFR5cGUpIHtcbiAgdmFyIGVuYyA9IHV0aWwuaXNBcnJheShzaG9ydGhhbmQpID8gc2hvcnRoYW5kIDogc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pO1xuICByZXR1cm4gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKSB7XG4gICAgdmFyIHNwbGl0ID0gZS5zcGxpdChjLmFzc2lnbiksXG4gICAgICAgIGVuY3R5cGUgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgIGZpZWxkID0gc3BsaXRbMV07XG5cbiAgICBtW2VuY3R5cGVdID0gdmxmaWVsZC5mcm9tU2hvcnRoYW5kKGZpZWxkLCBjb252ZXJ0VHlwZSk7XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1dGlsaXR5IGZvciBmaWVsZFxuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG52YXIgdmxmaWVsZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZsZmllbGQuc2hvcnRoYW5kID0gZnVuY3Rpb24oZikge1xuICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gIHJldHVybiAoZi5hZ2dyID8gZi5hZ2dyICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5mbiA/IGYuZm4gKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLmJpbiA/ICdiaW4nICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5uYW1lIHx8ICcnKSArIGMudHlwZSArXG4gICAgKGNvbnN0cy5kYXRhVHlwZU5hbWVzW2YudHlwZV0gfHwgZi50eXBlKTtcbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kcyA9IGZ1bmN0aW9uKGZpZWxkcywgZGVsaW0pIHtcbiAgZGVsaW0gPSBkZWxpbSB8fCBjLmRlbGltO1xuICByZXR1cm4gZmllbGRzLm1hcCh2bGZpZWxkLnNob3J0aGFuZCkuam9pbihkZWxpbSk7XG59O1xuXG52bGZpZWxkLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGNvbnZlcnRUeXBlKSB7XG4gIHZhciBzcGxpdCA9IHNob3J0aGFuZC5zcGxpdChjLnR5cGUpLCBpO1xuICB2YXIgbyA9IHtcbiAgICBuYW1lOiBzcGxpdFswXS50cmltKCksXG4gICAgdHlwZTogY29udmVydFR5cGUgPyBjb25zdHMuZGF0YVR5cGVzW3NwbGl0WzFdLnRyaW0oKV0gOiBzcGxpdFsxXS50cmltKClcbiAgfTtcblxuICAvLyBjaGVjayBhZ2dyZWdhdGUgdHlwZVxuICBmb3IgKGkgaW4gc2NoZW1hLmFnZ3IuZW51bSkge1xuICAgIHZhciBhID0gc2NoZW1hLmFnZ3IuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyID0gYTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRpbWUgZm5cbiAgZm9yIChpIGluIHNjaGVtYS50aW1lZm5zKSB7XG4gICAgdmFyIGYgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKGYgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKG8ubGVuZ3RoICsgMSk7XG4gICAgICBvLmZuID0gZjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGJpblxuICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKCdiaW5fJykgPT09IDApIHtcbiAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgIG8uYmluID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufTtcblxudmFyIHR5cGVPcmRlciA9IHtcbiAgTzogMCxcbiAgRzogMSxcbiAgVDogMixcbiAgUTogM1xufTtcblxudmxmaWVsZC5vcmRlciA9IHt9O1xuXG52bGZpZWxkLm9yZGVyLnR5cGUgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoZmllbGQuYWdncj09PSdjb3VudCcpIHJldHVybiA0O1xuICByZXR1cm4gdHlwZU9yZGVyW2ZpZWxkLnR5cGVdO1xufTtcblxudmxmaWVsZC5vcmRlci50eXBlVGhlbk5hbWUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdmxmaWVsZC5vcmRlci50eXBlKGZpZWxkKSArICdfJyArIGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZsZmllbGQub3JkZXIub3JpZ2luYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7IC8vIG5vIHN3YXAgd2lsbCBvY2N1clxufTtcblxudmxmaWVsZC5vcmRlci5uYW1lID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLm5hbWU7XG59O1xuXG52bGZpZWxkLm9yZGVyLnR5cGVUaGVuQ2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMpe1xuICByZXR1cm4gc3RhdHNbZmllbGQubmFtZV0uY2FyZGluYWxpdHk7XG59O1xuXG4vLyBGSVhNRSByZWZhY3RvclxudmxmaWVsZC5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgcmV0dXJuIChmaWVsZERlZi50eXBlICYgdHlwZSkgPiAwO1xufTtcblxudmxmaWVsZC5pc1R5cGUuYnlDb2RlID0gdmxmaWVsZC5pc1R5cGU7XG5cbnZsZmllbGQuaXNUeXBlLmJ5TmFtZSA9IGZ1bmN0aW9uIChmaWVsZCwgdHlwZSkge1xuICByZXR1cm4gZmllbGQudHlwZSA9PT0gY29uc3RzLmRhdGFUeXBlTmFtZXNbdHlwZV07XG59O1xuXG5cbmZ1bmN0aW9uIGdldElzVHlwZSh1c2VUeXBlQ29kZSkge1xuICByZXR1cm4gdXNlVHlwZUNvZGUgPyB2bGZpZWxkLmlzVHlwZS5ieUNvZGUgOiB2bGZpZWxkLmlzVHlwZS5ieU5hbWU7XG59XG5cbnZsZmllbGQuaXNUeXBlLmdldCA9IGdldElzVHlwZTsgLy9GSVhNRVxuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQuZm4gJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC5mbikgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLmZuICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUgLypvcHRpb25hbCovKSB7XG4gIHJldHVybiBmaWVsZCAmJiBpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUpIHtcbiAgcmV0dXJuIGZpZWxkICYmICFpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5yb2xlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGlzRGltZW5zaW9uKGZpZWxkKSA/ICdkaW1lbnNpb24nIDogJ21lYXN1cmUnO1xufTtcblxudmxmaWVsZC5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge25hbWU6JyonLCBhZ2dyOiAnY291bnQnLCB0eXBlOidRJywgZGlzcGxheU5hbWU6IHZsZmllbGQuY291bnQuZGlzcGxheU5hbWV9O1xufTtcblxudmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZSA9ICdOdW1iZXIgb2YgUmVjb3Jkcyc7XG5cbnZsZmllbGQuaXNDb3VudCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hZ2dyID09PSAnY291bnQnO1xufTtcblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5jYXJkaW5hbGl0eSgpIHRvIGF2b2lkIGNvbmZ1c2lvbi4gIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdXNlVHlwZUNvZGUpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSksXG4gICAgdHlwZSA9IHVzZVR5cGVDb2RlID8gY29uc3RzLmRhdGFUeXBlTmFtZXNbZmllbGQudHlwZV0gOiBmaWVsZC50eXBlO1xuXG4gIGZpbHRlck51bGwgPSBmaWx0ZXJOdWxsIHx8IHt9O1xuXG4gIGlmIChmaWVsZC5iaW4pIHtcbiAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhzdGF0c1tmaWVsZC5uYW1lXSwgZmllbGQuYmluLm1heGJpbnMgfHwgc2NoZW1hLk1BWEJJTlNfREVGQVVMVCk7XG4gICAgcmV0dXJuIChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgfVxuICBpZiAoaXNUeXBlKGZpZWxkLCBUKSkge1xuICAgIHZhciBjYXJkaW5hbGl0eSA9IHRpbWUuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKTtcbiAgICBpZihjYXJkaW5hbGl0eSAhPT0gbnVsbCkgcmV0dXJuIGNhcmRpbmFsaXR5O1xuICAgIC8vb3RoZXJ3aXNlIHVzZSBjYWxjdWxhdGlvbiBiZWxvd1xuICB9XG4gIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyByZW1vdmUgbnVsbFxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICByZXR1cm4gc3RhdC5jYXJkaW5hbGl0eSAtXG4gICAgKHN0YXQubnVtTnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLlRBQkxFID0gJ3RhYmxlJztcbmcuUkFXID0gJ3Jhdyc7XG5nLlNUQUNLRUQgPSAnc3RhY2tlZCc7XG5nLklOREVYID0gJ2luZGV4JztcblxuZy5YID0gJ3gnO1xuZy5ZID0gJ3knO1xuZy5ST1cgPSAncm93JztcbmcuQ09MID0gJ2NvbCc7XG5nLlNJWkUgPSAnc2l6ZSc7XG5nLlNIQVBFID0gJ3NoYXBlJztcbmcuQ09MT1IgPSAnY29sb3InO1xuZy5BTFBIQSA9ICdhbHBoYSc7XG5nLlRFWFQgPSAndGV4dCc7XG5nLkRFVEFJTCA9ICdkZXRhaWwnO1xuXG5nLk8gPSAxO1xuZy5RID0gMjtcbmcuVCA9IDQ7XG4iLCIvLyBQYWNrYWdlIG9mIGRlZmluaW5nIFZlZ2FsaXRlIFNwZWNpZmljYXRpb24ncyBqc29uIHNjaGVtYVxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzY2hlbWEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5zY2hlbWEudXRpbCA9IHJlcXVpcmUoJy4vc2NoZW1hdXRpbCcpO1xuXG5zY2hlbWEubWFya3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ3BvaW50JywgJ3RpY2snLCAnYmFyJywgJ2xpbmUnLCAnYXJlYScsICdjaXJjbGUnLCAnc3F1YXJlJywgJ3RleHQnXVxufTtcblxuc2NoZW1hLmFnZ3IgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ2F2ZycsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICBzdXBwb3J0ZWRFbnVtczoge1xuICAgIFE6IFsnYXZnJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gICAgTzogW10sXG4gICAgVDogWydhdmcnLCAnbWluJywgJ21heCddLFxuICAgICcnOiBbJ2NvdW50J11cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHsnUSc6IHRydWUsICdPJzogdHJ1ZSwgJ1QnOiB0cnVlLCAnJzogdHJ1ZX1cbn07XG5zY2hlbWEuYmFuZCA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMVxuICAgIH1cbiAgfVxufTtcblxuc2NoZW1hLmdldFN1cHBvcnRlZFJvbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gIHJldHVybiBzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jLnByb3BlcnRpZXNbZW5jVHlwZV0uc3VwcG9ydGVkUm9sZTtcbn07XG5cbnNjaGVtYS50aW1lZm5zID0gWyd5ZWFyJywgJ21vbnRoJywgJ2RheScsICdkYXRlJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddO1xuXG5zY2hlbWEuZGVmYXVsdFRpbWVGbiA9ICdtb250aCc7XG5cbnNjaGVtYS5mbiA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IHNjaGVtYS50aW1lZm5zLFxuICBzdXBwb3J0ZWRUeXBlczogeydUJzogdHJ1ZX1cbn07XG5cbi8vVE9ETyhrYW5pdHcpOiBhZGQgb3RoZXIgdHlwZSBvZiBmdW5jdGlvbiBoZXJlXG5cbnNjaGVtYS5zY2FsZV90eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydsaW5lYXInLCAnbG9nJywgJ3BvdycsICdzcXJ0JywgJ3F1YW50aWxlJ10sXG4gIGRlZmF1bHQ6ICdsaW5lYXInLFxuICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZX1cbn07XG5cbnNjaGVtYS5maWVsZCA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNsb25lID0gdXRpbC5kdXBsaWNhdGU7XG52YXIgbWVyZ2UgPSBzY2hlbWEudXRpbC5tZXJnZTtcblxuc2NoZW1hLk1BWEJJTlNfREVGQVVMVCA9IDE1O1xuXG52YXIgYmluID0ge1xuICB0eXBlOiBbJ2Jvb2xlYW4nLCAnb2JqZWN0J10sXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWF4Ymluczoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogc2NoZW1hLk1BWEJJTlNfREVGQVVMVCxcbiAgICAgIG1pbmltdW06IDJcbiAgICB9XG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlfSAvLyBUT0RPOiBhZGQgJ08nIGFmdGVyIGZpbmlzaGluZyAjODFcbn07XG5cbnZhciB0eXBpY2FsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ08nLCAnUScsICdUJ11cbiAgICB9LFxuICAgIGFnZ3I6IHNjaGVtYS5hZ2dyLFxuICAgIGZuOiBzY2hlbWEuZm4sXG4gICAgYmluOiBiaW4sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiBzY2hlbWEuc2NhbGVfdHlwZSxcbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZSwgJ1QnOiB0cnVlfVxuICAgICAgICB9LFxuICAgICAgICB6ZXJvOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5jbHVkZSB6ZXJvJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlLCAnVCc6IHRydWV9XG4gICAgICAgIH0sXG4gICAgICAgIG5pY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ10sXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnVCc6IHRydWV9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgb25seU9yZGluYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfSxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydPJywnUScsICdUJ10gLy8gb3JkaW5hbC1vbmx5IGZpZWxkIHN1cHBvcnRzIFEgd2hlbiBiaW4gaXMgYXBwbGllZCBhbmQgVCB3aGVuIGZuIGlzIGFwcGxpZWQuXG4gICAgfSxcbiAgICBmbjogc2NoZW1hLmZuLFxuICAgIGJpbjogYmluLFxuICAgIGFnZ3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjb3VudCddLFxuICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnTyc6IHRydWV9XG4gICAgfVxuICB9XG59KTtcblxudmFyIGF4aXNNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIGF4aXM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIGZsYWcgaW5kaWNhdGUgaWYgZ3JpZGxpbmVzIHNob3VsZCBiZSBjcmVhdGVkIGluIGFkZGl0aW9uIHRvIHRpY2tzLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgZm9yIHRoZSBheGlzLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGVPZmZzZXQ6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSB0aXRsZSBvZmZzZXQgdmFsdWUgZm9yIHRoZSBheGlzLidcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgYXhpcyBsYWJlbHMuJ1xuICAgICAgICB9LFxuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAyNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNvcnRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogW10sXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnTyc6IHRydWV9LFxuICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ2FnZ3InXSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIGFnZ3I6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ2F2ZycsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGJhbmRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBiYW5kOiBzY2hlbWEuYmFuZFxuICB9XG59O1xuXG52YXIgbGVnZW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7J3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHRleHQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0J1xuICAgICAgICB9LFxuICAgICAgICBiYXNlbGluZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdtaWRkbGUnXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiA0LFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHdlaWdodDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2JvbGQnXSxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfSxcbiAgICAgICAgZmFtaWx5OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ0hlbHZldGljYSBOZXVlJ1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2l0YWxpYyddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaXplTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgYmFyOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMzAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29sb3JNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCAndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdzdGVlbGJsdWUnXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYXJyYXknXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgYWxwaGFNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCAndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDFcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaGFwZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnY2lyY2xlJywgJ3NxdWFyZScsICdjcm9zcycsICdkaWFtb25kJywgJ3RyaWFuZ2xlLXVwJywgJ3RyaWFuZ2xlLWRvd24nXSxcbiAgICAgIGRlZmF1bHQ6ICdjaXJjbGUnXG4gICAgfVxuICB9XG59O1xuXG52YXIgZGV0YWlsTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgbGluZTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9XG59O1xuXG52YXIgcm93TWl4aW4gPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDE1MFxuICAgIH0sXG4gICAgZ3JpZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQSBmbGFnIGluZGljYXRlIGlmIGdyaWRsaW5lcyBzaG91bGQgYmUgY3JlYXRlZCBpbiBhZGRpdGlvbiB0byB0aWNrcy4nXG4gICAgfSxcbiAgfVxufTtcblxudmFyIGNvbE1peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDE1MFxuICAgIH0sXG4gICAgYXhpczoge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAxMixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGZhY2V0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVxdWlyZWROYW1lVHlwZSA9IHtcbiAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ11cbn07XG5cbnZhciBtdWx0aVJvbGVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgcXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogJ29yZGluYWwtb25seScgLy8gdXNpbmcgYWxwaGEgLyBzaXplIHRvIGVuY29kaW5nIGNhdGVnb3J5IGxlYWQgdG8gb3JkZXIgaW50ZXJwcmV0YXRpb25cbiAgfVxufSk7XG5cbnZhciBvbmx5UXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgeCA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgYXhpc01peGluLCBiYW5kTWl4aW4sIHJlcXVpcmVkTmFtZVR5cGUsIHNvcnRNaXhpbik7XG52YXIgeSA9IGNsb25lKHgpO1xuXG52YXIgZmFjZXQgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgcmVxdWlyZWROYW1lVHlwZSwgZmFjZXRNaXhpbiwgc29ydE1peGluKTtcbnZhciByb3cgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgcm93TWl4aW4pO1xudmFyIGNvbCA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCBjb2xNaXhpbik7XG5cbnZhciBzaXplID0gbWVyZ2UoY2xvbmUocXVhbnRpdGF0aXZlRmllbGQpLCBsZWdlbmRNaXhpbiwgc2l6ZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGNvbG9yID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBsZWdlbmRNaXhpbiwgY29sb3JNaXhpbiwgc29ydE1peGluKTtcbnZhciBhbHBoYSA9IG1lcmdlKGNsb25lKHF1YW50aXRhdGl2ZUZpZWxkKSwgYWxwaGFNaXhpbiwgc29ydE1peGluKTtcbnZhciBzaGFwZSA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBsZWdlbmRNaXhpbiwgc2hhcGVNaXhpbiwgc29ydE1peGluKTtcbnZhciBkZXRhaWwgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgZGV0YWlsTWl4aW4sIHNvcnRNaXhpbik7XG5cbi8vIHdlIG9ubHkgcHV0IGFnZ3JlZ2F0ZWQgbWVhc3VyZSBpbiBwaXZvdCB0YWJsZVxudmFyIHRleHQgPSBtZXJnZShjbG9uZShvbmx5UXVhbnRpdGF0aXZlRmllbGQpLCB0ZXh0TWl4aW4sIHNvcnRNaXhpbik7XG5cbi8vIFRPRE8gYWRkIGxhYmVsXG5cbnZhciBmaWx0ZXIgPSB7XG4gIHR5cGU6ICdhcnJheScsXG4gIGl0ZW1zOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgb3BlcmFuZHM6IHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBbJ3N0cmluZycsICdib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBlbnVtOiBbJz4nLCAnPj0nLCAnPScsICchPScsICc8JywgJzw9JywgJ25vdE51bGwnXVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGNmZyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyB0ZW1wbGF0ZVxuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2aWV3cG9ydDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdpbnRlZ2VyJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgZ3JpZENvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnI2VlZWVlZSdcbiAgICB9LFxuXG4gICAgLy8gZmlsdGVyIG51bGxcbiAgICBmaWx0ZXJOdWxsOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgTzoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgICAgIFE6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX0sXG4gICAgICAgIFQ6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZVNvcnQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ08nXG4gICAgfSxcblxuICAgIC8vIHNpbmdsZSBwbG90XG4gICAgc2luZ2xlSGVpZ2h0OiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVXaWR0aDoge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGggKiAoY2FyZGluYWxpdHkgKyBwYWRkaW5nKVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gYmFuZCBzaXplXG4gICAgbGFyZ2VCYW5kU2l6ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjEsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzbWFsbEJhbmRTaXplOiB7XG4gICAgICAvL3NtYWxsIG11bHRpcGxlcyBvciBzaW5nbGUgcGxvdCB3aXRoIGhpZ2ggY2FyZGluYWxpdHlcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHk6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEwXG4gICAgfSxcbiAgICAvLyBzbWFsbCBtdWx0aXBsZXNcbiAgICBjZWxsUGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIGNlbGxHcmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICcjYWFhYWFhJ1xuICAgIH0sXG4gICAgY2VsbEJhY2tncm91bmRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgdGV4dENlbGxXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogOTAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIG1hcmtzXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIHNjYWxlc1xuICAgIHRpbWVTY2FsZUxhYmVsTGVuZ3RoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gb3RoZXJcbiAgICBjaGFyYWN0ZXJXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNlxuICAgIH0sXG5cbiAgICAvLyBkYXRhIHNvdXJjZVxuICAgIGRhdGFGb3JtYXRUeXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnanNvbicsICdjc3YnXSxcbiAgICAgIGRlZmF1bHQ6ICdqc29uJ1xuICAgIH0sXG4gICAgdXNlVmVnYVNlcnZlcjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRhdGFVcmw6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2ZWdhU2VydmVyVGFibGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2ZWdhU2VydmVyVXJsOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnXG4gICAgfVxuICB9XG59O1xuXG4vKiogQHR5cGUgT2JqZWN0IFNjaGVtYSBvZiBhIHZlZ2FsaXRlIHNwZWNpZmljYXRpb24gKi9cbnNjaGVtYS5zY2hlbWEgPSB7XG4gICRzY2hlbWE6ICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSMnLFxuICBkZXNjcmlwdGlvbjogJ1NjaGVtYSBmb3IgdmVnYWxpdGUgc3BlY2lmaWNhdGlvbicsXG4gIHR5cGU6ICdvYmplY3QnLFxuICByZXF1aXJlZDogWydtYXJrdHlwZScsICdlbmMnLCAnY2ZnJ10sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBtYXJrdHlwZTogc2NoZW1hLm1hcmt0eXBlLFxuICAgIGVuYzoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGNmZzogY2ZnXG4gIH1cbn07XG5cbnNjaGVtYS5lbmNUeXBlcyA9IHV0aWwua2V5cyhzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jLnByb3BlcnRpZXMpO1xuXG4vKiogSW5zdGFudGlhdGUgYSB2ZXJib3NlIHZsIHNwZWMgZnJvbSB0aGUgc2NoZW1hICovXG5zY2hlbWEuaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjaGVtYS51dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5zY2hlbWEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNjaGVtYXV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59O1xuXG5zY2hlbWF1dGlsLmV4dGVuZCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYXV0aWwubWVyZ2Uoc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEpLCBpbnN0YW5jZSk7XG59O1xuXG4vLyBpbnN0YW50aWF0ZSBhIHNjaGVtYVxuc2NoZW1hdXRpbC5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICB2YXIgdmFsO1xuICBpZiAoc2NoZW1hLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGluc3RhbmNlID0ge307XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgdmFsID0gc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEucHJvcGVydGllc1tuYW1lXSk7XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5zdGFuY2VbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIGlmICgnZGVmYXVsdCcgaW4gc2NoZW1hKSB7XG4gICAgdmFsID0gc2NoZW1hLmRlZmF1bHQ7XG4gICAgcmV0dXJuIHV0aWwuaXNPYmplY3QodmFsKSA/IHV0aWwuZHVwbGljYXRlKHZhbCkgOiB2YWw7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIHJlbW92ZSBhbGwgZGVmYXVsdHMgZnJvbSBhbiBpbnN0YW5jZVxuc2NoZW1hdXRpbC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBkZWZhdWx0cykge1xuICB2YXIgY2hhbmdlcyA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGluc3RhbmNlKSB7XG4gICAgdmFyIGRlZiA9IGRlZmF1bHRzW3Byb3BdO1xuICAgIHZhciBpbnMgPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAvLyBOb3RlOiBkb2VzIG5vdCBwcm9wZXJseSBzdWJ0cmFjdCBhcnJheXNcbiAgICBpZiAoIWRlZmF1bHRzIHx8IGRlZiAhPT0gaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIGlucyA9PT0gJ29iamVjdCcgJiYgIXV0aWwuaXNBcnJheShpbnMpICYmIGRlZikge1xuICAgICAgICB2YXIgYyA9IHNjaGVtYXV0aWwuc3VidHJhY3QoaW5zLCBkZWYpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoYykpXG4gICAgICAgICAgY2hhbmdlc1twcm9wXSA9IGM7XG4gICAgICB9IGVsc2UgaWYgKCF1dGlsLmlzQXJyYXkoaW5zKSB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gaW5zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbnNjaGVtYXV0aWwubWVyZ2UgPSBmdW5jdGlvbigvKmRlc3QqLCBzcmMwLCBzcmMxLCAuLi4qLyl7XG4gIHZhciBkZXN0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKHZhciBpPTEgOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBtZXJnZShkZXN0LCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxuLy8gcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ29iamVjdCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICBmb3IgKHZhciBwIGluIHNyYykge1xuICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNyY1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNbcF0gIT09ICdvYmplY3QnIHx8IHNyY1twXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IHNyY1twXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0W3BdICE9PSAnb2JqZWN0JyB8fCBkZXN0W3BdID09PSBudWxsKSB7XG4gICAgICBkZXN0W3BdID0gbWVyZ2Uoc3JjW3BdLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge30sIHNyY1twXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlKGRlc3RbcF0sIHNyY1twXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG51dGlsLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIGsgPSBbXSwgeDtcbiAgZm9yICh4IGluIG9iaikgay5wdXNoKHgpO1xuICByZXR1cm4gaztcbn07XG5cbnV0aWwudmFscyA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgdiA9IFtdLCB4O1xuICBmb3IgKHggaW4gb2JqKSB2LnB1c2gob2JqW3hdKTtcbiAgcmV0dXJuIHY7XG59O1xuXG51dGlsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignaW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxudXRpbC5maW5kID0gZnVuY3Rpb24obGlzdCwgcGF0dGVybikge1xuICB2YXIgbCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geFtwYXR0ZXJuLm5hbWVdID09PSBwYXR0ZXJuLnZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGwubGVuZ3RoICYmIGxbMF0gfHwgbnVsbDtcbn07XG5cbnV0aWwuaXNpbiA9IGZ1bmN0aW9uKGl0ZW0sIGFycmF5KSB7XG4gIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbn07XG5cbnV0aWwudW5pcSA9IGZ1bmN0aW9uKGRhdGEsIGZpZWxkKSB7XG4gIHZhciBtYXAgPSB7fSwgY291bnQgPSAwLCBpLCBrO1xuICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIGsgPSBkYXRhW2ldW2ZpZWxkXTtcbiAgICBpZiAoIW1hcFtrXSkge1xuICAgICAgbWFwW2tdID0gMTtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbnZhciBpc051bWJlciA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn07XG5cbi8vIHRyeSBwYXJzaW5nIHRvIG51bWJlclxudXRpbC5udW1iZXJzID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBudW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzTnVtYmVyKHZhbHVlc1tpXSkpIHtcbiAgICAgIG51bXMucHVzaCgrdmFsdWVzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bXM7XG59O1xuXG4vLyB0cnkgdG8gcGFyc2UgYXMgZGF0ZVxudXRpbC5kYXRlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgZGF0ZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGF0ZSA9IERhdGUucGFyc2UodmFsdWVzW2ldKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUpKSB7XG4gICAgICBkYXRlcy5wdXNoKG5ldyBEYXRlKGRhdGUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGVzO1xufTtcblxudXRpbC5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFsdWVzLnNvcnQoZnVuY3Rpb24oYSwgYikge3JldHVybiBhIC0gYjt9KTtcbiAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGgvMik7XG4gIGlmICh2YWx1ZXMubGVuZ3RoICUgMikge1xuICAgIHJldHVybiB2YWx1ZXNbaGFsZl07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh2YWx1ZXNbaGFsZi0xXSArIHZhbHVlc1toYWxmXSkgLyAyLjA7XG4gIH1cbn07XG5cbnV0aWwubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbih2LCByKSB7cmV0dXJuIHYgKyByO30sIDApIC8gdmFsdWVzLmxlbmd0aDtcbn07XG5cbnV0aWwudmFyaWFuY2UgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIGF2ZyA9IHV0aWwubWVhbih2YWx1ZXMpO1xuICB2YXIgZGlmZnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBkaWZmcy5wdXNoKE1hdGgucG93KCh2YWx1ZXNbaV0gLSBhdmcpLCAyKSk7XG4gIH1cbiAgcmV0dXJuIHV0aWwubWVhbihkaWZmcyk7XG59O1xuXG51dGlsLnN0YWJsZXNvcnQgPSBmdW5jdGlvbihhcnJheSwgc29ydEJ5LCBrZXlGbikge1xuICB2YXIgaW5kaWNlcyA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgIGluZGljZXNba2V5Rm4odildID0gaTtcbiAgfSk7XG5cbiAgYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHNhID0gc29ydEJ5KGEpLFxuICAgICAgc2IgPSBzb3J0QnkoYik7XG5cbiAgICByZXR1cm4gc2E8c2IgPyAtMSA6IHNhPnNiID8gMSA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnV0aWwuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh1dGlsLnZhcmlhbmNlKHZhbHVlcykpO1xufTtcblxudXRpbC5za2V3ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBhdmcgPSB1dGlsLm1lYW4odmFsdWVzKSxcbiAgICBtZWQgPSB1dGlsLm1lZGlhbih2YWx1ZXMpLFxuICAgIHN0ZCA9IHV0aWwuc3RkZXYodmFsdWVzKTtcbiAgcmV0dXJuIDEuMCAqIChhdmcgLSBtZWQpIC8gc3RkO1xufTtcblxuLy8gcGFyc2VzIGEgc3RyaW5nIHRvIGRhdGUgb3IgbnVtYmVyXG51dGlsLnBhcnNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuICAgIHJldHVybiArdmFsdWU7XG4gIH1cblxuICB2YXIgZGF0ZSA9IERhdGUucGFyc2UodmFsdWUpO1xuICBpZiAoIWlzTmFOKGRhdGUpKSB7XG4gICAgcmV0dXJuIChuZXcgRGF0ZShkYXRlKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudXRpbC5taW5tYXggPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBzdGF0cyA9IHttaW46ICtJbmZpbml0eSwgbWF4OiAtSW5maW5pdHl9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdiA9IGRhdGFbaV07XG4gICAgaWYgKHYgIT09IG51bGwpIHtcbiAgICAgIGlmICh2ID4gc3RhdHMubWF4IHx8IHN0YXRzLm1heCA9PT0gLUluZmluaXR5KSBzdGF0cy5tYXggPSB2O1xuICAgICAgaWYgKHYgPCBzdGF0cy5taW4gfHwgc3RhdHMubWluID09PSArSW5maW5pdHkpIHN0YXRzLm1pbiA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGF0cztcbn07XG5cbnV0aWwuZHVwbGljYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnV0aWwuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnV0aWwuYXJyYXkgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ID8gKHV0aWwuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107XG59O1xuXG51dGlsLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2guY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgayAsIG9iaik7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLnJlZHVjZSA9IGZ1bmN0aW9uKG9iaiwgZiwgaW5pdCwgdGhpc0FyZykge1xuICBpZiAob2JqLnJlZHVjZSkge1xuICAgIHJldHVybiBvYmoucmVkdWNlLmNhbGwodGhpc0FyZywgZiwgaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGluaXQgPSBmLmNhbGwodGhpc0FyZywgaW5pdCwgb2JqW2tdLCBrLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxufTtcblxudXRpbC5tYXAgPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5tYXApIHtcbiAgICByZXR1cm4gb2JqLm1hcC5jYWxsKHRoaXNBcmcsIGYpO1xuICB9IGVsc2Uge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgb3V0cHV0LnB1c2goIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGssIG9iaikpO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5hbnkgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKGYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG51dGlsLmFsbCA9IGZ1bmN0aW9uKGFyciwgZikge1xuICB2YXIgaSA9IDAsIGs7XG4gIGZvciAoayBpbiBhcnIpIHtcbiAgICBpZiAoIWYoYXJyW2tdLCBrLCBpKyspKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbnV0aWwuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24oZGVzdCwgc3JjKSB7XG4gIHJldHVybiB1dGlsLmtleXMoc3JjKS5yZWR1Y2UoZnVuY3Rpb24oYywgaykge1xuICAgIGNba10gPSBzcmNba107XG4gICAgcmV0dXJuIGM7XG4gIH0sIGRlc3QpO1xufTtcblxudXRpbC5tZXJnZSA9IGZ1bmN0aW9uKC8qZGVzdCosIHNyYzAsIHNyYzEsIC4uLiovKXtcbiAgdmFyIGRlc3QgPSBhcmd1bWVudHNbMF07XG4gIGZvciAodmFyIGk9MSA7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdCA9IG1lcmdlKGRlc3QsIGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG51dGlsLmdldGJpbnMgPSBmdW5jdGlvbihzdGF0cywgbWF4Ymlucykge1xuICByZXR1cm4gdXRpbC5iaW5zKHtcbiAgICBtaW46IHN0YXRzLm1pbixcbiAgICBtYXg6IHN0YXRzLm1heCxcbiAgICBtYXhiaW5zOiBtYXhiaW5zXG4gIH0pO1xufTtcblxuXG51dGlsLmJpbnMgPSBmdW5jdGlvbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIC8vIGRldGVybWluZSByYW5nZVxuICB2YXIgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDEwMjQsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSxcbiAgICAgIG1pbnMgPSBvcHQubWluc3RlcCB8fCAwLFxuICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKSxcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAgPSBNYXRoLm1heChtaW5zLCBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbCkpLFxuICAgICAgbmJpbnMgPSBNYXRoLmNlaWwoc3BhbiAvIHN0ZXApLFxuICAgICAgcHJlY2lzaW9uLCB2LCBpLCBlcHM7XG5cbiAgaWYgKG9wdC5zdGVwKSB7XG4gICAgc3RlcCA9IG9wdC5zdGVwO1xuICB9IGVsc2UgaWYgKG9wdC5zdGVwcykge1xuICAgIC8vIGlmIHByb3ZpZGVkLCBsaW1pdCBjaG9pY2UgdG8gYWNjZXB0YWJsZSBzdGVwIHNpemVzXG4gICAgc3RlcCA9IG9wdC5zdGVwc1tNYXRoLm1pbihcbiAgICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICAgIHV0aWxfYmlzZWN0TGVmdChvcHQuc3RlcHMsIHNwYW4gLyBtYXhiLCAwLCBvcHQuc3RlcHMubGVuZ3RoKVxuICAgICldO1xuICB9IGVsc2Uge1xuICAgIC8vIGluY3JlYXNlIHN0ZXAgc2l6ZSBpZiB0b28gbWFueSBiaW5zXG4gICAgZG8ge1xuICAgICAgc3RlcCAqPSBiYXNlO1xuICAgICAgbmJpbnMgPSBNYXRoLmNlaWwoc3BhbiAvIHN0ZXApO1xuICAgIH0gd2hpbGUgKG5iaW5zID4gbWF4Yik7XG5cbiAgICAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuICAgIGZvciAoaSA9IDA7IGkgPCBkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWlucyAmJiBzcGFuIC8gdiA8PSBtYXhiKSB7XG4gICAgICAgIHN0ZXAgPSB2O1xuICAgICAgICBuYmlucyA9IE1hdGguY2VpbChzcGFuIC8gc3RlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDE7XG4gIGVwcyA9IChtaW48MCA/IC0xIDogMSkgKiBNYXRoLnBvdyhiYXNlLCAtcHJlY2lzaW9uIC0gMSk7XG4gIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5mbG9vcihtaW4gLyBzdGVwICsgZXBzKSAqIHN0ZXApO1xuICBtYXggPSBNYXRoLmNlaWwobWF4IC8gc3RlcCkgKiBzdGVwO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiBtYXgsXG4gICAgc3RlcDogc3RlcCxcbiAgICB1bml0OiBwcmVjaXNpb25cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHV0aWxfYmlzZWN0TGVmdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG4vKipcbiAqIHhbcFswXV0uLi5bcFtuXV0gPSB2YWxcbiAqIEBwYXJhbSBub2F1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5zZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCB2YWwsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGgtMTsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICB4W3BbaV1dID0gdmFsO1xufTtcblxuXG4vKipcbiAqIHJldHVybnMgeFtwWzBdXS4uLltwW25dXVxuICogQHBhcmFtIGF1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5nZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufTtcblxudXRpbC50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyB8fCBcIi4uLlwiO1xuICB2YXIgbCA9IE1hdGgubWF4KDAsIGxlbmd0aCAtIGVsbGlwc2lzLmxlbmd0aCk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmV0dXJuIGVsbGlwc2lzICsgKHdvcmQgPyB2Z190cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHZnX3RydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgKyBlbGxpcHNpcyArXG4gICAgICAgICh3b3JkID8gdmdfdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHZnX3RydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZnX3RydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHZnX3RydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKFwiXCIpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdmdfdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuXG5cbnV0aWwuZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcbiAgY29uc29sZS5lcnJvcignW1ZMIEVycm9yXScsIG1zZyk7XG59O1xuXG4iXX0=\n","'use strict';\n\nvar globals = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema'),\n  time = require('./compile/time');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      marktype: marktype,\n      enc: enc,\n      cfg: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._cfg = specExtended.cfg;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (this._enc[et].aggr === 'count') {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.any = function(f) {\n    return util.any(this._enc, f);\n  };\n\n  proto.all = function(f) {\n    return util.all(this._enc, f);\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec, stats) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.cfg = util.duplicate(this._cfg);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, cfg) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, cfg);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, cfg, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, cfg).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.cfg, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.cfg = spec.cfg || {};\n    spec.cfg.toggleSort = spec.cfg.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.cfg.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.cfg = spec.cfg || {};\n    spec.cfg.filterNull = spec.cfg.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.cfg.filterNull.O = !spec.cfg.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].numNulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else {\n      setter(def, ['properties', 'grid', 'stroke'], {\n        value: encoding.config('gridColor')\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n\n  if (opt.preaggregatedData) {\n    return;\n  }\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = compile;\n\nvar template = compile.template = require('./template'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale'),\n  vlsort = compile.sort = require('./sort'),\n  vlstyle = compile.style = require('./style'),\n  time = compile.time = require('./time'),\n  aggregates = compile.aggregates = require('./aggregates'),\n  binning = compile.binning = require('./binning'),\n  faceting = compile.faceting = require('./faceting'),\n  stacking = compile.stacking = require('./stacking'),\n  subfaceting = compile.subfaceting = require('./subfaceting');\n\ncompile.layout = require('./layout');\ncompile.group = require('./group');\n\nfunction compile(encoding, stats) {\n  var layout = compile.layout(encoding, stats),\n    style = vlstyle(encoding, stats),\n    spec = template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = vlsort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config('useVegaServer');\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  binning(spec.data[1], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if (!preaggregatedData) {\n    spec = time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec, encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfaceting(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n}\n\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  schema = require('../schema/schema'),\n  time = require('./time'),\n  vlfield = require('../field');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength = stats[encoding.fieldName(x)].maxlength;\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(stats[encoding.fieldName(x)].maxlength, 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n","'use strict';\n\nvar global = require('../globals'),\n  time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vegalite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlscale = require('./scale');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n","\"use strict\";\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlfield = require('../field'),\n  Encoding = require('../Encoding');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nvar global = require('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nvar groupdef = require('./group').def,\n  vldata = require('../data');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) { //hack use stats\n\n  var data = {name: RAW, format: {type: encoding.config('dataFormatType')}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = vldata.getUrl(encoding, stats);\n  if (dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config('useVegaServer');\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === 'count') {\n        name = 'count';\n      } else if (preaggregatedData && field.bin) {\n        name = 'bin_' + field.name;\n      } else if (preaggregatedData && field.aggr) {\n        name = field.aggr + '_' + field.name;\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.cardinality -\n        (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n","'use strict';\n\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\n// TODO: rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar vldata = module.exports = {},\n  vlfield = require('./field');\n\nvldata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config('useVegaServer')) {\n    // don't use vega server\n    return encoding.config('dataUrl');\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = [];\n  encoding.forEach(function(field, encType) {\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    };\n    if (field.aggr) {\n      obj.aggr = field.aggr;\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name], encoding.bin(encType).maxbins).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config('vegaServerTable'),\n    fields: fields\n  };\n\n  return encoding.config('vegaServerUrl') + '/query/?q=' + JSON.stringify(query);\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\nvldata.getSchema = function(data, order) {\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    // find non-null data\n    var i = 0, datum = data[i][k];\n    while (datum === '' || datum === null || datum === undefined) {\n      datum = data[++i][k];\n    }\n\n    datum = util.parse(datum);\n    var type = (typeof datum === 'number') ? 'Q':\n      (datum instanceof Date) ? 'T' : 'O';\n\n    schema.push({name: k, type: type});\n  });\n\n  schema = util.stablesort(schema, order || vlfield.order.typeThenName, vlfield.order.name);\n\n  return schema;\n};\n\nvldata.getStats = function(data) { // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var column = data.map(function(d) {return d[k];});\n\n    // Hack\n    var val = util.parse(data[0][k]);\n    var type = (typeof val === 'number') ? 'Q':\n      (val instanceof Date) ? 'T' : 'O';\n\n    var stat = {};\n    if (typeof val === 'number') {\n      stat = util.minmax(util.numbers(column));\n    } else if (val instanceof Date) {\n      stat = util.minmax(util.dates(column));\n    } else {\n      stat = util.minmax(column);\n    }\n\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n\n    stat.maxlength = data.reduce(function(max,row) {\n      if (row[k] === null) {\n        return max;\n      }\n      var len = row[k].toString().length;\n      return len > max ? len : max;\n    }, 0);\n\n    stat.numNulls = data.reduce(function(count, row) {\n      return row[k] === null ? count + 1 : count;\n    }, 0);\n\n    var numbers = util.numbers(column);\n\n    if (numbers.length > 0) {\n      stat.skew = util.skew(numbers);\n      stat.stdev = util.stdev(numbers);\n      stat.mean = util.mean(numbers);\n      stat.median = util.median(numbers);\n    }\n\n    var sample = {};\n    while(Object.keys(sample).length < Math.min(stat.cardinality, 10)) {\n      var value = data[Math.floor(Math.random() * data.length)][k];\n      sample[value] = true;\n    }\n    stat.sample = Object.keys(sample);\n\n    stats[k] = stat;\n  });\n  stats.count = data.length;\n  return stats;\n};\n","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init, i = 0, k;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field, encType) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].cardinality;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stats[field.name], field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  var stat = stats[field.name];\n  return stat.cardinality -\n    (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n","// Package of defining Vegalite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar cfg = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#eeeeee'\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#aaaaaa'\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    },\n\n    // data source\n    dataFormatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    useVegaServer: {\n      type: 'boolean',\n      default: false\n    },\n    dataUrl: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServerTable: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServerUrl: {\n      type: 'string',\n      default: 'http://localhost:3001'\n    }\n  }\n};\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for vegalite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'cfg'],\n  properties: {\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    cfg: cfg\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = {};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.vals = function(obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n};\n\nutil.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\nutil.find = function(list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n};\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.uniq = function(data, field) {\n  var map = {}, count = 0, i, k;\n  for (i = 0; i < data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n};\n\nvar isNumber = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n// try parsing to number\nutil.numbers = function(values) {\n  var nums = [];\n  for (var i = 0; i < values.length; i++) {\n    if (isNumber(values[i])) {\n      nums.push(+values[i]);\n    }\n  }\n  return nums;\n};\n\n// try to parse as date\nutil.dates = function(values) {\n  var dates = [];\n  for (var i = 0; i < values.length; i++) {\n    var date = Date.parse(values[i]);\n    if (!isNaN(date)) {\n      dates.push(new Date(date));\n    }\n  }\n  return dates;\n};\n\nutil.median = function(values) {\n  values.sort(function(a, b) {return a - b;});\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\nutil.mean = function(values) {\n  return values.reduce(function(v, r) {return v + r;}, 0) / values.length;\n};\n\nutil.variance = function(values) {\n  var avg = util.mean(values);\n  var diffs = [];\n  for (var i = 0; i < values.length; i++) {\n    diffs.push(Math.pow((values[i] - avg), 2));\n  }\n  return util.mean(diffs);\n};\n\nutil.stablesort = function(array, sortBy, keyFn) {\n  var indices = {};\n\n  array.forEach(function(v, i) {\n    indices[keyFn(v)] = i;\n  });\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n      sb = sortBy(b);\n\n    return sa<sb ? -1 : sa>sb ? 1 : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n  return array;\n};\n\nutil.stdev = function(values) {\n  return Math.sqrt(util.variance(values));\n};\n\nutil.skew = function(values) {\n  var avg = util.mean(values),\n    med = util.median(values),\n    std = util.stdev(values);\n  return 1.0 * (avg - med) / std;\n};\n\n// parses a string to date or number\nutil.parse = function(value) {\n  if (isNumber(value)) {\n    return +value;\n  }\n\n  var date = Date.parse(value);\n  if (!isNaN(date)) {\n    return (new Date(date));\n  }\n  return value;\n};\n\nutil.minmax = function(data) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (var i = 0; i < data.length; ++i) {\n    var v = data[i];\n    if (v !== null) {\n      if (v > stats.max || stats.max === -Infinity) stats.max = v;\n      if (v < stats.min || stats.min === +Infinity) stats.min = v;\n    }\n  }\n  return stats;\n};\n\nutil.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nutil.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nutil.array = function(x) {\n  return x ? (util.isArray(x) ? x : [x]) : [];\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\n\nutil.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nvar merge = function(dest, src) {\n  return util.keys(src).reduce(function(c, k) {\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n\nutil.bins = function(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 1024,\n      base = opt.base || 10,\n      div = opt.div || [5, 2],\n      mins = opt.minstep || 0,\n      logb = Math.log(base),\n      level = Math.ceil(Math.log(maxb) / logb),\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step = Math.max(mins, Math.pow(base, Math.round(Math.log(span) / logb) - level)),\n      nbins = Math.ceil(span / step),\n      precision, v, i, eps;\n\n  if (opt.step) {\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n        opt.steps.length - 1,\n        util_bisectLeft(opt.steps, span / maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // increase step size if too many bins\n    do {\n      step *= base;\n      nbins = Math.ceil(span / step);\n    } while (nbins > maxb);\n\n    // decrease step size if allowed\n    for (i = 0; i < div.length; ++i) {\n      v = step / div[i];\n      if (v >= mins && span / v <= maxb) {\n        step = v;\n        nbins = Math.ceil(span / step);\n      }\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = (min<0 ? -1 : 1) * Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop: max,\n    step: step,\n    unit: precision\n  };\n};\n\nfunction util_bisectLeft(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis || \"...\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? vg_truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? vg_truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis +\n        (word ? vg_truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? vg_truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction vg_truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(vg_truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar vg_truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n"],"sourceRoot":"/source/"}