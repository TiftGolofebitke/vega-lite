{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","src/Encoding.js","src/axis.js","src/compile.js","src/consts.js","src/data.js","src/globals.js","src/legends.js","src/marks.js","src/scale.js","src/schema.js","src/schemautil.js","src/util.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"vegalite.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var globals = require(\"./globals\"),\n    util = require(\"./util\"),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.schema = require('./schema');\nvl.Encoding = require('./Encoding');\nvl.axis = require('./axis');\nvl.compile = require('./compile');\nvl.data = require('./data');\nvl.legends = require('./legends');\nvl.marks = require('./marks')\nvl.scale = require('./scale');\n\nmodule.exports = vl;","\"use strict\";\n\nvar global = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  schema = require('./schema');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, config) {\n    this._marktype = marktype;\n    this._enc = enc; // {encType1:field1, ...}\n    this._cfg = util.merge(Object.create(consts.DEFAULTS), config);\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(x) {\n    return this._enc[x] !== undefined;\n  };\n\n  proto.enc = function(x){\n    return this._enc[x];\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(x, nodata, nofn) {\n    if (!this.has(x)) return null;\n\n    var f = (nodata ? \"\" : \"data.\");\n\n    if (this._enc[x].aggr === \"count\") {\n      return f + \"count\";\n    } else if (!nofn && this._enc[x].bin) {\n      return f + \"bin_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].aggr) {\n      return f + this._enc[x].aggr + \"_\" + this._enc[x].name;\n    } else if (!nofn && this._enc[x].fn){\n      return f + this._enc[x].fn + \"_\" + this._enc[x].name;\n    } else {\n      return f + this._enc[x].name;\n    }\n  };\n\n  proto.fieldName = function(x){\n    return this._enc[x].name;\n  }\n\n  proto.fieldTitle = function(x){\n    if (this._enc[x].aggr) {\n      return this._enc[x].aggr + \"(\" + this._enc[x].name + \")\";\n    } else {\n      return this._enc[x].name;\n    }\n  }\n\n  proto.scale = function(x){\n    return this._enc[x].scale || {};\n  }\n\n  proto.axis = function(x){\n    return this._enc[x].axis || {};\n  }\n\n  proto.aggr = function(x){\n    return this._enc[x].aggr;\n  }\n\n  proto.bin = function(x){\n    return this._enc[x].bin;\n  }\n\n  proto.legend = function(x){\n    return this._enc[x].legend;\n  }\n\n  proto.fn = function(x){\n    return this._enc[x].fn;\n  }\n\n  proto.any = function(f){\n    return util.any(this._enc, f);\n  }\n\n  proto.all = function(f){\n    return util.all(this._enc, f);\n  }\n\n  proto.length = function(){\n    return util.keys(this._enc).length;\n  }\n\n  proto.reduce = function(f, init){\n    var r = init, i=0;\n    for (k in this._enc){\n      r = f(r, this._enc[k], k, this._enc);\n    }\n    return r;\n  }\n\n  proto.forEach = function(f) {\n    var i=0, k;\n    for (k in this._enc) {\n      f(k, this._enc[k], i++);\n    }\n  };\n\n  proto.type = function(x) {\n    return this.has(x) ? this._enc[x].type : null;\n  };\n\n  proto.isType = function(x, t) {\n    var xt = this.type(x);\n    if (xt == null) return false;\n    return (xt & t) > 0;\n  };\n\n  proto.config = function(name) {\n    return this._cfg[name];\n  };\n\n  proto.toSpec = function(excludeConfig){\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for(var e in enc){\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc\n    }\n\n    if(!excludeConfig){\n      spec.cfg = util.duplicate(this._cfg)\n    }\n\n    return spec;\n  };\n\n  proto.toShorthand = function(){\n    var enc = this._enc;\n    return this._marktype + \".\" + util.keys(enc).map(function(e){\n      var v = enc[e];\n        return e + \"-\" +\n          (v.aggr ? v.aggr+\"_\" : \"\") +\n          (v.fn ? v.fn+\"_\" : \"\") +\n          (v.bin ? \"bin_\" : \"\") +\n          (v.name || \"\") + \"-\" +\n          consts.dataTypeNames[v.type];\n      }\n    ).join(\".\");\n  }\n\n  Encoding.parseShorthand = function(shorthand, cfg){\n    var enc = shorthand.split(\".\"),\n      marktype = enc.shift();\n\n    enc = enc.reduce(function(m, e){\n      var split = e.split(\"-\"),\n        enctype = split[0],\n        o = {name: split[1], type: consts.dataTypes[split[2]]};\n\n      // check aggregate type\n      for(var i in schema.aggr.enum){\n        var a = schema.aggr.enum[i];\n        if(o.name.indexOf(a+\"_\") == 0){\n          o.name = o.name.substr(a.length+1);\n          if (a==\"count\" && o.name.length === 0) o.name = \"*\";\n          o.aggr = a;\n          break;\n        }\n      }\n      // check time fn\n      for(var i in schema.timefns){\n        var f = schema.timefns[i];\n        if(o.name && o.name.indexOf(f+\"_\") == 0){\n          o.name = o.name.substr(o.length+1);\n          o.fn = f;\n          break;\n        }\n      }\n\n      // check bin\n      if(o.name && o.name.indexOf(\"bin_\") == 0){\n        o.name = o.name.substr(4);\n        o.bin = true;\n      }\n\n      m[enctype] = o;\n      return m;\n    }, {});\n\n    return new Encoding(marktype, enc, cfg);\n  }\n\n  Encoding.fromSpec = function(spec, extraCfg) {\n    var enc = util.duplicate(spec.enc);\n\n    //convert type from string to bitcode (e.g, O=1)\n    for(var e in enc){\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, util.merge(spec.cfg, extraCfg || {}));\n  }\n\n  return Encoding;\n\n})();\n","var globals = require('./globals'),\n  util = require('./util');\n\nvar axis = module.exports = {};\n\naxis.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s===X || s===Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\naxis.defs = function(names, encoding, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis_def(name, encoding, opt));\n    return a;\n  }, []);\n}\n\nfunction axis_def(name, encoding, opt){\n  var type = name, axis;\n  var isCol = name==COL, isRow = name==ROW;\n  if(isCol) type = \"x\";\n  if(isRow) type = \"y\";\n\n  var axis = {\n    type: type,\n    scale: name,\n    ticks: 3 //TODO(kanitw): better determine # of ticks\n  };\n\n  if (encoding.axis(name).grid) {\n    axis.grid = true;\n    axis.layer = \"back\";\n  }\n\n  if (encoding.axis(name).title) {\n    //show title by default\n\n    axis = axis_title(axis, name, encoding, opt);\n  }\n\n  if(isRow || isCol){\n    axis.properties = {\n      ticks: { opacity: {value: 0} },\n      majorTicks: { opacity: {value: 0} },\n      axis: { opacity: {value: 0} }\n    };\n  }\n  if(isCol){\n    axis.offset = [opt.xAxisMargin || 0, encoding.config(\"yAxisMargin\")];\n    axis.orient = \"top\";\n  }\n\n  if (name==\"x\" && (encoding.isType(name, O) || encoding.bin(name))) {\n    axis.properties = {\n      labels: {\n        angle: {value: 270},\n        align: {value: \"right\"},\n        baseline: {value: \"middle\"}\n      }\n    }\n  }\n\n  return axis;\n}\n\nfunction axis_title(axis, name, encoding, opt){\n  axis.title = encoding.fieldTitle(name);\n  if(name==Y){\n    axis.titleOffset = 60;\n    // TODO: set appropriate titleOffset\n    // maybe based on some string length from stats\n  }\n  return axis;\n}\n","var globals = require('./globals'),\n  util = require('./util'),\n  axis = require('./axis'),\n  legends = require('./legends'),\n  marks = require('./marks'),\n  scale = require('./scale');\n\nvar compile = module.exports = function(encoding, stats) {\n  var size = setSize(encoding, stats),\n    cellWidth = size.cellWidth,\n    cellHeight = size.cellHeight;\n\n  var hasAgg = encoding.any(function(v, k){\n    return v.aggr !== undefined;\n  });\n\n  var spec = template(encoding, size, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdef = markdef(mark, encoding, {\n      hasAggregate: hasAgg\n    });\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  group.marks.push(mdef);\n  // TODO: return value not used\n  binning(spec.data[0], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if(!preaggregatedData){\n    encoding.forEach(function(encType, field){\n      if(field.type === T && field.fn){\n        timeTransform(spec.data[0], encoding, encType, field);\n      }\n    });\n  }\n\n  // handle subfacets\n  var aggResult = aggregates(spec.data[0], encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && stacking(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isType(X, Q | T) && encoding.isType(Y, O)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    mdef.from.transform = [{type: \"sort\", by: encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding);\n    group.legends = legends.defs(encoding);\n  }\n\n  return spec;\n}\n\nfunction getCardinality(encoding, encType, stats){\n  var field = encoding.fieldName(encType);\n  if (encoding.bin(encType)) {\n    var bins = util.getbins(stats[field]);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  return stats[field].cardinality;\n}\n\nfunction setSize(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y);\n\n  // HACK to set chart size\n  // NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  // One solution is to update Vega to support auto-sizing\n  // In the meantime, auto-padding (mostly) does the trick\n  //\n  var colCardinality = hasCol ? getCardinality(encoding, COL, stats) : 1,\n    rowCardinality = hasRow ? getCardinality(encoding, ROW, stats) : 1;\n\n  var cellWidth = hasX ?\n      +encoding.config(\"cellWidth\") || encoding.config(\"width\") * 1.0 / colCardinality :\n      encoding.marktype() === \"text\" ?\n        +encoding.config(\"textCellWidth\") :\n        +encoding.config(\"bandSize\"),\n    cellHeight = hasY ?\n      +encoding.config(\"cellHeight\") || encoding.config(\"height\") * 1.0 / rowCardinality :\n      +encoding.config(\"bandSize\"),\n    cellPadding = encoding.config(\"cellPadding\"),\n    bandPadding = encoding.config(\"bandPadding\"),\n    width = encoding.config(\"_minWidth\"),\n    height = encoding.config(\"_minHeight\");\n\n  if (hasX && (encoding.isType(X, O) || encoding.bin(X))) { //ordinal field will override parent\n    // bands within cell use rangePoints()\n    var xCardinality = getCardinality(encoding, X, stats);\n    cellWidth = (xCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  width = cellWidth * ((1 + cellPadding) * (colCardinality-1) + 1);\n\n  if (hasY && (encoding.isType(Y, O) || encoding.bin(Y))) {\n    // bands within cell use rangePoint()\n    var yCardinality = getCardinality(encoding, Y, stats);\n    cellHeight = (yCardinality + bandPadding) * +encoding.config(\"bandSize\");\n  }\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n  height = cellHeight * ((1 + cellPadding) * (rowCardinality-1) + 1);\n\n  return {\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    width: width,\n    height:height\n  };\n}\n\nfunction facet(group, encoding, cellHeight, cellWidth, spec, mdef, stack, stats) {\n    var enter = group.properties.enter;\n    var facetKeys = [], cellAxes = [];\n\n    var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n    var xAxisMargin = encoding.has(Y) ? encoding.config(\"xAxisMargin\") : undefined;\n\n    enter.fill = {value: encoding.config(\"cellBackgroundColor\")};\n\n    //move \"from\" to cell level and add facet transform\n    group.from = {data: group.marks[0].from.data};\n\n    if (group.marks[0].from.transform) {\n      delete group.marks[0].from.data; //need to keep transform for subfacetting case\n    } else {\n      delete group.marks[0].from;\n    }\n    if (hasRow) {\n      if (!encoding.isType(ROW, O)) {\n        util.error(\"Row encoding should be ordinal.\");\n      }\n      enter.y = {scale: ROW, field: \"keys.\" + facetKeys.length};\n      enter.height = {\"value\": cellHeight}; // HACK\n\n      facetKeys.push(encoding.field(ROW));\n\n      var from;\n      if (hasCol) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(COL)]});\n      }\n\n      var axesGrp = groupdef(\"x-axes\", {\n          axes: encoding.has(X) ?  axis.defs([\"x\"], encoding) : undefined,\n          x: hasCol ? {scale: COL, field: \"keys.0\", offset: xAxisMargin} : {value: xAxisMargin},\n          width: hasCol && {\"value\": cellWidth}, //HACK?\n          from: from\n        });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || [])\n      spec.axes.push.apply(spec.axes, axis.defs([\"row\"], encoding));\n    } else { // doesn't have row\n      if(encoding.has(X)){\n        //keep x axis in the cell\n        cellAxes.push.apply(cellAxes, axis.defs([\"x\"], encoding));\n      }\n    }\n\n    if (hasCol) {\n      if (!encoding.isType(COL, O)) {\n        util.error(\"Col encoding should be ordinal.\");\n      }\n      enter.x = {scale: COL, field: \"keys.\" + facetKeys.length};\n      enter.width = {\"value\": cellWidth}; // HACK\n\n      facetKeys.push(encoding.field(COL));\n\n      var from;\n      if (hasRow) {\n        from = util.duplicate(group.from);\n        from.transform = from.transform || [];\n        from.transform.unshift({type: \"facet\", keys: [encoding.field(ROW)]});\n      }\n\n      var axesGrp = groupdef(\"y-axes\", {\n        axes: encoding.has(Y) ? axis.defs([\"y\"], encoding) : undefined,\n        y: hasRow && {scale: ROW, field: \"keys.0\"},\n        x: hasRow && {value: xAxisMargin},\n        height: hasRow && {\"value\": cellHeight}, //HACK?\n        from: from\n      });\n\n      spec.marks.push(axesGrp);\n      (spec.axes = spec.axes || [])\n      spec.axes.push.apply(spec.axes, axis.defs([\"col\"], encoding, {\n        xAxisMargin: xAxisMargin\n      }));\n    } else { // doesn't have col\n      if(encoding.has(Y)){\n        cellAxes.push.apply(cellAxes, axis.defs([\"y\"], encoding));\n      }\n    }\n\n    if(hasRow){\n      if(enter.x) enter.x.offset= xAxisMargin;\n      else enter.x = {value: xAxisMargin};\n    }\n    if(hasCol){\n      //TODO fill here..\n    }\n\n    // assuming equal cellWidth here\n    // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n    spec.scales = scale.defs(\n      scale.names(enter).concat(scale.names(mdef.properties.update)),\n      encoding,\n      {cellWidth: cellWidth, cellHeight: cellHeight, stack: stack, facet:true, stats: stats}\n    ); // row/col scales + cell scales\n\n    if (cellAxes.length > 0) {\n      group.axes = cellAxes;\n    }\n\n    // add facet transform\n    var trans = (group.from.transform || (group.from.transform = []));\n    trans.unshift({type: \"facet\", keys: facetKeys});\n\n  return spec;\n  }\n\nfunction subfacet(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef(\"subfacet\", {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: \"facet\", keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: \"sort\", by: encoding.field(COLOR)});\n  }\n}\n\nfunction getTimeFn(fn){\n  switch(fn){\n    case \"second\": return \"getUTCSeconds\";\n    case \"minute\": return \"getUTCMinutes\";\n    case \"hour\": return \"getUTCHours\";\n    case \"day\": return \"getUTCDay\";\n    case \"date\": return \"getUTCDate\";\n    case \"month\": return \"getUTCMonth\";\n    case \"year\": return \"getUTCFullYear\";\n  }\n  console.error(\"no function specified for date\");\n}\n\nfunction timeTransform(spec, encoding, encType, field){\n  var func = getTimeFn(field.fn);\n\n  spec.transform = spec.transform || [];\n  spec.transform.push({\n    type: \"formula\",\n    field: encoding.field(encType),\n    expr: \"new Date(d.data.\"+field.name+\").\"+func+\"()\"\n  });\n  return spec;\n}\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n  encoding.forEach(function(vv, d) {\n    if (d.bin) bins[d.name] = d.name;\n  });\n  bins = util.keys(bins);\n\n  if (bins.length === 0 || opt.preaggregatedData) return false;\n\n  if (!spec.transform) spec.transform = [];\n  bins.forEach(function(d) {\n    spec.transform.push({\n      type: \"bin\",\n      field: \"data.\" + d,\n      output: \"data.bin_\" + d,\n      maxbins: MAX_BINS\n    });\n  });\n  return bins;\n}\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n  var dims = {}, meas = {}, detail = {}, facets={};\n  encoding.forEach(function(encType, field) {\n    if (field.aggr) {\n      if(field.aggr===\"count\"){\n        meas[\"count\"] = {op:\"count\", field:\"*\"};\n      }else{\n        meas[field.aggr+\"|\"+field.name] = {\n          op:field.aggr,\n          field:\"data.\"+field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType==ROW || encType == COL){\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!spec.transform) spec.transform = [];\n    spec.transform.push({\n      type: \"aggregate\",\n      groupby: dims,\n      fields: meas\n    });\n\n    if (encoding.marktype() === TEXT) {\n      meas.forEach( function (m) {\n        var fieldName = m.field.substr(5), //remove \"data.\"\n          field = \"data.\" + (m.op ? m.op + \"_\" : \"\") + fieldName;\n        spec.transform.push({\n          type: \"formula\",\n          field: field,\n          expr: \"d3.format('.2f')(d.\"+field+\")\"\n        });\n      });\n    }\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  }\n}\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n  if (!encoding.has(COLOR)) return false;\n\n  var dim = X, val = Y, idx = 1;\n  if (encoding.isType(X,Q|T) && !encoding.isType(Y,Q|T) && encoding.has(Y)) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: \"aggregate\",\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: \"sum\", field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if(facets && facets.length > 0){\n    stacked.transform.push({ //calculate max for each facet\n      type: \"aggregate\",\n      groupby: facets,\n      fields: [{op: \"max\", field: \"data.sum_\" + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: \"stack\",\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val+\"2\"}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val+\"2\"] = mdef.properties.enter[val+\"2\"] = {scale: val, field: val+\"2\"};\n\n  return val; //return stack encoding\n}\n\n\nfunction markdef(mark, encoding, opt) {\n  var p = mark.prop(encoding, opt)\n  return {\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  };\n}\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: \"group\",\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: \"width\"},\n        height: opt.height || {group: \"height\"}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\nfunction template(encoding, size, stats) { //hack use stats\n\n  var data = {name:TABLE, format: {type: encoding.config(\"dataFormatType\")}},\n    dataUrl = vl.data.getUrl(encoding, stats);\n  if(dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = encoding.config(\"useVegaServer\");\n\n  encoding.forEach(function(encType, field){\n    if(field.type == T){\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = \"date\";\n    }else if(field.type == Q){\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === \"count\") {\n        var name = \"count\";\n      } else if(preaggregatedData && field.bin){\n        var name = \"bin_\" + field.name;\n      } else if(preaggregatedData && field.aggr){\n        var name = field.aggr + \"_\" + field.name;\n      } else{\n        var name = field.name;\n      }\n      data.format.parse[name] = \"number\";\n    }\n  });\n\n  return {\n    width: size.width,\n    height: size.height,\n    padding: \"auto\",\n    data: [data],\n    marks: [groupdef(\"cell\", {\n      width: size.cellWidth ? {value: size.cellWidth}: undefined,\n      height: size.cellHeight ? {value: size.cellHeight} : undefined\n    })]\n  };\n}\n","var globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT];\n\nconsts.dataTypes = {\"O\": O, \"Q\": Q, \"T\": T};\n\nconsts.dataTypeNames = [\"O\",\"Q\",\"T\"].reduce(function(r,x) {\n  r[consts.dataTypes[x]] = x; return r;\n},{});\n\nconsts.DEFAULTS = {\n  // template\n  width: undefined,\n  height: undefined,\n  viewport: undefined,\n  _minWidth: 20,\n  _minHeight: 20,\n\n  // data source\n  dataUrl: undefined, //for easier export\n  useVegaServer: false,\n  vegaServerUrl: \"http://localhost:3001\",\n  vegaServerTable: undefined,\n  dataFormatType: \"json\",\n\n  //small multiples\n  cellHeight: 200, // will be overwritten by bandWidth\n  cellWidth: 200, // will be overwritten by bandWidth\n  cellPadding: 0.1,\n  cellBackgroundColor: \"#fdfdfd\",\n  xAxisMargin: 80,\n  yAxisMargin: 0,\n  textCellWidth: 90,\n\n  // marks\n  bandSize: 21,\n  bandPadding: 1,\n  pointSize: 50,\n  pointShape: \"circle\",\n  strokeWidth: 2,\n  color: \"steelblue\",\n  textColor: \"black\",\n  textAlign: \"left\",\n  textBaseline: \"middle\",\n  textMargin: 4,\n  font: \"Helvetica Neue\",\n  fontSize: \"12\",\n  fontWeight: \"normal\",\n  fontStyle: \"normal\",\n  opacity: 1,\n  _thickOpacity: 0.5,\n  _thinOpacity: 0.2,\n\n  // scales\n  // TODO remove _xZero, ...\n  _xZero: true,\n  _xReverse: false,\n  _yZero: true,\n  _yReverse: false,\n  timeScaleNice: \"day\"\n};","// TODO rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nmodule.exports.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.config(\"useVegaServer\")) {\n    // don't use vega server\n    return encoding.config(\"dataUrl\");\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = []\n  encoding.forEach(function(encType, field){\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    }\n    if (field.aggr) {\n      obj.aggr = field.aggr\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name]).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.config(\"vegaServerTable\"),\n    fields: fields\n  }\n\n  return encoding.config(\"vegaServerUrl\") + \"/query/?q=\" + JSON.stringify(query)\n};\n\nmodule.exports.getStats = function(data){ // hack\n  var stats = {};\n  var fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = util.minmax(data, k);\n    stat.cardinality = util.uniq(data, k);\n\n    var i=0, datum = data[i][k];\n    while(datum === \"\" || datum === null || datum === undefined){\n      datum = data[++i][k];\n    }\n\n    //TODO(kanitw): better type inference here\n    stat.type = (typeof datum === \"number\") ? \"Q\" :\n      isNaN(Date.parse(datum)) ? \"O\" : \"T\";\n    stat.count = data.length;\n    stats[k] = stat;\n  });\n  return stats;\n};\n","// declare global constant\nvar g = global || window;\n\ng.TABLE = \"table\";\ng.STACKED = \"stacked\";\ng.INDEX = \"index\";\n\ng.X = \"x\";\ng.Y = \"y\";\ng.ROW = \"row\";\ng.COL = \"col\";\ng.SIZE = \"size\";\ng.SHAPE = \"shape\";\ng.COLOR = \"color\";\ng.ALPHA = \"alpha\";\ng.TEXT = \"text\";\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n//TODO refactor this to be config?\ng.MAX_BINS = 20;","var global = require('./globals');\n\nvar legends = module.exports = {};\n\nlegends.defs = function(encoding) {\n  var legends = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    legends.push({\n      fill: COLOR,\n      title: encoding.fieldTitle(COLOR),\n      orient: \"right\"\n    });\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    legends.push({\n      size: SIZE,\n      title: encoding.fieldTitle(SIZE),\n      orient: legends.length === 1 ? \"left\" : \"right\"\n    });\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (legends.length === 2) {\n      // TODO: fix this\n      console.error(\"Vegalite currently only supports two legends\");\n      return legends;\n    }\n    legends.push({\n      shape: SHAPE,\n      title: encoding.fieldTitle(SHAPE),\n      orient: legends.length === 1 ? \"left\" : \"right\"\n    });\n  }\n\n  return legends;\n}","var globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar marks = module.exports = {};\n\nmarks.bar = {\n  type: \"rect\",\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.line = {\n  type: \"line\",\n  line: true,\n  prop: line_props,\n  requiredEncoding: [\"x\", \"y\"],\n  supportedEncoding: {row:1, col:1, x:1, y:1, color:1, alpha:1}\n};\n\nmarks.area = {\n  type: \"area\",\n  stack: true,\n  line: true,\n  requiredEncoding: [\"x\", \"y\"],\n  prop: area_props,\n  supportedEncoding: marks.line.supportedEncoding\n};\n\nmarks.circle = {\n  type: \"symbol\",\n  prop: filled_point_props(\"circle\"),\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1}\n};\n\nmarks.square = {\n  type: \"symbol\",\n  prop: filled_point_props(\"square\"),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: \"symbol\",\n  prop: point_props,\n  supportedEncoding: {row:1, col:1, x:1, y:1, size:1, color:1, alpha:1, shape:1}\n};\n\nmarks.text = {\n  type: \"text\",\n  prop: text_props,\n  requiredEncoding: [\"text\"],\n  supportedEncoding: {row:1, col:1, size:1, color:1, alpha:1, text:1}\n};\n\nfunction bar_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T) && !e.bin(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.has(Y) && (!e.isType(Y,Q|T) || e.bin(Y))) {\n      p.x2 = {scale: X, value: 0};\n    }\n  } else if (e.has(X)) {\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T) && !e.bin(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    p.yc = {group: \"height\"};\n  }\n\n  // width\n  if (!e.isType(X,Q|T)) {\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.width = {scale: X, band: true, offset: -1};\n      p.width = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(Y,O) && !e.bin(Y)) {\n    p.width = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // height\n  if (!e.isType(Y,Q|T)) {\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      // p.height = {scale: Y, band: true, offset: -1};\n      p.height = {value: +e.config(\"bandSize\"), offset: -1};\n    }\n  } else if (!e.isType(X,O) && !e.bin(X)) {\n    p.height = {value: +e.config(\"bandSize\"), offset: -1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, opt) {\n  var p = {};\n  opt = opt || {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.config(\"pointSize\")};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.config(\"pointShape\")};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }else{\n    p.opacity = {\n      value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n    };\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction line_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config(\"strokeWidth\")};\n\n  return p;\n}\n\nfunction area_props(e) {\n  var p = {};\n\n  // x\n  if (e.isType(X,Q|T)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (!e.isType(Y,Q|T) && e.has(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: \"horizontal\"};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isType(Y,Q|T)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: \"height\"};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"color\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, opt) {\n    var p = {};\n    opt = opt || {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.config(\"bandSize\")/2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.config(\"bandSize\")/2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.config(\"pointSize\")};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.config(\"color\")};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    }else {\n      p.opacity = {\n        value: e.config(\"opacity\") || e.config(opt.hasAggregate ? \"_thickOpacity\" : \"_thinOpacity\")\n      };\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.config(\"bandSize\")/2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.config(\"bandSize\")/2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(X)) {\n    p.fontSize = {value: e.config(\"fontSize\")};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.config(\"textColor\")};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    p.text = {field: e.field(TEXT)};\n  } else {\n    p.text = {value: \"Abc\"};\n  }\n\n  p.font = {value: e.config(\"font\")};\n  p.fontWeight = {value: e.config(\"fontWeight\")};\n  p.fontStyle = {value: e.config(\"fontStyle\")};\n  p.baseline = {value: e.config(\"textBaseline\")};\n\n  // align\n  if (e.has(X)) {\n    if (e.isType(X,O)) {\n      p.align = {value: \"left\"};\n      p.dx = {value: e.config(\"textMargin\")};\n    } else {\n      p.align = {value: \"center\"}\n    }\n  } else if (e.has(Y)) {\n    p.align = {value: \"left\"};\n    p.dx = {value: e.config(\"textMargin\")};\n  } else {\n    p.align = {value: e.config(\"textAlign\")};\n  }\n\n  return p;\n}","var globals = require(\"./globals\"),\n  util = require(\"./util\");\n\nvar scale = module.exports = {};\n\nscale.names = function (props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n}\n\nscale.defs = function (names, encoding, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale_type(name, encoding),\n      domain: scale_domain(name, encoding, opt)\n    };\n    if (s.type === \"ordinal\" && !encoding.bin(name)) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, opt);\n\n    return (a.push(s), a);\n  }, []);\n}\n\nfunction scale_type(name, encoding) {\n  switch (encoding.type(name)) {\n    case O: return \"ordinal\";\n    case T:\n      if (encoding.fn(name)) {\n        return \"linear\";\n      }\n      return \"time\";\n    case Q:\n      if (encoding.bin(name)) {\n        return \"ordinal\";\n      }\n      return encoding.scale(name).type || \"linear\";\n  }\n}\n\nfunction scale_domain(name, encoding, opt) {\n  if (encoding.type(name) === T){\n    switch(encoding.fn(name)){\n      case \"second\":\n      case \"minute\": return [0, 59];\n      case \"hour\": return [0, 23];\n      case \"day\": return [0, 6];\n      case \"date\": return [1, 31];\n      case \"month\": return [0, 11];\n    }\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)]);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name===Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: \"data.\" + (opt.facet ? \"max_\" :\"\") + \"sum_\" + encoding.field(name, true)\n    }:\n    {data: TABLE, field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellWidth ? [0, opt.cellWidth] : \"width\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_xZero\");\n        s.reverse = spec.reverse || encoding.config(\"_xReverse\");\n      }\n      s.round = true;\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name) || encoding.config(\"timeScaleNice\");\n      }else{\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name)) {\n        s.bandWidth = +encoding.config(\"bandSize\");\n      } else {\n        s.range = opt.cellHeight ? [opt.cellHeight, 0] : \"height\";\n        //TODO zero and reverse should become generic, and we just read default from either the schema or the schema generator\n        s.zero = spec.zero || encoding.config(\"_yZero\");\n        s.reverse = spec.reverse || encoding.config(\"_yReverse\");\n      }\n\n      s.round = true;\n\n      if (encoding.isType(s.name, T)){\n        s.nice = encoding.aggr(s.name);\n      }else{\n        s.nice = true;\n      }\n      break;\n    case ROW:\n      s.bandWidth = opt.cellHeight || encoding.config(\"cellHeight\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL:\n      s.bandWidth = opt.cellWidth || encoding.config(\"cellWidth\");\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is(\"bar\")) {\n        s.range = [3, +encoding.config(\"bandSize\")];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else {\n        s.range = [10, 1000];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = \"shapes\";\n      break;\n    case COLOR:\n      if (encoding.isType(s.name, O)) {\n        s.range = \"category10\";\n      } else {\n        s.range = [\"#ddf\", \"steelblue\"];\n        s.zero = false;\n      }\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error(\"Unknown encoding name: \"+s.name);\n  }\n\n  switch(s.name){\n    case ROW:\n    case COL:\n      s.padding = encoding.config(\"cellPadding\");\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (encoding.isType(s.name, O) || encoding.bin(s.name) ) { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.config(\"bandPadding\");\n      }\n  }\n}","// Defining Vegalite Encoding's schema\nvar schema = module.exports = {};\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: \"string\",\n  enum: [\"point\", \"bar\", \"line\", \"area\", \"circle\", \"square\", \"text\"]\n};\n\nschema.aggr = {\n  type: \"string\",\n  enum: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n  supportedEnums: {\n    Q: [\"avg\", \"sum\", \"min\", \"max\", \"count\"],\n    O: [\"count\"],\n    T: [\"avg\", \"min\", \"max\", \"count\"],\n    \"\": [\"count\"],\n  },\n  supportedTypes: {\"Q\": true, \"O\": true, \"T\": true, \"\": true}\n};\n\nschema.timefns = [\"month\", \"year\", \"day\", \"date\", \"hour\", \"minute\", \"second\"];\n\nschema.fn = {\n  type: \"string\",\n  enum: schema.timefns,\n  supportedTypes: {\"T\": true}\n}\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: \"string\",\n  enum: [\"linear\", \"log\",\"pow\", \"sqrt\", \"quantile\"],\n  default: \"linear\",\n  supportedTypes: {\"Q\": true}\n};\n\nschema.field = {\n  type: \"object\",\n  required: [\"name\", \"type\"],\n  properties: {\n    name: {\n      type: \"string\"\n    }\n  }\n};\n","var util = module.exports = {};\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0\n}\n\n// instantiate a schema\nutil.instantiate = function(schema, required) {\n  if (schema.type === 'object') {\n    schema.required = schema.required ? schema.required : [];\n    var instance = {};\n    for (var name in schema.properties) {\n      var child = schema.properties[name];\n      instance[name] = util.instantiate(child, schema.required.indexOf(name) != -1);\n    };\n    return instance;\n  } else if ('default' in schema) {\n    return schema.default;\n  } else if (schema.enum && required) {\n    return schema.enum[0];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nutil.difference = function(defaults, instance) {\n  var changes = {};\n  for (var prop in instance) {\n    if (!defaults || defaults[prop] !== instance[prop]) {\n      if (typeof instance[prop] == \"object\") {\n        var c = util.difference(defaults[prop], instance[prop]);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else {\n        changes[prop] = instance[prop];\n      }\n    }\n  }\n  return changes;\n};\n\n// recursively merges instance into defaults\nutil.merge = function (defaults, instance) {\n  if (typeof instance!=='object' || instance===null) {\n    return defaults;\n  }\n\n  for (var p in instance) {\n    if (!instance.hasOwnProperty(p))\n      continue;\n    if (instance[p]===undefined )\n      continue;\n    if (typeof instance[p] !== 'object' || instance[p] === null) {\n      defaults[p] = instance[p];\n    } else if (typeof defaults[p] !== 'object' || defaults[p] === null) {\n      defaults[p] = util.merge(instance[p].constructor === Array ? [] : {}, instance[p]);\n    } else {\n      util.merge(defaults[p], instance[p]);\n    }\n  }\n  return defaults;\n}\n","var util = module.exports = {};\n\nutil.keys = function (obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n}\n\nutil.vals = function (obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n}\n\nutil.range = function (start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error(\"infinite range\");\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n}\n\nutil.find = function (list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n}\n\nutil.uniq = function (data, field) {\n  var map = {}, count = 0, i, k;\n  for (i=0; i<data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n}\n\nutil.minmax = function (data, field) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (i=0; i<data.length; ++i) {\n    var v = data[i][field];\n    if (v > stats.max) stats.max = v;\n    if (v < stats.min) stats.min = v;\n  }\n  return stats;\n}\n\nutil.duplicate = function (obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.any = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(f(arr[k], k, i++)) return true;\n  }\n  return false;\n}\n\nutil.all = function(arr, f){\n  var i=0, k;\n  for (k in arr) {\n    if(!f(arr[k], k, i++)) return false;\n  }\n  return true;\n}\n\nutil.merge = function(dest, src){\n  return util.keys(src).reduce(function(c, k){\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.getbins = function (stats) {\n  return vg.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: MAX_BINS\n  });\n}\n\n\nutil.error = function(msg){\n  console.error(\"[VL Error]\", msg);\n}\n\n"]}